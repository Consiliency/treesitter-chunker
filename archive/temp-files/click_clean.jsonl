{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 54, "end_line": 57, "size": 4, "parent_context": 
"", "content": "def hidden_prompt_func(prompt: str) -> str:\n    import getpass\n\n   
return getpass.getpass(prompt)"}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 60, "end_line": 73, "size": 14, "parent_context":
"", "content": "def _build_prompt(\n    text: str,\n    suffix: str,\n    
show_default: bool = False,\n    default: t.Any | None = None,\n    show_choices: bool
= True,\n    type: ParamType | None = None,\n) -> str:\n    prompt = text\n    if type
is not None and show_choices and isinstance(type, Choice):\n        prompt += f\" ({',
'.join(map(str, type.choices))})\"\n    if default is not None and show_default:\n    
prompt = f\"{prompt} [{_format_default(default)}]\"\n    return 
f\"{prompt}{suffix}\""}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 76, "end_line": 80, "size": 5, "parent_context": 
"", "content": "def _format_default(default: t.Any) -> t.Any:\n    if 
isinstance(default, (io.IOBase, LazyFile)) and hasattr(default, \"name\"):\n        
return default.name\n\n    return default"}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 83, "end_line": 191, "size": 109, 
"parent_context": "", "content": "def prompt(\n    text: str,\n    default: t.Any | 
None = None,\n    hide_input: bool = False,\n    confirmation_prompt: bool | str = 
False,\n    type: ParamType | t.Any | None = None,\n    value_proc: t.Callable[, 
t.Any] | None = None,\n    prompt_suffix: str = \": \",\n    show_default: bool = 
True,\n    err: bool = False,\n    show_choices: bool = True,\n) -> t.Any:\n    
\"\"\"Prompts a user for input.  This is a convenience function that can\n    be used 
to prompt a user for input later.\n\n    If the user aborts the input by sending an 
interrupt signal, this\n    function will catch it and raise a :exc:`Abort` 
exception.\n\n    :param text: the text to show for the prompt.\n    :param default: 
the default value to use if no input happens.  If this\n                    is not 
given it will prompt until it's aborted.\n    :param hide_input: if this is set to 
true then the input value will\n                       be hidden.\n    :param 
confirmation_prompt: Prompt a second time to confirm the\n        value. Can be set to
a string instead of ``True`` to customize\n        the message.\n    :param type: the 
type to use to check the value against.\n    :param value_proc: if this parameter is 
provided it's a function that\n                       is invoked instead of the type 
conversion to\n                       convert a value.\n    :param prompt_suffix: a 
suffix that should be added to the prompt.\n    :param show_default: shows or hides 
the default value in the prompt.\n    :param err: if set to true the file defaults to 
``stderr`` instead of\n                ``stdout``, the same as with echo.\n    :param 
show_choices: Show or hide choices if the passed type is a Choice.\n                  
For example if type is a Choice of either day or week,\n                         
show_choices is true and text is \"Group by\" then the\n                         
prompt will be \"Group by (day, week): \".\n\n    .. versionadded:: 8.0\n        
``confirmation_prompt`` can be a custom string.\n\n    .. versionadded:: 7.0\n        
Added the ``show_choices`` parameter.\n\n    .. versionadded:: 6.0\n        Added 
unicode support for cmd.exe on Windows.\n\n    .. versionadded:: 4.0\n        Added 
the `err` parameter.\n\n    \"\"\"\n\n    def prompt_func(text: str) -> str:\n        
f = hidden_prompt_func if hide_input else visible_prompt_func\n        try:\n         
# Write the prompt separately so that we get nice\n            # coloring through 
colorama on Windows\n            echo(text.rstrip(\" \"), nl=False, err=err)\n        
# Echo a space to stdout to work around an issue where\n            # readline causes 
backspace to clear the whole line.\n            return f(\" \")\n        except 
(KeyboardInterrupt, EOFError):\n            # getpass doesn't print a newline if the 
user aborts input with ^C.\n            # Allegedly this behavior is inherited from 
getpass(3).\n            # A doc bug has been filed at 
https://bugs.python.org/issue24711\n            if hide_input:\n                
echo(None, err=err)\n            raise Abort() from None\n\n    if value_proc is 
None:\n        value_proc = convert_type(type, default)\n\n    prompt = 
_build_prompt(\n        text, prompt_suffix, show_default, default, show_choices, 
type\n    )\n\n    if confirmation_prompt:\n        if confirmation_prompt is True:\n 
confirmation_prompt = _(\"Repeat for confirmation\")\n\n        confirmation_prompt = 
_build_prompt(confirmation_prompt, prompt_suffix)\n\n    while True:\n        while 
True:\n            value = prompt_func(prompt)\n            if value:\n               
break\n            elif default is not None:\n                value = default\n       
break\n        try:\n            result = value_proc(value)\n        except UsageError
as e:\n            if hide_input:\n                echo(_(\"Error: The value you 
entered was invalid.\"), err=err)\n            else:\n                echo(_(\"Error: 
{e.message}\").format(e=e), err=err)\n            continue\n        if not 
confirmation_prompt:\n            return result\n        while True:\n            
value2 = prompt_func(confirmation_prompt)\n            is_empty = not value and not 
value2\n            if value2 or is_empty:\n                break\n        if value ==
value2:\n            return result\n        echo(_(\"Error: The two entered values do 
not match.\"), err=err)"}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 136, "end_line": 151, "size": 16, 
"parent_context": "function_definition", "content": "def prompt_func(text: str) -> 
str:\n        f = hidden_prompt_func if hide_input else visible_prompt_func\n        
try:\n            # Write the prompt separately so that we get nice\n            # 
coloring through colorama on Windows\n            echo(text.rstrip(\" \"), nl=False, 
err=err)\n            # Echo a space to stdout to work around an issue where\n        
# readline causes backspace to clear the whole line.\n            return f(\" \")\n   
except (KeyboardInterrupt, EOFError):\n            # getpass doesn't print a newline 
if the user aborts input with ^C.\n            # Allegedly this behavior is inherited 
from getpass(3).\n            # A doc bug has been filed at 
https://bugs.python.org/issue24711\n            if hide_input:\n                
echo(None, err=err)\n            raise Abort() from None"}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 194, "end_line": 252, "size": 59, 
"parent_context": "", "content": "def confirm(\n    text: str,\n    default: bool | 
None = False,\n    abort: bool = False,\n    prompt_suffix: str = \": \",\n    
show_default: bool = True,\n    err: bool = False,\n) -> bool:\n    \"\"\"Prompts for 
confirmation (yes/no question).\n\n    If the user aborts the input by sending a 
interrupt signal this\n    function will catch it and raise a :exc:`Abort` 
exception.\n\n    :param text: the question to ask.\n    :param default: The default 
value to use when no input is given. If\n        ``None``, repeat until input is 
given.\n    :param abort: if this is set to `True` a negative answer aborts the\n     
exception by raising :exc:`Abort`.\n    :param prompt_suffix: a suffix that should be 
added to the prompt.\n    :param show_default: shows or hides the default value in the
prompt.\n    :param err: if set to true the file defaults to ``stderr`` instead of\n  
``stdout``, the same as with echo.\n\n    .. versionchanged:: 8.0\n        Repeat 
until input is given if ``default`` is ``None``.\n\n    .. versionadded:: 4.0\n       
Added the ``err`` parameter.\n    \"\"\"\n    prompt = _build_prompt(\n        text,\n
prompt_suffix,\n        show_default,\n        \"y/n\" if default is None else 
(\"Y/n\" if default else \"y/N\"),\n    )\n\n    while True:\n        try:\n          
# Write the prompt separately so that we get nice\n            # coloring through 
colorama on Windows\n            echo(prompt.rstrip(\" \"), nl=False, err=err)\n      
# Echo a space to stdout to work around an issue where\n            # readline causes 
backspace to clear the whole line.\n            value = visible_prompt_func(\" 
\").lower().strip()\n        except (KeyboardInterrupt, EOFError):\n            raise 
Abort() from None\n        if value in (\"y\", \"yes\"):\n            rv = True\n     
elif value in (\"n\", \"no\"):\n            rv = False\n        elif default is not 
None and value == \"\":\n            rv = default\n        else:\n            
echo(_(\"Error: invalid input\"), err=err)\n            continue\n        break\n    
if abort and not rv:\n        raise Abort()\n    return rv"}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 255, "end_line": 284, "size": 30, 
"parent_context": "", "content": "def echo_via_pager(\n    text_or_generator: 
cabc.Iterable | t.Callable[[], cabc.Iterable] | str,\n    color: bool | None = 
None,\n) -> None:\n    \"\"\"This function takes a text and shows it via an 
environment specific\n    pager on stdout.\n\n    .. versionchanged:: 3.0\n       
Added the `color` flag.\n\n    :param text_or_generator: the text to page, or 
alternatively, a\n                              generator emitting the text to page.\n
:param color: controls if the pager supports ANSI colors or not.  The\n               
default is autodetection.\n    \"\"\"\n    color = resolve_color_default(color)\n\n   
if inspect.isgeneratorfunction(text_or_generator):\n        i = 
t.cast(\"t.Callable[[], cabc.Iterable]\", text_or_generator)()\n    elif 
isinstance(text_or_generator, str):\n        i = \n    else:\n        i = 
iter(t.cast(\"cabc.Iterable\", text_or_generator))\n\n    # convert every element of i
to a text type if necessary\n    text_generator = (el if isinstance(el, str) else 
str(el) for el in i)\n\n    from ._termui_impl import pager\n\n    return 
pager(itertools.chain(text_generator, \"\\n\"), color)"}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 287, "end_line": 304, "size": 18, 
"parent_context": "", "content": "@t.overload\ndef progressbar(\n    *,\n    length: 
int,\n    label: str | None = None,\n    hidden: bool = False,\n    show_eta: bool = 
True,\n    show_percent: bool | None = None,\n    show_pos: bool = False,\n    
fill_char: str = \"#\",\n    empty_char: str = \"-\",\n    bar_template: str = 
\"%(label)s  [%(bar)s]  %(info)s\",\n    info_sep: str = \"  \",\n    width: int = 
36,\n    file: t.TextIO | None = None,\n    color: bool | None = None,\n    
update_min_steps: int = 1,\n) -> ProgressBar: ..."}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 288, "end_line": 304, "size": 17, 
"parent_context": "decorated_definition", "content": "def progressbar(\n    *,\n    
length: int,\n    label: str | None = None,\n    hidden: bool = False,\n    show_eta: 
bool = True,\n    show_percent: bool | None = None,\n    show_pos: bool = False,\n    
fill_char: str = \"#\",\n    empty_char: str = \"-\",\n    bar_template: str = 
\"%(label)s  [%(bar)s]  %(info)s\",\n    info_sep: str = \"  \",\n    width: int = 
36,\n    file: t.TextIO | None = None,\n    color: bool | None = None,\n    
update_min_steps: int = 1,\n) -> ProgressBar: ..."}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 307, "end_line": 325, "size": 19, 
"parent_context": "", "content": "@t.overload\ndef progressbar(\n    iterable: 
cabc.Iterable[V] | None = None,\n    length: int | None = None,\n    label: str | None
= None,\n    hidden: bool = False,\n    show_eta: bool = True,\n    show_percent: bool
| None = None,\n    show_pos: bool = False,\n    item_show_func: t.Callable[[V | 
None], str | None] | None = None,\n    fill_char: str = \"#\",\n    empty_char: str = 
\"-\",\n    bar_template: str = \"%(label)s  [%(bar)s]  %(info)s\",\n    info_sep: str
= \"  \",\n    width: int = 36,\n    file: t.TextIO | None = None,\n    color: bool | 
None = None,\n    update_min_steps: int = 1,\n) -> ProgressBar[V]: ..."}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 308, "end_line": 325, "size": 18, 
"parent_context": "decorated_definition", "content": "def progressbar(\n    iterable: 
cabc.Iterable[V] | None = None,\n    length: int | None = None,\n    label: str | None
= None,\n    hidden: bool = False,\n    show_eta: bool = True,\n    show_percent: bool
| None = None,\n    show_pos: bool = False,\n    item_show_func: t.Callable[[V | 
None], str | None] | None = None,\n    fill_char: str = \"#\",\n    empty_char: str = 
\"-\",\n    bar_template: str = \"%(label)s  [%(bar)s]  %(info)s\",\n    info_sep: str
= \"  \",\n    width: int = 36,\n    file: t.TextIO | None = None,\n    color: bool | 
None = None,\n    update_min_steps: int = 1,\n) -> ProgressBar[V]: ..."}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 328, "end_line": 484, "size": 157, 
"parent_context": "", "content": "def progressbar(\n    iterable: cabc.Iterable[V] | 
None = None,\n    length: int | None = None,\n    label: str | None = None,\n    
hidden: bool = False,\n    show_eta: bool = True,\n    show_percent: bool | None = 
None,\n    show_pos: bool = False,\n    item_show_func: t.Callable[[V | None], str | 
None] | None = None,\n    fill_char: str = \"#\",\n    empty_char: str = \"-\",\n    
bar_template: str = \"%(label)s  [%(bar)s]  %(info)s\",\n    info_sep: str = \"  \",\n
width: int = 36,\n    file: t.TextIO | None = None,\n    color: bool | None = None,\n 
update_min_steps: int = 1,\n) -> ProgressBar[V]:\n    \"\"\"This function creates an 
iterable context manager that can be used\n    to iterate over something while showing
a progress bar.  It will\n    either iterate over the `iterable` or `length` items 
(that are counted\n    up).  While iteration happens, this function will print a 
rendered\n    progress bar to the given `file` (defaults to stdout) and will attempt\n
to calculate remaining time and more.  By default, this progress bar\n    will not be 
rendered if the file is not a terminal.\n\n    The context manager creates the 
progress bar.  When the context\n    manager is entered the progress bar is already 
created.  With every\n    iteration over the progress bar, the iterable passed to the 
bar is\n    advanced and the bar is updated.  When the context manager exits,\n    a 
newline is printed and the progress bar is finalized on screen.\n\n    Note: The 
progress bar is currently designed for use cases where the\n    total progress can be 
expected to take at least several seconds.\n    Because of this, the ProgressBar class
object won't display\n    progress that is considered too fast, and progress where the
time\n    between steps is less than a second.\n\n    No printing must happen or the 
progress bar will be unintentionally\n    destroyed.\n\n    Example usage::\n\n       
with progressbar(items) as bar:\n            for item in bar:\n                
do_something_with(item)\n\n    Alternatively, if no iterable is specified, one can 
manually update the\n    progress bar through the `update()` method instead of 
directly\n    iterating over the progress bar.  The update method accepts the number\n
of steps to increment the bar with::\n\n        with 
progressbar(length=chunks.total_bytes) as bar:\n            for chunk in chunks:\n    
process_chunk(chunk)\n                bar.update(chunks.bytes)\n\n    The ``update()``
method also takes an optional value specifying the\n    ``current_item`` at the new 
position. This is useful when used\n    together with ``item_show_func`` to customize 
the output for each\n    manual step::\n\n        with click.progressbar(\n           
length=total_size,\n            label='Unzipping archive',\n            
item_show_func=lambda a: a.filename\n        ) as bar:\n            for archive in 
zip_file:\n                archive.extract()\n                bar.update(archive.size,
archive)\n\n    :param iterable: an iterable to iterate over.  If not provided the 
length\n                     is required.\n    :param length: the number of items to 
iterate over.  By default the\n                   progressbar will attempt to ask the 
iterator about its\n                   length, which might or might not work.  If an 
iterable is\n                   also provided this parameter can be used to override 
the\n                   length.  If an iterable is not provided the progress bar\n    
will iterate over a range of that length.\n    :param label: the label to show next to
the progress bar.\n    :param hidden: hide the progressbar. Defaults to ``False``. 
When no tty is\n        detected, it will only print the progressbar label. Setting 
this to\n        ``False`` also disables that.\n    :param show_eta: enables or 
disables the estimated time display.  This is\n                     automatically 
disabled if the length cannot be\n                     determined.\n    :param 
show_percent: enables or disables the percentage display.  The\n                      
default is `True` if the iterable has a length or\n                         `False` if
not.\n    :param show_pos: enables or disables the absolute position display.  The\n  
default is `False`.\n    :param item_show_func: A function called with the current 
item which\n        can return a string to show next to the progress bar. If the\n    
function returns ``None`` nothing is shown. The current item can\n        be ``None``,
such as when entering and exiting the bar.\n    :param fill_char: the character to use
to show the filled part of the\n                      progress bar.\n    :param 
empty_char: the character to use to show the non-filled part of\n                     
the progress bar.\n    :param bar_template: the format string to use as template for 
the bar.\n                         The parameters in it are ``label`` for the label,\n
``bar`` for the progress bar and ``info`` for the\n                         info 
section.\n    :param info_sep: the separator between multiple info items (eta etc.)\n 
:param width: the width of the progress bar in characters, 0 means full\n             
terminal width\n    :param file: The file to write to. If this is not a terminal 
then\n        only the label is printed.\n    :param color: controls if the terminal 
supports ANSI colors or not.  The\n                  default is autodetection.  This 
is only needed if ANSI\n                  codes are included anywhere in the progress 
bar output\n                  which is not the case by default.\n    :param 
update_min_steps: Render only when this many updates have\n        completed. This 
allows tuning for very fast iterators.\n\n    .. versionadded:: 8.2\n        The 
``hidden`` argument.\n\n    .. versionchanged:: 8.0\n        Output is shown even if 
execution time is less than 0.5 seconds.\n\n    .. versionchanged:: 8.0\n        
``item_show_func`` shows the current item, not the previous one.\n\n    .. 
versionchanged:: 8.0\n        Labels are echoed if the output is not a TTY. Reverts a 
change\n        in 7.0 that removed all output.\n\n    .. versionadded:: 8.0\n       
The ``update_min_steps`` parameter.\n\n    .. versionadded:: 4.0\n        The 
``color`` parameter and ``update`` method.\n\n    .. versionadded:: 2.0\n    \"\"\"\n 
from ._termui_impl import ProgressBar\n\n    color = resolve_color_default(color)\n   
return ProgressBar(\n        iterable=iterable,\n        length=length,\n        
hidden=hidden,\n        show_eta=show_eta,\n        show_percent=show_percent,\n      
show_pos=show_pos,\n        item_show_func=item_show_func,\n        
fill_char=fill_char,\n        empty_char=empty_char,\n        
bar_template=bar_template,\n        info_sep=info_sep,\n        file=file,\n        
label=label,\n        width=width,\n        color=color,\n        
update_min_steps=update_min_steps,\n    )"}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 487, "end_line": 498, "size": 12, 
"parent_context": "", "content": "def clear() -> None:\n    \"\"\"Clears the terminal 
screen.  This will have the effect of clearing\n    the whole visible space of the 
terminal and moving the cursor to the\n    top left.  This does not do anything if not
connected to a terminal.\n\n    .. versionadded:: 2.0\n    \"\"\"\n    if not 
isatty(sys.stdout):\n        return\n\n    # ANSI escape \\033[2J clears the screen, 
\\033[1;1H moves the cursor\n    echo(\"\\033[2J\\033[1;1H\", nl=False)"}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 501, "end_line": 509, "size": 9, 
"parent_context": "", "content": "def _interpret_color(color: int | tuple | str, 
offset: int = 0) -> str:\n    if isinstance(color, int):\n        return f\"{38 + 
offset};5;{color:d}\"\n\n    if isinstance(color, (tuple, list)):\n        r, g, b = 
color\n        return f\"{38 + offset};2;{r:d};{g:d};{b:d}\"\n\n    return 
str(_ansi_colors + offset)"}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 512, "end_line": 638, "size": 127, 
"parent_context": "", "content": "def style(\n    text: t.Any,\n    fg: int | tuple | 
str | None = None,\n    bg: int | tuple | str | None = None,\n    bold: bool | None = 
None,\n    dim: bool | None = None,\n    underline: bool | None = None,\n    overline:
bool | None = None,\n    italic: bool | None = None,\n    blink: bool | None = None,\n
reverse: bool | None = None,\n    strikethrough: bool | None = None,\n    reset: bool 
= True,\n) -> str:\n    \"\"\"Styles a text with ANSI styles and returns the new 
string.  By\n    default the styling is self contained which means that at the end\n  
of the string a reset code is issued.  This can be prevented by\n    passing 
``reset=False``.\n\n    Examples::\n\n        click.echo(click.style('Hello World!', 
fg='green'))\n        click.echo(click.style('ATTENTION!', blink=True))\n        
click.echo(click.style('Some things', reverse=True, fg='cyan'))\n        
click.echo(click.style('More colors', fg=(255, 12, 128), bg=117))\n\n    Supported 
color names:\n\n    * ``black`` (might be a gray)\n    * ``red``\n    * ``green``\n   
* ``yellow`` (might be an orange)\n    * ``blue``\n    * ``magenta``\n    * ``cyan``\n
* ``white`` (might be light gray)\n    * ``bright_black``\n    * ``bright_red``\n    *
``bright_green``\n    * ``bright_yellow``\n    * ``bright_blue``\n    * 
``bright_magenta``\n    * ``bright_cyan``\n    * ``bright_white``\n    * ``reset`` 
(reset the color code only)\n\n    If the terminal supports it, color may also be 
specified as:\n\n    -   An integer in the interval [0, 255]. The terminal must 
support\n        8-bit/256-color mode.\n    -   An RGB tuple of three integers in [0, 
255]. The terminal must\n        support 24-bit/true-color mode.\n\n    See 
https://en.wikipedia.org/wiki/ANSI_color and\n    
https://gist.github.com/XVilka/8346728 for more information.\n\n    :param text: the 
string to style with ansi codes.\n    :param fg: if provided this will become the 
foreground color.\n    :param bg: if provided this will become the background color.\n
:param bold: if provided this will enable or disable bold mode.\n    :param dim: if 
provided this will enable or disable dim mode.  This is\n                badly 
supported.\n    :param underline: if provided this will enable or disable underline.\n
:param overline: if provided this will enable or disable overline.\n    :param italic:
if provided this will enable or disable italic.\n    :param blink: if provided this 
will enable or disable blinking.\n    :param reverse: if provided this will enable or 
disable inverse\n                    rendering (foreground becomes background and 
the\n                    other way round).\n    :param strikethrough: if provided this
will enable or disable\n        striking through text.\n    :param reset: by default a
reset-all code is added at the end of the\n                  string which means that 
styles do not carry over.  This\n                  can be disabled to compose 
styles.\n\n    .. versionchanged:: 8.0\n        A non-string ``message`` is converted 
to a string.\n\n    .. versionchanged:: 8.0\n       Added support for 256 and RGB 
color codes.\n\n    .. versionchanged:: 8.0\n        Added the ``strikethrough``, 
``italic``, and ``overline``\n        parameters.\n\n    .. versionchanged:: 7.0\n    
Added support for bright colors.\n\n    .. versionadded:: 2.0\n    \"\"\"\n    if not 
isinstance(text, str):\n        text = str(text)\n\n    bits = []\n\n    if fg:\n     
try:\n            bits.append(f\"\\033[{_interpret_color(fg)}m\")\n        except 
KeyError:\n            raise TypeError(f\"Unknown color {fg!r}\") from None\n\n    if 
bg:\n        try:\n            bits.append(f\"\\033[{_interpret_color(bg, 10)}m\")\n  
except KeyError:\n            raise TypeError(f\"Unknown color {bg!r}\") from None\n\n
if bold is not None:\n        bits.append(f\"\\033[{1 if bold else 22}m\")\n    if dim
is not None:\n        bits.append(f\"\\033[{2 if dim else 22}m\")\n    if underline is
not None:\n        bits.append(f\"\\033[{4 if underline else 24}m\")\n    if overline 
is not None:\n        bits.append(f\"\\033[{53 if overline else 55}m\")\n    if italic
is not None:\n        bits.append(f\"\\033[{3 if italic else 23}m\")\n    if blink is 
not None:\n        bits.append(f\"\\033[{5 if blink else 25}m\")\n    if reverse is 
not None:\n        bits.append(f\"\\033[{7 if reverse else 27}m\")\n    if 
strikethrough is not None:\n        bits.append(f\"\\033[{9 if strikethrough else 
29}m\")\n    bits.append(text)\n    if reset:\n        bits.append(_ansi_reset_all)\n 
return \"\".join(bits)"}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 641, "end_line": 650, "size": 10, 
"parent_context": "", "content": "def unstyle(text: str) -> str:\n    \"\"\"Removes 
ANSI styling information from a string.  Usually it's not\n    necessary to use this 
function as Click's echo function will\n    automatically remove styling if 
necessary.\n\n    .. versionadded:: 2.0\n\n    :param text: the text to remove style 
information from.\n    \"\"\"\n    return strip_ansi(text)"}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 653, "end_line": 684, "size": 32, 
"parent_context": "", "content": "def secho(\n    message: t.Any | None = None,\n    
file: t.IO | None = None,\n    nl: bool = True,\n    err: bool = False,\n    color: 
bool | None = None,\n    **styles: t.Any,\n) -> None:\n    \"\"\"This function 
combines :func:`echo` and :func:`style` into one\n    call.  As such the following two
calls are the same::\n\n        click.secho('Hello World!', fg='green')\n        
click.echo(click.style('Hello World!', fg='green'))\n\n    All keyword arguments are 
forwarded to the underlying functions\n    depending on which one they go with.\n\n   
Non-string types will be converted to :class:`str`. However,\n    :class:`bytes` are 
passed directly to :meth:`echo` without applying\n    style. If you want to style 
bytes that represent text, call\n    :meth:`bytes.decode` first.\n\n    .. 
versionchanged:: 8.0\n        A non-string ``message`` is converted to a string. Bytes
are\n        passed through without style applied.\n\n    .. versionadded:: 2.0\n    
\"\"\"\n    if message is not None and not isinstance(message, (bytes, bytearray)):\n 
message = style(message, **styles)\n\n    return echo(message, file=file, nl=nl, 
err=err, color=color)"}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 687, "end_line": 694, "size": 8, 
"parent_context": "", "content": "@t.overload\ndef edit(\n    text: bytes | 
bytearray,\n    editor: str | None = None,\n    env: cabc.Mapping | None = None,\n    
require_save: bool = False,\n    extension: str = \".txt\",\n) -> bytes | None: ..."}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 688, "end_line": 694, "size": 7, 
"parent_context": "decorated_definition", "content": "def edit(\n    text: bytes | 
bytearray,\n    editor: str | None = None,\n    env: cabc.Mapping | None = None,\n    
require_save: bool = False,\n    extension: str = \".txt\",\n) -> bytes | None: ..."}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 697, "end_line": 704, "size": 8, 
"parent_context": "", "content": "@t.overload\ndef edit(\n    text: str,\n    editor: 
str | None = None,\n    env: cabc.Mapping | None = None,\n    require_save: bool = 
True,\n    extension: str = \".txt\",\n) -> str | None: ..."}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 698, "end_line": 704, "size": 7, 
"parent_context": "decorated_definition", "content": "def edit(\n    text: str,\n    
editor: str | None = None,\n    env: cabc.Mapping | None = None,\n    require_save: 
bool = True,\n    extension: str = \".txt\",\n) -> str | None: ..."}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 707, "end_line": 715, "size": 9, 
"parent_context": "", "content": "@t.overload\ndef edit(\n    text: None = None,\n    
editor: str | None = None,\n    env: cabc.Mapping | None = None,\n    require_save: 
bool = True,\n    extension: str = \".txt\",\n    filename: str | cabc.Iterable | None
= None,\n) -> None: ..."}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 708, "end_line": 715, "size": 8, 
"parent_context": "decorated_definition", "content": "def edit(\n    text: None = 
None,\n    editor: str | None = None,\n    env: cabc.Mapping | None = None,\n    
require_save: bool = True,\n    extension: str = \".txt\",\n    filename: str | 
cabc.Iterable | None = None,\n) -> None: ..."}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 718, "end_line": 773, "size": 56, 
"parent_context": "", "content": "def edit(\n    text: str | bytes | bytearray | None 
= None,\n    editor: str | None = None,\n    env: cabc.Mapping | None = None,\n    
require_save: bool = True,\n    extension: str = \".txt\",\n    filename: str | 
cabc.Iterable | None = None,\n) -> str | bytes | bytearray | None:\n    r\"\"\"Edits 
the given text in the defined editor.  If an editor is given\n    (should be the full 
path to the executable but the regular operating\n    system search path is used for 
finding the executable) it overrides\n    the detected editor.  Optionally, some 
environment variables can be\n    used.  If the editor is closed without changes, 
`None` is returned.  In\n    case a file is edited directly the return value is always
`None` and\n    `require_save` and `extension` are ignored.\n\n    If the editor 
cannot be opened a :exc:`UsageError` is raised.\n\n    Note for Windows: to simplify 
cross-platform usage, the newlines are\n    automatically converted from POSIX to 
Windows and vice versa.  As such,\n    the message here will have ``\\n`` as newline 
markers.\n\n    :param text: the text to edit.\n    :param editor: optionally the 
editor to use.  Defaults to automatic\n                   detection.\n    :param env: 
environment variables to forward to the editor.\n    :param require_save: if this is 
true, then not saving in the editor\n                         will make the return 
value become `None`.\n    :param extension: the extension to tell the editor about.  
This defaults\n                      to `.txt` but changing this might change syntax\n
highlighting.\n    :param filename: if provided it will edit this file instead of 
the\n                     provided text contents.  It will not use a temporary\n      
file as an indirection in that case. If the editor supports\n                     
editing multiple files at once, a sequence of files may be\n                     
passed as well. Invoke `click.file` once per file instead\n                     if 
multiple files cannot be managed at once or editing the\n                     files 
serially is desired.\n\n    .. versionchanged:: 8.2.0\n        ``filename`` now 
accepts any ``Iterable`` in addition to a ``str``\n        if the ``editor`` supports 
editing multiple files at once.\n\n    \"\"\"\n    from ._termui_impl import 
Editor\n\n    ed = Editor(editor=editor, env=env, require_save=require_save, 
extension=extension)\n\n    if filename is None:\n        return ed.edit(text)\n\n    
if isinstance(filename, str):\n        filename = (filename,)\n\n    
ed.edit_files(filenames=filename)\n    return None"}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 776, "end_line": 802, "size": 27, 
"parent_context": "", "content": "def launch(url: str, wait: bool = False, locate: 
bool = False) -> int:\n    \"\"\"This function launches the given URL (or filename) in
the default\n    viewer application for this file type.  If this is an executable, 
it\n    might launch the executable in a new session.  The return value is\n    the 
exit code of the launched application.  Usually, ``0`` indicates\n    success.\n\n    
Examples::\n\n        click.launch('https://click.palletsprojects.com/')\n        
click.launch('/my/downloaded/file', locate=True)\n\n    .. versionadded:: 2.0\n\n    
:param url: URL or filename of the thing to launch.\n    :param wait: Wait for the 
program to exit before returning. This\n        only works if the launched program 
blocks. In particular,\n        ``xdg-open`` on Linux does not block.\n    :param 
locate: if this is set to `True` then instead of launching the\n                   
application associated with the URL it will attempt to\n                   launch a 
file manager with the file located.  This\n                   might have weird effects
if the URL does not point to\n                   the filesystem.\n    \"\"\"\n    from
._termui_impl import open_url\n\n    return open_url(url, wait=wait, locate=locate)"}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 810, "end_line": 837, "size": 28, 
"parent_context": "", "content": "def getchar(echo: bool = False) -> str:\n    
\"\"\"Fetches a single character from the terminal and returns it.  This\n    will 
always return a unicode character and under certain rare\n    circumstances this might
return more than one character.  The\n    situations which more than one character is 
returned is when for\n    whatever reason multiple characters end up in the terminal 
buffer or\n    standard input was not actually a terminal.\n\n    Note that this will 
always read from the terminal, even if something\n    is piped into the standard 
input.\n\n    Note for Windows: in rare cases when typing non-ASCII characters, this\n
function might wait for a second character and then return both at once.\n    This is 
because certain Unicode characters look like special-key markers.\n\n    .. 
versionadded:: 2.0\n\n    :param echo: if set to `True`, the character read will also 
show up on\n                 the terminal.  The default is to not show it.\n    
\"\"\"\n    global _getchar\n\n    if _getchar is None:\n        from ._termui_impl 
import getchar as f\n\n        _getchar = f\n\n    return _getchar(echo)"}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 840, "end_line": 843, "size": 4, 
"parent_context": "", "content": "def raw_terminal() -> AbstractContextManager:\n    
from ._termui_impl import raw_terminal as f\n\n    return f()"}
{"file": "click/src/click/termui.py", "language": "python", "node_type": 
"function_definition", "start_line": 846, "end_line": 877, "size": 32, 
"parent_context": "", "content": "def pause(info: str | None = None, err: bool = 
False) -> None:\n    \"\"\"This command stops execution and waits for the user to 
press any\n    key to continue.  This is similar to the Windows batch \"pause\"\n    
command.  If the program is not run through a terminal, this command\n    will instead
do nothing.\n\n    .. versionadded:: 2.0\n\n    .. versionadded:: 4.0\n       Added 
the `err` parameter.\n\n    :param info: The message to print before pausing. Defaults
to\n        ``\"Press any key to continue...\"``.\n    :param err: if set to message 
goes to ``stderr`` instead of\n                ``stdout``, the same as with echo.\n   
\"\"\"\n    if not isatty(sys.stdin) or not isatty(sys.stdout):\n        return\n\n   
if info is None:\n        info = _(\"Press any key to continue...\")\n\n    try:\n    
if info:\n            echo(info, nl=False, err=err)\n        try:\n            
getchar()\n        except (KeyboardInterrupt, EOFError):\n            pass\n    
finally:\n        if info:\n            echo(err=err)"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 19, "end_line": 37, "size": 19, "parent_context":
"", "content": "def _make_text_stream(\n    stream: t.BinaryIO,\n    encoding: str | 
None,\n    errors: str | None,\n    force_readable: bool = False,\n    force_writable:
bool = False,\n) -> t.TextIO:\n    if encoding is None:\n        encoding = 
get_best_encoding(stream)\n    if errors is None:\n        errors = \"replace\"\n    
return _NonClosingTextIOWrapper(\n        stream,\n        encoding,\n        
errors,\n        line_buffering=True,\n        force_readable=force_readable,\n       
force_writable=force_writable,\n    )"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 40, "end_line": 45, "size": 6, "parent_context": 
"", "content": "def is_ascii_encoding(encoding: str) -> bool:\n    \"\"\"Checks if a 
given encoding is ascii.\"\"\"\n    try:\n        return codecs.lookup(encoding).name 
== \"ascii\"\n    except LookupError:\n        return False"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 48, "end_line": 53, "size": 6, "parent_context": 
"", "content": "def get_best_encoding(stream: t.IO) -> str:\n    \"\"\"Returns the 
default stream encoding if not found.\"\"\"\n    rv = getattr(stream, \"encoding\", 
None) or sys.getdefaultencoding()\n    if is_ascii_encoding(rv):\n        return 
\"utf-8\"\n    return rv"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"class_definition", "start_line": 56, "end_line": 79, "size": 24, "parent_context": 
"", "content": "class _NonClosingTextIOWrapper(io.TextIOWrapper):\n    def __init__(\n
self,\n        stream: t.BinaryIO,\n        encoding: str | None,\n        errors: str
| None,\n        force_readable: bool = False,\n        force_writable: bool = 
False,\n        **extra: t.Any,\n    ) -> None:\n        self._stream = stream = 
t.cast(\n            t.BinaryIO, _FixupStream(stream, force_readable, 
force_writable)\n        )\n        super().__init__(stream, encoding, errors, 
**extra)\n\n    def __del__(self) -> None:\n        try:\n            self.detach()\n 
except Exception:\n            pass\n\n    def isatty(self) -> bool:\n        # 
https://bitbucket.org/pypy/pypy/issue/1803\n        return self._stream.isatty()"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 57, "end_line": 69, "size": 13, "parent_context":
"class_definition", "content": "def __init__(\n        self,\n        stream: 
t.BinaryIO,\n        encoding: str | None,\n        errors: str | None,\n        
force_readable: bool = False,\n        force_writable: bool = False,\n        **extra:
t.Any,\n    ) -> None:\n        self._stream = stream = t.cast(\n            
t.BinaryIO, _FixupStream(stream, force_readable, force_writable)\n        )\n        
super().__init__(stream, encoding, errors, **extra)"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 71, "end_line": 75, "size": 5, "parent_context": 
"class_definition", "content": "def __del__(self) -> None:\n        try:\n            
self.detach()\n        except Exception:\n            pass"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 77, "end_line": 79, "size": 3, "parent_context": 
"class_definition", "content": "def isatty(self) -> bool:\n        # 
https://bitbucket.org/pypy/pypy/issue/1803\n        return self._stream.isatty()"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"class_definition", "start_line": 82, "end_line": 148, "size": 67, "parent_context": 
"", "content": "class _FixupStream:\n    \"\"\"The new io interface needs more from 
streams than streams\n    traditionally implement.  As such, this fix-up code is 
necessary in\n    some circumstances.\n\n    The forcing of readable and writable 
flags are there because some tools\n    put badly patched objects on sys (one such 
offender are certain version\n    of jupyter notebook).\n    \"\"\"\n\n    def 
__init__(\n        self,\n        stream: t.BinaryIO,\n        force_readable: bool = 
False,\n        force_writable: bool = False,\n    ):\n        self._stream = stream\n
self._force_readable = force_readable\n        self._force_writable = 
force_writable\n\n    def __getattr__(self, name: str) -> t.Any:\n        return 
getattr(self._stream, name)\n\n    def read1(self, size: int) -> bytes:\n        f = 
getattr(self._stream, \"read1\", None)\n\n        if f is not None:\n            
return t.cast(bytes, f(size))\n\n        return self._stream.read(size)\n\n    def 
readable(self) -> bool:\n        if self._force_readable:\n            return True\n  
x = getattr(self._stream, \"readable\", None)\n        if x is not None:\n            
return t.cast(bool, x())\n        try:\n            self._stream.read(0)\n        
except Exception:\n            return False\n        return True\n\n    def 
writable(self) -> bool:\n        if self._force_writable:\n            return True\n  
x = getattr(self._stream, \"writable\", None)\n        if x is not None:\n            
return t.cast(bool, x())\n        try:\n            self._stream.write(b\"\")\n       
except Exception:\n            try:\n                self._stream.write(b\"\")\n      
except Exception:\n                return False\n        return True\n\n    def 
seekable(self) -> bool:\n        x = getattr(self._stream, \"seekable\", None)\n      
if x is not None:\n            return t.cast(bool, x())\n        try:\n            
self._stream.seek(self._stream.tell())\n        except Exception:\n            return 
False\n        return True"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 92, "end_line": 100, "size": 9, "parent_context":
"class_definition", "content": "def __init__(\n        self,\n        stream: 
t.BinaryIO,\n        force_readable: bool = False,\n        force_writable: bool = 
False,\n    ):\n        self._stream = stream\n        self._force_readable = 
force_readable\n        self._force_writable = force_writable"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 102, "end_line": 103, "size": 2, 
"parent_context": "class_definition", "content": "def __getattr__(self, name: str) -> 
t.Any:\n        return getattr(self._stream, name)"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 105, "end_line": 111, "size": 7, 
"parent_context": "class_definition", "content": "def read1(self, size: int) -> 
bytes:\n        f = getattr(self._stream, \"read1\", None)\n\n        if f is not 
None:\n            return t.cast(bytes, f(size))\n\n        return 
self._stream.read(size)"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 113, "end_line": 123, "size": 11, 
"parent_context": "class_definition", "content": "def readable(self) -> bool:\n       
if self._force_readable:\n            return True\n        x = getattr(self._stream, 
\"readable\", None)\n        if x is not None:\n            return t.cast(bool, x())\n
try:\n            self._stream.read(0)\n        except Exception:\n            return 
False\n        return True"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 125, "end_line": 138, "size": 14, 
"parent_context": "class_definition", "content": "def writable(self) -> bool:\n       
if self._force_writable:\n            return True\n        x = getattr(self._stream, 
\"writable\", None)\n        if x is not None:\n            return t.cast(bool, x())\n
try:\n            self._stream.write(b\"\")\n        except Exception:\n            
try:\n                self._stream.write(b\"\")\n            except Exception:\n      
return False\n        return True"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 140, "end_line": 148, "size": 9, 
"parent_context": "class_definition", "content": "def seekable(self) -> bool:\n       
x = getattr(self._stream, \"seekable\", None)\n        if x is not None:\n            
return t.cast(bool, x())\n        try:\n            
self._stream.seek(self._stream.tell())\n        except Exception:\n            return 
False\n        return True"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 151, "end_line": 157, "size": 7, 
"parent_context": "", "content": "def _is_binary_reader(stream: t.IO, default: bool = 
False) -> bool:\n    try:\n        return isinstance(stream.read(0), bytes)\n    
except Exception:\n        return default\n        # This happens in some cases where 
the stream was already\n        # closed.  In this case, we assume the default."}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 160, "end_line": 170, "size": 11, 
"parent_context": "", "content": "def _is_binary_writer(stream: t.IO, default: bool = 
False) -> bool:\n    try:\n        stream.write(b\"\")\n    except Exception:\n       
try:\n            stream.write(\"\")\n            return False\n        except 
Exception:\n            pass\n        return default\n    return True"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 173, "end_line": 188, "size": 16, 
"parent_context": "", "content": "def _find_binary_reader(stream: t.IO) -> t.BinaryIO 
| None:\n    # We need to figure out if the given stream is already binary.\n    # 
This can happen because the official docs recommend detaching\n    # the streams to 
get binary streams.  Some code might do this, so\n    # we need to deal with this case
explicitly.\n    if _is_binary_reader(stream, False):\n        return 
t.cast(t.BinaryIO, stream)\n\n    buf = getattr(stream, \"buffer\", None)\n\n    # 
Same situation here; this time we assume that the buffer is\n    # actually binary in 
case it's closed.\n    if buf is not None and _is_binary_reader(buf, True):\n        
return t.cast(t.BinaryIO, buf)\n\n    return None"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 191, "end_line": 206, "size": 16, 
"parent_context": "", "content": "def _find_binary_writer(stream: t.IO) -> t.BinaryIO 
| None:\n    # We need to figure out if the given stream is already binary.\n    # 
This can happen because the official docs recommend detaching\n    # the streams to 
get binary streams.  Some code might do this, so\n    # we need to deal with this case
explicitly.\n    if _is_binary_writer(stream, False):\n        return 
t.cast(t.BinaryIO, stream)\n\n    buf = getattr(stream, \"buffer\", None)\n\n    # 
Same situation here; this time we assume that the buffer is\n    # actually binary in 
case it's closed.\n    if buf is not None and _is_binary_writer(buf, True):\n        
return t.cast(t.BinaryIO, buf)\n\n    return None"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 209, "end_line": 215, "size": 7, 
"parent_context": "", "content": "def _stream_is_misconfigured(stream: t.TextIO) -> 
bool:\n    \"\"\"A stream is misconfigured if its encoding is ASCII.\"\"\"\n    # If 
the stream does not have an encoding set, we assume it's set\n    # to ASCII.  This 
appears to happen in certain unittest\n    # environments.  It's not quite clear what 
the correct behavior is\n    # but this at least will force Click to recover 
somehow.\n    return is_ascii_encoding(getattr(stream, \"encoding\", None) or 
\"ascii\")"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 218, "end_line": 224, "size": 7, 
"parent_context": "", "content": "def _is_compat_stream_attr(stream: t.TextIO, attr: 
str, value: str | None) -> bool:\n    \"\"\"A stream attribute is compatible if it is 
equal to the\n    desired value or the desired value is unset and the attribute\n    
has a value.\n    \"\"\"\n    stream_value = getattr(stream, attr, None)\n    return 
stream_value == value or (value is None and stream_value is not None)"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 227, "end_line": 235, "size": 9, 
"parent_context": "", "content": "def _is_compatible_text_stream(\n    stream: 
t.TextIO, encoding: str | None, errors: str | None\n) -> bool:\n    \"\"\"Check if a 
stream's encoding and errors attributes are\n    compatible with the desired values.\n
\"\"\"\n    return _is_compat_stream_attr(\n        stream, \"encoding\", encoding\n  
) and _is_compat_stream_attr(stream, \"errors\", errors)"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 238, "end_line": 281, "size": 44, 
"parent_context": "", "content": "def _force_correct_text_stream(\n    text_stream: 
t.IO,\n    encoding: str | None,\n    errors: str | None,\n    is_binary: 
t.Callable[[t.IO, bool], bool],\n    find_binary: t.Callable[[t.IO], t.BinaryIO | 
None],\n    force_readable: bool = False,\n    force_writable: bool = False,\n) -> 
t.TextIO:\n    if is_binary(text_stream, False):\n        binary_reader = 
t.cast(t.BinaryIO, text_stream)\n    else:\n        text_stream = t.cast(t.TextIO, 
text_stream)\n        # If the stream looks compatible, and won't default to a\n      
# misconfigured ascii encoding, return it as-is.\n        if 
_is_compatible_text_stream(text_stream, encoding, errors) and not (\n            
encoding is None and _stream_is_misconfigured(text_stream)\n        ):\n            
return text_stream\n\n        # Otherwise, get the underlying binary reader.\n        
possible_binary_reader = find_binary(text_stream)\n\n        # If that's not possible,
silently use the original reader\n        # and get mojibake instead of exceptions.\n 
if possible_binary_reader is None:\n            return text_stream\n\n        
binary_reader = possible_binary_reader\n\n    # Default errors to replace instead of 
strict in order to get\n    # something that works.\n    if errors is None:\n        
errors = \"replace\"\n\n    # Wrap the binary stream in a text stream with the 
correct\n    # encoding parameters.\n    return _make_text_stream(\n        
binary_reader,\n        encoding,\n        errors,\n        
force_readable=force_readable,\n        force_writable=force_writable,\n    )"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 284, "end_line": 297, "size": 14, 
"parent_context": "", "content": "def _force_correct_text_reader(\n    text_reader: 
t.IO,\n    encoding: str | None,\n    errors: str | None,\n    force_readable: bool = 
False,\n) -> t.TextIO:\n    return _force_correct_text_stream(\n        text_reader,\n
encoding,\n        errors,\n        _is_binary_reader,\n        _find_binary_reader,\n
force_readable=force_readable,\n    )"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 300, "end_line": 313, "size": 14, 
"parent_context": "", "content": "def _force_correct_text_writer(\n    text_writer: 
t.IO,\n    encoding: str | None,\n    errors: str | None,\n    force_writable: bool = 
False,\n) -> t.TextIO:\n    return _force_correct_text_stream(\n        text_writer,\n
encoding,\n        errors,\n        _is_binary_writer,\n        _find_binary_writer,\n
force_writable=force_writable,\n    )"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 316, "end_line": 320, "size": 5, 
"parent_context": "", "content": "def get_binary_stdin() -> t.BinaryIO:\n    reader = 
_find_binary_reader(sys.stdin)\n    if reader is None:\n        raise 
RuntimeError(\"Was not able to determine binary stream for sys.stdin.\")\n    return 
reader"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 323, "end_line": 327, "size": 5, 
"parent_context": "", "content": "def get_binary_stdout() -> t.BinaryIO:\n    writer =
_find_binary_writer(sys.stdout)\n    if writer is None:\n        raise 
RuntimeError(\"Was not able to determine binary stream for sys.stdout.\")\n    return 
writer"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 330, "end_line": 334, "size": 5, 
"parent_context": "", "content": "def get_binary_stderr() -> t.BinaryIO:\n    writer =
_find_binary_writer(sys.stderr)\n    if writer is None:\n        raise 
RuntimeError(\"Was not able to determine binary stream for sys.stderr.\")\n    return 
writer"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 337, "end_line": 341, "size": 5, 
"parent_context": "", "content": "def get_text_stdin(encoding: str | None = None, 
errors: str | None = None) -> t.TextIO:\n    rv = 
_get_windows_console_stream(sys.stdin, encoding, errors)\n    if rv is not None:\n    
return rv\n    return _force_correct_text_reader(sys.stdin, encoding, errors, 
force_readable=True)"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 344, "end_line": 348, "size": 5, 
"parent_context": "", "content": "def get_text_stdout(encoding: str | None = None, 
errors: str | None = None) -> t.TextIO:\n    rv = 
_get_windows_console_stream(sys.stdout, encoding, errors)\n    if rv is not None:\n   
return rv\n    return _force_correct_text_writer(sys.stdout, encoding, errors, 
force_writable=True)"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 351, "end_line": 355, "size": 5, 
"parent_context": "", "content": "def get_text_stderr(encoding: str | None = None, 
errors: str | None = None) -> t.TextIO:\n    rv = 
_get_windows_console_stream(sys.stderr, encoding, errors)\n    if rv is not None:\n   
return rv\n    return _force_correct_text_writer(sys.stderr, encoding, errors, 
force_writable=True)"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 358, "end_line": 368, "size": 11, 
"parent_context": "", "content": "def _wrap_io_open(\n    file: str | os.PathLike | 
int,\n    mode: str,\n    encoding: str | None,\n    errors: str | None,\n) -> t.IO:\n
\"\"\"Handles not passing ``encoding`` and ``errors`` in binary mode.\"\"\"\n    if 
\"b\" in mode:\n        return open(file, mode)\n\n    return open(file, mode, 
encoding=encoding, errors=errors)"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 371, "end_line": 449, "size": 79, 
"parent_context": "", "content": "def open_stream(\n    filename: str | os.PathLike,\n
mode: str = \"r\",\n    encoding: str | None = None,\n    errors: str | None = 
\"strict\",\n    atomic: bool = False,\n) -> tuple[t.IO, bool]:\n    binary = \"b\" in
mode\n    filename = os.fspath(filename)\n\n    # Standard streams first. These are 
simple because they ignore the\n    # atomic flag. Use fsdecode to handle 
Path(\"-\").\n    if os.fsdecode(filename) == \"-\":\n        if any(m in mode for m 
in [\"w\", \"a\", \"x\"]):\n            if binary:\n                return 
get_binary_stdout(), False\n            return get_text_stdout(encoding=encoding, 
errors=errors), False\n        if binary:\n            return get_binary_stdin(), 
False\n        return get_text_stdin(encoding=encoding, errors=errors), False\n\n    #
Non-atomic writes directly go out through the regular open functions.\n    if not 
atomic:\n        return _wrap_io_open(filename, mode, encoding, errors), True\n\n    #
Some usability stuff for atomic writes\n    if \"a\" in mode:\n        raise 
ValueError(\n            \"Appending to an existing file is not supported, because 
that\"\n            \" would involve an expensive `copy`-operation to a temporary\"\n 
\" file. Open the file in normal `w`-mode and copy explicitly\"\n            \" if 
that's what you're after.\"\n        )\n    if \"x\" in mode:\n        raise 
ValueError(\"Use the `overwrite`-parameter instead.\")\n    if \"w\" not in mode:\n   
raise ValueError(\"Atomic writes only make sense with `w`-mode.\")\n\n    # Atomic 
writes are more complicated.  They work by opening a file\n    # as a proxy in the 
same folder and then using the fdopen\n    # functionality to wrap it in a Python 
file.  Then we wrap it in an\n    # atomic file that moves the file over on close.\n  
import errno\n    import random\n\n    try:\n        perm: int | None = 
os.stat(filename).st_mode\n    except OSError:\n        perm = None\n\n    flags = 
os.O_RDWR | os.O_CREAT | os.O_EXCL\n\n    if binary:\n        flags |= getattr(os, 
\"O_BINARY\", 0)\n\n    while True:\n        tmp_filename = os.path.join(\n           
os.path.dirname(filename),\n            f\".__atomic-write{random.randrange(1 << 
32):08x}\",\n        )\n        try:\n            fd = os.open(tmp_filename, flags, 
0o666 if perm is None else perm)\n            break\n        except OSError as e:\n   
if e.errno == errno.EEXIST or (\n                os.name == \"nt\"\n                
and e.errno == errno.EACCES\n                and os.path.isdir(e.filename)\n          
and os.access(e.filename, os.W_OK)\n            ):\n                continue\n        
raise\n\n    if perm is not None:\n        os.chmod(tmp_filename, perm)  # in case 
perm includes bits in umask\n\n    f = _wrap_io_open(fd, mode, encoding, errors)\n    
af = _AtomicFile(f, tmp_filename, os.path.realpath(filename))\n    return t.cast(t.IO,
af), True"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"class_definition", "start_line": 452, "end_line": 485, "size": 34, "parent_context": 
"", "content": "class _AtomicFile:\n    def __init__(self, f: t.IO, tmp_filename: str,
real_filename: str) -> None:\n        self._f = f\n        self._tmp_filename = 
tmp_filename\n        self._real_filename = real_filename\n        self.closed = 
False\n\n    @property\n    def name(self) -> str:\n        return 
self._real_filename\n\n    def close(self, delete: bool = False) -> None:\n        if 
self.closed:\n            return\n        self._f.close()\n        
os.replace(self._tmp_filename, self._real_filename)\n        self.closed = True\n\n   
def __getattr__(self, name: str) -> t.Any:\n        return getattr(self._f, name)\n\n 
def __enter__(self) -> _AtomicFile:\n        return self\n\n    def __exit__(\n       
self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException
| None,\n        tb: TracebackType | None,\n    ) -> None:\n        
self.close(delete=exc_type is not None)\n\n    def __repr__(self) -> str:\n        
return repr(self._f)"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 453, "end_line": 457, "size": 5, 
"parent_context": "class_definition", "content": "def __init__(self, f: t.IO, 
tmp_filename: str, real_filename: str) -> None:\n        self._f = f\n        
self._tmp_filename = tmp_filename\n        self._real_filename = real_filename\n      
self.closed = False"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 459, "end_line": 461, "size": 3, 
"parent_context": "class_definition", "content": "@property\n    def name(self) -> 
str:\n        return self._real_filename"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 460, "end_line": 461, "size": 2, 
"parent_context": "decorated_definition", "content": "def name(self) -> str:\n        
return self._real_filename"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 463, "end_line": 468, "size": 6, 
"parent_context": "class_definition", "content": "def close(self, delete: bool = 
False) -> None:\n        if self.closed:\n            return\n        
self._f.close()\n        os.replace(self._tmp_filename, self._real_filename)\n        
self.closed = True"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 470, "end_line": 471, "size": 2, 
"parent_context": "class_definition", "content": "def __getattr__(self, name: str) -> 
t.Any:\n        return getattr(self._f, name)"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 473, "end_line": 474, "size": 2, 
"parent_context": "class_definition", "content": "def __enter__(self) -> 
_AtomicFile:\n        return self"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 476, "end_line": 482, "size": 7, 
"parent_context": "class_definition", "content": "def __exit__(\n        self,\n      
exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n     
tb: TracebackType | None,\n    ) -> None:\n        self.close(delete=exc_type is not 
None)"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 484, "end_line": 485, "size": 2, 
"parent_context": "class_definition", "content": "def __repr__(self) -> str:\n        
return repr(self._f)"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 488, "end_line": 489, "size": 2, 
"parent_context": "", "content": "def strip_ansi(value: str) -> str:\n    return 
_ansi_re.sub(\"\", value)"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 492, "end_line": 496, "size": 5, 
"parent_context": "", "content": "def _is_jupyter_kernel_output(stream: t.IO) -> 
bool:\n    while isinstance(stream, (_FixupStream, _NonClosingTextIOWrapper)):\n      
stream = stream._stream\n\n    return 
stream.__class__.__module__.startswith(\"ipykernel.\")"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 499, "end_line": 506, "size": 8, 
"parent_context": "", "content": "def should_strip_ansi(\n    stream: t.IO | None = 
None, color: bool | None = None\n) -> bool:\n    if color is None:\n        if stream 
is None:\n            stream = sys.stdin\n        return not isatty(stream) and not 
_is_jupyter_kernel_output(stream)\n    return not color"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 515, "end_line": 518, "size": 4, 
"parent_context": "", "content": "def _get_argv_encoding() -> str:\n        import 
locale\n\n        return locale.getpreferredencoding()"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 522, "end_line": 555, "size": 34, 
"parent_context": "", "content": "def auto_wrap_for_ansi(stream: t.TextIO, color: bool
| None = None) -> t.TextIO:\n        \"\"\"Support ANSI color and style codes on 
Windows by wrapping a\n        stream with colorama.\n        \"\"\"\n        try:\n  
cached = _ansi_stream_wrappers.get(stream)\n        except Exception:\n            
cached = None\n\n        if cached is not None:\n            return cached\n\n        
import colorama\n\n        strip = should_strip_ansi(stream, color)\n        
ansi_wrapper = colorama.AnsiToWin32(stream, strip=strip)\n        rv = 
t.cast(t.TextIO, ansi_wrapper.stream)\n        _write = rv.write\n\n        def 
_safe_write(s: str) -> int:\n            try:\n                return _write(s)\n     
except BaseException:\n                ansi_wrapper.reset_all()\n                
raise\n\n        rv.write = _safe_write  # type: ignore\n\n        try:\n            
_ansi_stream_wrappers = rv\n        except Exception:\n            pass\n\n        
return rv"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 541, "end_line": 546, "size": 6, 
"parent_context": "function_definition", "content": "def _safe_write(s: str) -> int:\n
try:\n                return _write(s)\n            except BaseException:\n           
ansi_wrapper.reset_all()\n                raise"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 559, "end_line": 560, "size": 2, 
"parent_context": "", "content": "def _get_argv_encoding() -> str:\n        return 
getattr(sys.stdin, \"encoding\", None) or sys.getfilesystemencoding()"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 562, "end_line": 565, "size": 4, 
"parent_context": "", "content": "def _get_windows_console_stream(\n        f: 
t.TextIO, encoding: str | None, errors: str | None\n    ) -> t.TextIO | None:\n       
return None"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 568, "end_line": 569, "size": 2, 
"parent_context": "", "content": "def term_len(x: str) -> int:\n    return 
len(strip_ansi(x))"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 572, "end_line": 576, "size": 5, 
"parent_context": "", "content": "def isatty(stream: t.IO) -> bool:\n    try:\n       
return stream.isatty()\n    except Exception:\n        return False"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 579, "end_line": 604, "size": 26, 
"parent_context": "", "content": "def _make_cached_stream_func(\n    src_func: 
t.Callable[[], t.TextIO | None],\n    wrapper_func: t.Callable[[], t.TextIO],\n) -> 
t.Callable[[], t.TextIO | None]:\n    cache: cabc.MutableMapping = 
WeakKeyDictionary()\n\n    def func() -> t.TextIO | None:\n        stream = 
src_func()\n\n        if stream is None:\n            return None\n\n        try:\n   
rv = cache.get(stream)\n        except Exception:\n            rv = None\n        if 
rv is not None:\n            return rv\n        rv = wrapper_func()\n        try:\n   
cache = rv\n        except Exception:\n            pass\n        return rv\n\n    
return func"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": 
"function_definition", "start_line": 585, "end_line": 602, "size": 18, 
"parent_context": "function_definition", "content": "def func() -> t.TextIO | None:\n 
stream = src_func()\n\n        if stream is None:\n            return None\n\n        
try:\n            rv = cache.get(stream)\n        except Exception:\n            rv = 
None\n        if rv is not None:\n            return rv\n        rv = wrapper_func()\n
try:\n            cache = rv\n        except Exception:\n            pass\n        
return rv"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": "lambda", 
"start_line": 607, "end_line": 607, "size": 1, "parent_context": "", "content": 
"lambda: sys.stdin"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": "lambda", 
"start_line": 607, "end_line": 607, "size": 1, "parent_context": "lambda", "content": 
"lambda"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": "lambda", 
"start_line": 608, "end_line": 608, "size": 1, "parent_context": "", "content": 
"lambda: sys.stdout"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": "lambda", 
"start_line": 608, "end_line": 608, "size": 1, "parent_context": "lambda", "content": 
"lambda"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": "lambda", 
"start_line": 609, "end_line": 609, "size": 1, "parent_context": "", "content": 
"lambda: sys.stderr"}
{"file": "click/src/click/_compat.py", "language": "python", "node_type": "lambda", 
"start_line": 609, "end_line": 609, "size": 1, "parent_context": "lambda", "content": 
"lambda"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 52, "end_line": 109, "size": 58, 
"parent_context": "", "content": "def _unpack_args(\n    args: cabc.Sequence, 
nargs_spec: cabc.Sequence\n) -> tuple[cabc.Sequence[str | cabc.Sequence | None], 
list]:\n    \"\"\"Given an iterable of arguments and an iterable of nargs 
specifications,\n    it returns a tuple with all the unpacked arguments at the first 
index\n    and all remaining arguments as the second.\n\n    The nargs specification 
is the number of arguments that should be consumed\n    or `-1` to indicate that this 
position should eat up all the remainders.\n\n    Missing items are filled with 
`None`.\n    \"\"\"\n    args = deque(args)\n    nargs_spec = deque(nargs_spec)\n    
rv: list[str | tuple | None] = []\n    spos: int | None = None\n\n    def _fetch(c: 
deque[V]) -> V | None:\n        try:\n            if spos is None:\n                
return c.popleft()\n            else:\n                return c.pop()\n        except 
IndexError:\n            return None\n\n    while nargs_spec:\n        nargs = 
_fetch(nargs_spec)\n\n        if nargs is None:\n            continue\n\n        if 
nargs == 1:\n            rv.append(_fetch(args))\n        elif nargs > 1:\n           
x = [_fetch(args) for _ in range(nargs)]\n\n            # If we're reversed, we're 
pulling in the arguments in reverse,\n            # so we need to turn them around.\n 
if spos is not None:\n                x.reverse()\n\n            rv.append(tuple(x))\n
elif nargs < 0:\n            if spos is not None:\n                raise 
TypeError(\"Cannot have two nargs < 0\")\n\n            spos = len(rv)\n            
rv.append(None)\n\n    # spos is the position of the wildcard (star).  If it's not 
`None`,\n    # we fill it with the remainder.\n    if spos is not None:\n        rv = 
tuple(args)\n        args = []\n        rv = reversed(rv)\n\n    return tuple(rv), 
list(args)"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 69, "end_line": 76, "size": 8, "parent_context": 
"function_definition", "content": "def _fetch(c: deque[V]) -> V | None:\n        
try:\n            if spos is None:\n                return c.popleft()\n            
else:\n                return c.pop()\n        except IndexError:\n            return 
None"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 112, "end_line": 118, "size": 7, 
"parent_context": "", "content": "def _split_opt(opt: str) -> tuple:\n    first = 
opt[:1]\n    if first.isalnum():\n        return \"\", opt\n    if opt[1:2] == 
first:\n        return opt[:2], opt[2:]\n    return first, opt[1:]"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 121, "end_line": 125, "size": 5, 
"parent_context": "", "content": "def _normalize_opt(opt: str, ctx: Context | None) ->
str:\n    if ctx is None or ctx.token_normalize_func is None:\n        return opt\n   
prefix, opt = _split_opt(opt)\n    return 
f\"{prefix}{ctx.token_normalize_func(opt)}\""}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"class_definition", "start_line": 128, "end_line": 179, "size": 52, "parent_context": 
"", "content": "class _Option:\n    def __init__(\n        self,\n        obj: 
CoreOption,\n        opts: cabc.Sequence,\n        dest: str | None,\n        action: 
str | None = None,\n        nargs: int = 1,\n        const: t.Any | None = None,\n    
):\n        self._short_opts = []\n        self._long_opts = []\n        
self.prefixes: set = set()\n\n        for opt in opts:\n            prefix, value = 
_split_opt(opt)\n            if not prefix:\n                raise 
ValueError(f\"Invalid start character for option ({opt})\")\n            
self.prefixes.add(prefix[0])\n            if len(prefix) == 1 and len(value) == 1:\n  
self._short_opts.append(opt)\n            else:\n                
self._long_opts.append(opt)\n                self.prefixes.add(prefix)\n\n        if 
action is None:\n            action = \"store\"\n\n        self.dest = dest\n        
self.action = action\n        self.nargs = nargs\n        self.const = const\n        
self.obj = obj\n\n    @property\n    def takes_value(self) -> bool:\n        return 
self.action in (\"store\", \"append\")\n\n    def process(self, value: t.Any, state: 
_ParsingState) -> None:\n        if self.action == \"store\":\n            state.opts 
= value  # type: ignore\n        elif self.action == \"store_const\":\n            
state.opts = self.const  # type: ignore\n        elif self.action == \"append\":\n    
state.opts.setdefault(self.dest, []).append(value)  # type: ignore\n        elif 
self.action == \"append_const\":\n            state.opts.setdefault(self.dest, 
[]).append(self.const)  # type: ignore\n        elif self.action == \"count\":\n      
state.opts = state.opts.get(self.dest, 0) + 1  # type: ignore\n        else:\n        
raise ValueError(f\"unknown action '{self.action}'\")\n        
state.order.append(self.obj)"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 129, "end_line": 160, "size": 32, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
obj: CoreOption,\n        opts: cabc.Sequence,\n        dest: str | None,\n        
action: str | None = None,\n        nargs: int = 1,\n        const: t.Any | None = 
None,\n    ):\n        self._short_opts = []\n        self._long_opts = []\n        
self.prefixes: set = set()\n\n        for opt in opts:\n            prefix, value = 
_split_opt(opt)\n            if not prefix:\n                raise 
ValueError(f\"Invalid start character for option ({opt})\")\n            
self.prefixes.add(prefix[0])\n            if len(prefix) == 1 and len(value) == 1:\n  
self._short_opts.append(opt)\n            else:\n                
self._long_opts.append(opt)\n                self.prefixes.add(prefix)\n\n        if 
action is None:\n            action = \"store\"\n\n        self.dest = dest\n        
self.action = action\n        self.nargs = nargs\n        self.const = const\n        
self.obj = obj"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 162, "end_line": 164, "size": 3, 
"parent_context": "class_definition", "content": "@property\n    def takes_value(self)
-> bool:\n        return self.action in (\"store\", \"append\")"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 163, "end_line": 164, "size": 2, 
"parent_context": "decorated_definition", "content": "def takes_value(self) -> bool:\n
return self.action in (\"store\", \"append\")"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 166, "end_line": 179, "size": 14, 
"parent_context": "class_definition", "content": "def process(self, value: t.Any, 
state: _ParsingState) -> None:\n        if self.action == \"store\":\n            
state.opts = value  # type: ignore\n        elif self.action == \"store_const\":\n    
state.opts = self.const  # type: ignore\n        elif self.action == \"append\":\n    
state.opts.setdefault(self.dest, []).append(value)  # type: ignore\n        elif 
self.action == \"append_const\":\n            state.opts.setdefault(self.dest, 
[]).append(self.const)  # type: ignore\n        elif self.action == \"count\":\n      
state.opts = state.opts.get(self.dest, 0) + 1  # type: ignore\n        else:\n        
raise ValueError(f\"unknown action '{self.action}'\")\n        
state.order.append(self.obj)"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"class_definition", "start_line": 182, "end_line": 211, "size": 30, "parent_context": 
"", "content": "class _Argument:\n    def __init__(self, obj: CoreArgument, dest: str 
| None, nargs: int = 1):\n        self.dest = dest\n        self.nargs = nargs\n      
self.obj = obj\n\n    def process(\n        self,\n        value: str | cabc.Sequence 
| None,\n        state: _ParsingState,\n    ) -> None:\n        if self.nargs > 1:\n  
assert value is not None\n            holes = sum(1 for x in value if x is None)\n    
if holes == len(value):\n                value = None\n            elif holes != 0:\n 
raise BadArgumentUsage(\n                    _(\"Argument {name!r} takes {nargs} 
values.\").format(\n                        name=self.dest, nargs=self.nargs\n        
)\n                )\n\n        if self.nargs == -1 and self.obj.envvar is not None 
and value == ():\n            # Replace empty tuple with None so that a value from 
the\n            # environment may be tried.\n            value = None\n\n        
state.opts = value  # type: ignore\n        state.order.append(self.obj)"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 183, "end_line": 186, "size": 4, 
"parent_context": "class_definition", "content": "def __init__(self, obj: 
CoreArgument, dest: str | None, nargs: int = 1):\n        self.dest = dest\n        
self.nargs = nargs\n        self.obj = obj"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 188, "end_line": 211, "size": 24, 
"parent_context": "class_definition", "content": "def process(\n        self,\n       
value: str | cabc.Sequence | None,\n        state: _ParsingState,\n    ) -> None:\n   
if self.nargs > 1:\n            assert value is not None\n            holes = sum(1 
for x in value if x is None)\n            if holes == len(value):\n                
value = None\n            elif holes != 0:\n                raise BadArgumentUsage(\n 
_(\"Argument {name!r} takes {nargs} values.\").format(\n                        
name=self.dest, nargs=self.nargs\n                    )\n                )\n\n        
if self.nargs == -1 and self.obj.envvar is not None and value == ():\n            # 
Replace empty tuple with None so that a value from the\n            # environment may 
be tried.\n            value = None\n\n        state.opts = value  # type: ignore\n   
state.order.append(self.obj)"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"class_definition", "start_line": 214, "end_line": 219, "size": 6, "parent_context": 
"", "content": "class _ParsingState:\n    def __init__(self, rargs: list) -> None:\n  
self.opts: dict = {}\n        self.largs: list = []\n        self.rargs = rargs\n     
self.order: list[CoreParameter] = []"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 215, "end_line": 219, "size": 5, 
"parent_context": "class_definition", "content": "def __init__(self, rargs: list) -> 
None:\n        self.opts: dict = {}\n        self.largs: list = []\n        self.rargs
= rargs\n        self.order: list[CoreParameter] = []"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"class_definition", "start_line": 222, "end_line": 499, "size": 278, "parent_context":
"", "content": "class _OptionParser:\n    \"\"\"The option parser is an internal class
that is ultimately used to\n    parse options and arguments.  It's modelled after 
optparse and brings\n    a similar but vastly simplified API.  It should generally not
be used\n    directly as the high level Click classes wrap it for you.\n\n    It's not
nearly as extensible as optparse or argparse as it does not\n    implement features 
that are implemented on a higher level (such as\n    types or defaults).\n\n    :param
ctx: optionally the :class:`~click.Context` where this parser\n                should 
go with.\n\n    .. deprecated:: 8.2\n        Will be removed in Click 9.0.\n    
\"\"\"\n\n    def __init__(self, ctx: Context | None = None) -> None:\n        #: The 
:class:`~click.Context` for this parser.  This might be\n        #: `None` for some 
advanced use cases.\n        self.ctx = ctx\n        #: This controls how the parser 
deals with interspersed arguments.\n        #: If this is set to `False`, the parser 
will stop on the first\n        #: non-option.  Click uses this to implement nested 
subcommands\n        #: safely.\n        self.allow_interspersed_args: bool = True\n  
#: This tells the parser how to deal with unknown options.  By\n        #: default it 
will error out (which is sensible), but there is a\n        #: second mode where it 
will ignore it and continue processing\n        #: after shifting all the unknown 
options into the resulting args.\n        self.ignore_unknown_options: bool = 
False\n\n        if ctx is not None:\n            self.allow_interspersed_args = 
ctx.allow_interspersed_args\n            self.ignore_unknown_options = 
ctx.ignore_unknown_options\n\n        self._short_opt: dict = {}\n        
self._long_opt: dict = {}\n        self._opt_prefixes = {\"-\", \"--\"}\n        
self._args: list[_Argument] = []\n\n    def add_option(\n        self,\n        obj: 
CoreOption,\n        opts: cabc.Sequence,\n        dest: str | None,\n        action: 
str | None = None,\n        nargs: int = 1,\n        const: t.Any | None = None,\n    
) -> None:\n        \"\"\"Adds a new option named `dest` to the parser.  The 
destination\n        is not inferred (unlike with optparse) and needs to be 
explicitly\n        provided.  Action can be any of ``store``, ``store_const``,\n     
``append``, ``append_const`` or ``count``.\n\n        The `obj` can be used to 
identify the option in the order list\n        that is returned from the parser.\n    
\"\"\"\n        opts = [_normalize_opt(opt, self.ctx) for opt in opts]\n        option
= _Option(obj, opts, dest, action=action, nargs=nargs, const=const)\n        
self._opt_prefixes.update(option.prefixes)\n        for opt in option._short_opts:\n  
self._short_opt = option\n        for opt in option._long_opts:\n            
self._long_opt = option\n\n    def add_argument(self, obj: CoreArgument, dest: str | 
None, nargs: int = 1) -> None:\n        \"\"\"Adds a positional argument named `dest` 
to the parser.\n\n        The `obj` can be used to identify the option in the order 
list\n        that is returned from the parser.\n        \"\"\"\n        
self._args.append(_Argument(obj, dest=dest, nargs=nargs))\n\n    def parse_args(\n    
self, args: list\n    ) -> tuple[dict, list, list[CoreParameter]]:\n        
\"\"\"Parses positional arguments and returns ``(values, args, order)``\n        for 
the parsed options and arguments as well as the leftover\n        arguments if there 
are any.  The order is a list of objects as they\n        appear on the command line. 
If arguments appear multiple times they\n        will be memorized multiple times as 
well.\n        \"\"\"\n        state = _ParsingState(args)\n        try:\n            
self._process_args_for_options(state)\n            
self._process_args_for_args(state)\n        except UsageError:\n            if 
self.ctx is None or not self.ctx.resilient_parsing:\n                raise\n        
return state.opts, state.largs, state.order\n\n    def _process_args_for_args(self, 
state: _ParsingState) -> None:\n        pargs, args = _unpack_args(\n            
state.largs + state.rargs, \n        )\n\n        for idx, arg in 
enumerate(self._args):\n            arg.process(pargs, state)\n\n        state.largs =
args\n        state.rargs = []\n\n    def _process_args_for_options(self, state: 
_ParsingState) -> None:\n        while state.rargs:\n            arg = 
state.rargs.pop(0)\n            arglen = len(arg)\n            # Double dashes always 
handled explicitly regardless of what\n            # prefixes are valid.\n            
if arg == \"--\":\n                return\n            elif arg[:1] in 
self._opt_prefixes and arglen > 1:\n                self._process_opts(arg, state)\n  
elif self.allow_interspersed_args:\n                state.largs.append(arg)\n         
else:\n                state.rargs.insert(0, arg)\n                return\n\n        #
Say this is the original argument list:\n        # \n        #                        
^\n        # (we are about to process arg(i)).\n        #\n        # Then rargs is  
and largs is a *subset* of\n        #  (any options and their arguments will have\n   
# been removed from largs).\n        #\n        # The while loop will usually consume 
1 or more arguments per pass.\n        # If it consumes 1 (eg. arg is an option that 
takes no arguments),\n        # then after _process_arg() is done the situation is:\n 
#\n        #   largs = subset of \n        #   rargs = \n        #\n        # If 
allow_interspersed_args is false, largs will always be\n        # *empty* -- still a 
subset of , but\n        # not a very interesting subset!\n\n    def 
_match_long_opt(\n        self, opt: str, explicit_value: str | None, state: 
_ParsingState\n    ) -> None:\n        if opt not in self._long_opt:\n            from
difflib import get_close_matches\n\n            possibilities = get_close_matches(opt,
self._long_opt)\n            raise NoSuchOption(opt, possibilities=possibilities, 
ctx=self.ctx)\n\n        option = self._long_opt\n        if option.takes_value:\n    
# At this point it's safe to modify rargs by injecting the\n            # explicit 
value, because no exception is raised in this\n            # branch.  This means that 
the inserted value will be fully\n            # consumed.\n            if 
explicit_value is not None:\n                state.rargs.insert(0, explicit_value)\n\n
value = self._get_value_from_state(opt, option, state)\n\n        elif explicit_value 
is not None:\n            raise BadOptionUsage(\n                opt, _(\"Option 
{name!r} does not take a value.\").format(name=opt)\n            )\n\n        else:\n 
value = None\n\n        option.process(value, state)\n\n    def _match_short_opt(self,
arg: str, state: _ParsingState) -> None:\n        stop = False\n        i = 1\n       
prefix = arg[0]\n        unknown_options = []\n\n        for ch in arg[1:]:\n         
opt = _normalize_opt(f\"{prefix}{ch}\", self.ctx)\n            option = 
self._short_opt.get(opt)\n            i += 1\n\n            if not option:\n          
if self.ignore_unknown_options:\n                    unknown_options.append(ch)\n     
continue\n                raise NoSuchOption(opt, ctx=self.ctx)\n            if 
option.takes_value:\n                # Any characters left in arg?  Pretend they're 
the\n                # next arg, and stop consuming characters of arg.\n              
if i < len(arg):\n                    state.rargs.insert(0, arg)\n                    
stop = True\n\n                value = self._get_value_from_state(opt, option, 
state)\n\n            else:\n                value = None\n\n            
option.process(value, state)\n\n            if stop:\n                break\n\n       
# If we got any unknown options we recombine the string of the\n        # remaining 
options and re-attach the prefix, then report that\n        # to the state as new 
larg.  This way there is basic combinatorics\n        # that can be achieved while 
still ignoring unknown arguments.\n        if self.ignore_unknown_options and 
unknown_options:\n            
state.largs.append(f\"{prefix}{''.join(unknown_options)}\")\n\n    def 
_get_value_from_state(\n        self, option_name: str, option: _Option, state: 
_ParsingState\n    ) -> t.Any:\n        nargs = option.nargs\n\n        if 
len(state.rargs) < nargs:\n            if option.obj._flag_needs_value:\n             
# Option allows omitting the value.\n                value = _flag_needs_value\n      
else:\n                raise BadOptionUsage(\n                    option_name,\n      
ngettext(\n                        \"Option {name!r} requires an argument.\",\n       
\"Option {name!r} requires {nargs} arguments.\",\n                        nargs,\n    
).format(name=option_name, nargs=nargs),\n                )\n        elif nargs == 
1:\n            next_rarg = state.rargs[0]\n\n            if (\n                
option.obj._flag_needs_value\n                and isinstance(next_rarg, str)\n        
and next_rarg[:1] in self._opt_prefixes\n                and len(next_rarg) > 1\n     
):\n                # The next arg looks like the start of an option, don't\n         
# use it as the value if omitting the value is allowed.\n                value = 
_flag_needs_value\n            else:\n                value = state.rargs.pop(0)\n    
else:\n            value = tuple(state.rargs[:nargs])\n            del 
state.rargs[:nargs]\n\n        return value\n\n    def _process_opts(self, arg: str, 
state: _ParsingState) -> None:\n        explicit_value = None\n        # Long option 
handling happens in two parts.  The first part is\n        # supporting explicitly 
attached values.  In any case, we will try\n        # to long match the option 
first.\n        if \"=\" in arg:\n            long_opt, explicit_value = 
arg.split(\"=\", 1)\n        else:\n            long_opt = arg\n        norm_long_opt 
= _normalize_opt(long_opt, self.ctx)\n\n        # At this point we will match the 
(assumed) long option through\n        # the long option matching code.  Note that 
this allows options\n        # like \"-foo\" to be matched as long options.\n        
try:\n            self._match_long_opt(norm_long_opt, explicit_value, state)\n        
except NoSuchOption:\n            # At this point the long option matching failed, and
we need\n            # to try with short options.  However there is a special rule\n  
# which says, that if we have a two character options prefix\n            # (applies 
to \"--foo\" for instance), we do not dispatch to the\n            # short option code
and will instead raise the no option\n            # error.\n            if arg[:2] not
in self._opt_prefixes:\n                self._match_short_opt(arg, state)\n           
return\n\n            if not self.ignore_unknown_options:\n                raise\n\n  
state.largs.append(arg)"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 239, "end_line": 261, "size": 23, 
"parent_context": "class_definition", "content": "def __init__(self, ctx: Context | 
None = None) -> None:\n        #: The :class:`~click.Context` for this parser.  This 
might be\n        #: `None` for some advanced use cases.\n        self.ctx = ctx\n    
#: This controls how the parser deals with interspersed arguments.\n        #: If this
is set to `False`, the parser will stop on the first\n        #: non-option.  Click 
uses this to implement nested subcommands\n        #: safely.\n        
self.allow_interspersed_args: bool = True\n        #: This tells the parser how to 
deal with unknown options.  By\n        #: default it will error out (which is 
sensible), but there is a\n        #: second mode where it will ignore it and continue
processing\n        #: after shifting all the unknown options into the resulting 
args.\n        self.ignore_unknown_options: bool = False\n\n        if ctx is not 
None:\n            self.allow_interspersed_args = ctx.allow_interspersed_args\n       
self.ignore_unknown_options = ctx.ignore_unknown_options\n\n        self._short_opt: 
dict = {}\n        self._long_opt: dict = {}\n        self._opt_prefixes = {\"-\", 
\"--\"}\n        self._args: list[_Argument] = []"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 263, "end_line": 286, "size": 24, 
"parent_context": "class_definition", "content": "def add_option(\n        self,\n    
obj: CoreOption,\n        opts: cabc.Sequence,\n        dest: str | None,\n        
action: str | None = None,\n        nargs: int = 1,\n        const: t.Any | None = 
None,\n    ) -> None:\n        \"\"\"Adds a new option named `dest` to the parser.  
The destination\n        is not inferred (unlike with optparse) and needs to be 
explicitly\n        provided.  Action can be any of ``store``, ``store_const``,\n     
``append``, ``append_const`` or ``count``.\n\n        The `obj` can be used to 
identify the option in the order list\n        that is returned from the parser.\n    
\"\"\"\n        opts = [_normalize_opt(opt, self.ctx) for opt in opts]\n        option
= _Option(obj, opts, dest, action=action, nargs=nargs, const=const)\n        
self._opt_prefixes.update(option.prefixes)\n        for opt in option._short_opts:\n  
self._short_opt = option\n        for opt in option._long_opts:\n            
self._long_opt = option"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 288, "end_line": 294, "size": 7, 
"parent_context": "class_definition", "content": "def add_argument(self, obj: 
CoreArgument, dest: str | None, nargs: int = 1) -> None:\n        \"\"\"Adds a 
positional argument named `dest` to the parser.\n\n        The `obj` can be used to 
identify the option in the order list\n        that is returned from the parser.\n    
\"\"\"\n        self._args.append(_Argument(obj, dest=dest, nargs=nargs))"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 296, "end_line": 312, "size": 17, 
"parent_context": "class_definition", "content": "def parse_args(\n        self, args:
list\n    ) -> tuple[dict, list, list[CoreParameter]]:\n        \"\"\"Parses 
positional arguments and returns ``(values, args, order)``\n        for the parsed 
options and arguments as well as the leftover\n        arguments if there are any.  
The order is a list of objects as they\n        appear on the command line.  If 
arguments appear multiple times they\n        will be memorized multiple times as 
well.\n        \"\"\"\n        state = _ParsingState(args)\n        try:\n            
self._process_args_for_options(state)\n            
self._process_args_for_args(state)\n        except UsageError:\n            if 
self.ctx is None or not self.ctx.resilient_parsing:\n                raise\n        
return state.opts, state.largs, state.order"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 314, "end_line": 323, "size": 10, 
"parent_context": "class_definition", "content": "def _process_args_for_args(self, 
state: _ParsingState) -> None:\n        pargs, args = _unpack_args(\n            
state.largs + state.rargs, \n        )\n\n        for idx, arg in 
enumerate(self._args):\n            arg.process(pargs, state)\n\n        state.largs =
args\n        state.rargs = []"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 325, "end_line": 359, "size": 35, 
"parent_context": "class_definition", "content": "def _process_args_for_options(self, 
state: _ParsingState) -> None:\n        while state.rargs:\n            arg = 
state.rargs.pop(0)\n            arglen = len(arg)\n            # Double dashes always 
handled explicitly regardless of what\n            # prefixes are valid.\n            
if arg == \"--\":\n                return\n            elif arg[:1] in 
self._opt_prefixes and arglen > 1:\n                self._process_opts(arg, state)\n  
elif self.allow_interspersed_args:\n                state.largs.append(arg)\n         
else:\n                state.rargs.insert(0, arg)\n                return\n\n        #
Say this is the original argument list:\n        # \n        #                        
^\n        # (we are about to process arg(i)).\n        #\n        # Then rargs is  
and largs is a *subset* of\n        #  (any options and their arguments will have\n   
# been removed from largs).\n        #\n        # The while loop will usually consume 
1 or more arguments per pass.\n        # If it consumes 1 (eg. arg is an option that 
takes no arguments),\n        # then after _process_arg() is done the situation is:\n 
#\n        #   largs = subset of \n        #   rargs = \n        #\n        # If 
allow_interspersed_args is false, largs will always be\n        # *empty* -- still a 
subset of , but\n        # not a very interesting subset!"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 361, "end_line": 389, "size": 29, 
"parent_context": "class_definition", "content": "def _match_long_opt(\n        self, 
opt: str, explicit_value: str | None, state: _ParsingState\n    ) -> None:\n        if
opt not in self._long_opt:\n            from difflib import get_close_matches\n\n     
possibilities = get_close_matches(opt, self._long_opt)\n            raise 
NoSuchOption(opt, possibilities=possibilities, ctx=self.ctx)\n\n        option = 
self._long_opt\n        if option.takes_value:\n            # At this point it's safe 
to modify rargs by injecting the\n            # explicit value, because no exception 
is raised in this\n            # branch.  This means that the inserted value will be 
fully\n            # consumed.\n            if explicit_value is not None:\n          
state.rargs.insert(0, explicit_value)\n\n            value = 
self._get_value_from_state(opt, option, state)\n\n        elif explicit_value is not 
None:\n            raise BadOptionUsage(\n                opt, _(\"Option {name!r} 
does not take a value.\").format(name=opt)\n            )\n\n        else:\n          
value = None\n\n        option.process(value, state)"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 391, "end_line": 429, "size": 39, 
"parent_context": "class_definition", "content": "def _match_short_opt(self, arg: str,
state: _ParsingState) -> None:\n        stop = False\n        i = 1\n        prefix = 
arg[0]\n        unknown_options = []\n\n        for ch in arg[1:]:\n            opt = 
_normalize_opt(f\"{prefix}{ch}\", self.ctx)\n            option = 
self._short_opt.get(opt)\n            i += 1\n\n            if not option:\n          
if self.ignore_unknown_options:\n                    unknown_options.append(ch)\n     
continue\n                raise NoSuchOption(opt, ctx=self.ctx)\n            if 
option.takes_value:\n                # Any characters left in arg?  Pretend they're 
the\n                # next arg, and stop consuming characters of arg.\n              
if i < len(arg):\n                    state.rargs.insert(0, arg)\n                    
stop = True\n\n                value = self._get_value_from_state(opt, option, 
state)\n\n            else:\n                value = None\n\n            
option.process(value, state)\n\n            if stop:\n                break\n\n       
# If we got any unknown options we recombine the string of the\n        # remaining 
options and re-attach the prefix, then report that\n        # to the state as new 
larg.  This way there is basic combinatorics\n        # that can be achieved while 
still ignoring unknown arguments.\n        if self.ignore_unknown_options and 
unknown_options:\n            
state.largs.append(f\"{prefix}{''.join(unknown_options)}\")"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 431, "end_line": 467, "size": 37, 
"parent_context": "class_definition", "content": "def _get_value_from_state(\n        
self, option_name: str, option: _Option, state: _ParsingState\n    ) -> t.Any:\n      
nargs = option.nargs\n\n        if len(state.rargs) < nargs:\n            if 
option.obj._flag_needs_value:\n                # Option allows omitting the value.\n  
value = _flag_needs_value\n            else:\n                raise BadOptionUsage(\n 
option_name,\n                    ngettext(\n                        \"Option {name!r}
requires an argument.\",\n                        \"Option {name!r} requires {nargs} 
arguments.\",\n                        nargs,\n                    
).format(name=option_name, nargs=nargs),\n                )\n        elif nargs == 
1:\n            next_rarg = state.rargs[0]\n\n            if (\n                
option.obj._flag_needs_value\n                and isinstance(next_rarg, str)\n        
and next_rarg[:1] in self._opt_prefixes\n                and len(next_rarg) > 1\n     
):\n                # The next arg looks like the start of an option, don't\n         
# use it as the value if omitting the value is allowed.\n                value = 
_flag_needs_value\n            else:\n                value = state.rargs.pop(0)\n    
else:\n            value = tuple(state.rargs[:nargs])\n            del 
state.rargs[:nargs]\n\n        return value"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 469, "end_line": 499, "size": 31, 
"parent_context": "class_definition", "content": "def _process_opts(self, arg: str, 
state: _ParsingState) -> None:\n        explicit_value = None\n        # Long option 
handling happens in two parts.  The first part is\n        # supporting explicitly 
attached values.  In any case, we will try\n        # to long match the option 
first.\n        if \"=\" in arg:\n            long_opt, explicit_value = 
arg.split(\"=\", 1)\n        else:\n            long_opt = arg\n        norm_long_opt 
= _normalize_opt(long_opt, self.ctx)\n\n        # At this point we will match the 
(assumed) long option through\n        # the long option matching code.  Note that 
this allows options\n        # like \"-foo\" to be matched as long options.\n        
try:\n            self._match_long_opt(norm_long_opt, explicit_value, state)\n        
except NoSuchOption:\n            # At this point the long option matching failed, and
we need\n            # to try with short options.  However there is a special rule\n  
# which says, that if we have a two character options prefix\n            # (applies 
to \"--foo\" for instance), we do not dispatch to the\n            # short option code
and will instead raise the no option\n            # error.\n            if arg[:2] not
in self._opt_prefixes:\n                self._match_short_opt(arg, state)\n           
return\n\n            if not self.ignore_unknown_options:\n                raise\n\n  
state.largs.append(arg)"}
{"file": "click/src/click/parser.py", "language": "python", "node_type": 
"function_definition", "start_line": 502, "end_line": 532, "size": 31, 
"parent_context": "", "content": "def __getattr__(name: str) -> object:\n    import 
warnings\n\n    if name in {\n        \"OptionParser\",\n        \"Argument\",\n      
\"Option\",\n        \"split_opt\",\n        \"normalize_opt\",\n        
\"ParsingState\",\n    }:\n        warnings.warn(\n            f\"'parser.{name}' is 
deprecated and will be removed in Click 9.0.\"\n            \" The old parser is 
available in 'optparse'.\",\n            DeprecationWarning,\n            
stacklevel=2,\n        )\n        return globals()\n\n    if name == 
\"split_arg_string\":\n        from .shell_completion import split_arg_string\n\n     
warnings.warn(\n            \"Importing 'parser.split_arg_string' is deprecated, it 
will only be\"\n            \" available in 'shell_completion' in Click 9.0.\",\n     
DeprecationWarning,\n            stacklevel=2,\n        )\n        return 
split_arg_string\n\n    raise AttributeError(name)"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 14, "end_line": 21, "size": 8, "parent_context": 
"", "content": "def measure_table(rows: cabc.Iterable[tuple]) -> tuple:\n    widths: 
dict = {}\n\n    for row in rows:\n        for idx, col in enumerate(row):\n          
widths = max(widths.get(idx, 0), term_len(col))\n\n    return tuple(y for x, y in 
sorted(widths.items()))"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 24, "end_line": 28, "size": 5, "parent_context": 
"", "content": "def iter_rows(\n    rows: cabc.Iterable[tuple], col_count: int\n) -> 
cabc.Iterator[tuple]:\n    for row in rows:\n        yield row + (\"\",) * (col_count 
- len(row))"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 31, "end_line": 101, "size": 71, 
"parent_context": "", "content": "def wrap_text(\n    text: str,\n    width: int = 
78,\n    initial_indent: str = \"\",\n    subsequent_indent: str = \"\",\n    
preserve_paragraphs: bool = False,\n) -> str:\n    \"\"\"A helper function that 
intelligently wraps text.  By default, it\n    assumes that it operates on a single 
paragraph of text but if the\n    `preserve_paragraphs` parameter is provided it will 
intelligently\n    handle paragraphs (defined by two empty lines).\n\n    If 
paragraphs are handled, a paragraph can be prefixed with an empty\n    line containing
the ``\\\\b`` character (``\\\\x08``) to indicate that\n    no rewrapping should 
happen in that block.\n\n    :param text: the text that should be rewrapped.\n    
:param width: the maximum width for the text.\n    :param initial_indent: the initial 
indent that should be placed on the\n                           first line as a 
string.\n    :param subsequent_indent: the indent string that should be placed on\n   
each consecutive line.\n    :param preserve_paragraphs: if this flag is set then the 
wrapping will\n                                intelligently handle paragraphs.\n    
\"\"\"\n    from ._textwrap import TextWrapper\n\n    text = text.expandtabs()\n    
wrapper = TextWrapper(\n        width,\n        initial_indent=initial_indent,\n      
subsequent_indent=subsequent_indent,\n        replace_whitespace=False,\n    )\n    if
not preserve_paragraphs:\n        return wrapper.fill(text)\n\n    p: list[tuple] = 
[]\n    buf: list = []\n    indent = None\n\n    def _flush_par() -> None:\n        if
not buf:\n            return\n        if buf[0].strip() == \"\\b\":\n            
p.append((indent or 0, True, \"\\n\".join(buf[1:])))\n        else:\n            
p.append((indent or 0, False, \" \".join(buf)))\n        del buf[:]\n\n    for line in
text.splitlines():\n        if not line:\n            _flush_par()\n            indent
= None\n        else:\n            if indent is None:\n                orig_len = 
term_len(line)\n                line = line.lstrip()\n                indent = 
orig_len - term_len(line)\n            buf.append(line)\n    _flush_par()\n\n    rv = 
[]\n    for indent, raw, text in p:\n        with wrapper.extra_indent(\" \" * 
indent):\n            if raw:\n                rv.append(wrapper.indent_only(text))\n 
else:\n                rv.append(wrapper.fill(text))\n\n    return 
\"\\n\\n\".join(rv)"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 72, "end_line": 79, "size": 8, "parent_context": 
"function_definition", "content": "def _flush_par() -> None:\n        if not buf:\n   
return\n        if buf[0].strip() == \"\\b\":\n            p.append((indent or 0, 
True, \"\\n\".join(buf[1:])))\n        else:\n            p.append((indent or 0, 
False, \" \".join(buf)))\n        del buf[:]"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"class_definition", "start_line": 104, "end_line": 280, "size": 177, "parent_context":
"", "content": "class HelpFormatter:\n    \"\"\"This class helps with formatting 
text-based help pages.  It's\n    usually just needed for very special internal cases,
but it's also\n    exposed so that developers can write their own fancy outputs.\n\n  
At present, it always writes into memory.\n\n    :param indent_increment: the 
additional increment for each level.\n    :param width: the width for the text.  This 
defaults to the terminal\n                  width clamped to a maximum of 78.\n    
\"\"\"\n\n    def __init__(\n        self,\n        indent_increment: int = 2,\n      
width: int | None = None,\n        max_width: int | None = None,\n    ) -> None:\n    
import shutil\n\n        self.indent_increment = indent_increment\n        if 
max_width is None:\n            max_width = 80\n        if width is None:\n           
width = FORCED_WIDTH\n            if width is None:\n                width = 
max(min(shutil.get_terminal_size().columns, max_width) - 2, 50)\n        self.width = 
width\n        self.current_indent: int = 0\n        self.buffer: list = []\n\n    def
write(self, string: str) -> None:\n        \"\"\"Writes a unicode string into the 
internal buffer.\"\"\"\n        self.buffer.append(string)\n\n    def indent(self) -> 
None:\n        \"\"\"Increases the indentation.\"\"\"\n        self.current_indent += 
self.indent_increment\n\n    def dedent(self) -> None:\n        \"\"\"Decreases the 
indentation.\"\"\"\n        self.current_indent -= self.indent_increment\n\n    def 
write_usage(self, prog: str, args: str = \"\", prefix: str | None = None) -> None:\n  
\"\"\"Writes a usage line into the buffer.\n\n        :param prog: the program name.\n
:param args: whitespace separated list of arguments.\n        :param prefix: The 
prefix for the first line. Defaults to\n            ``\"Usage: \"``.\n        \"\"\"\n
if prefix is None:\n            prefix = f\"{_('Usage:')} \"\n\n        usage_prefix =
f\"{prefix:>{self.current_indent}}{prog} \"\n        text_width = self.width - 
self.current_indent\n\n        if text_width >= (term_len(usage_prefix) + 20):\n      
# The arguments will fit to the right of the prefix.\n            indent = \" \" * 
term_len(usage_prefix)\n            self.write(\n                wrap_text(\n         
args,\n                    text_width,\n                    
initial_indent=usage_prefix,\n                    subsequent_indent=indent,\n         
)\n            )\n        else:\n            # The prefix is too long, put the 
arguments on the next line.\n            self.write(usage_prefix)\n            
self.write(\"\\n\")\n            indent = \" \" * (max(self.current_indent, 
term_len(prefix)) + 4)\n            self.write(\n                wrap_text(\n         
args, text_width, initial_indent=indent, subsequent_indent=indent\n                )\n
)\n\n        self.write(\"\\n\")\n\n    def write_heading(self, heading: str) -> 
None:\n        \"\"\"Writes a heading into the buffer.\"\"\"\n        
self.write(f\"{'':>{self.current_indent}}{heading}:\\n\")\n\n    def 
write_paragraph(self) -> None:\n        \"\"\"Writes a paragraph into the 
buffer.\"\"\"\n        if self.buffer:\n            self.write(\"\\n\")\n\n    def 
write_text(self, text: str) -> None:\n        \"\"\"Writes re-indented text into the 
buffer.  This rewraps and\n        preserves paragraphs.\n        \"\"\"\n        
indent = \" \" * self.current_indent\n        self.write(\n            wrap_text(\n   
text,\n                self.width,\n                initial_indent=indent,\n          
subsequent_indent=indent,\n                preserve_paragraphs=True,\n            )\n 
)\n        self.write(\"\\n\")\n\n    def write_dl(\n        self,\n        rows: 
cabc.Sequence[tuple],\n        col_max: int = 30,\n        col_spacing: int = 2,\n    
) -> None:\n        \"\"\"Writes a definition list into the buffer.  This is how 
options\n        and commands are usually formatted.\n\n        :param rows: a list of
two item tuples for the terms and values.\n        :param col_max: the maximum width 
of the first column.\n        :param col_spacing: the number of spaces between the 
first and\n                            second column.\n        \"\"\"\n        rows = 
list(rows)\n        widths = measure_table(rows)\n        if len(widths) != 2:\n      
raise TypeError(\"Expected two columns for definition list\")\n\n        first_col = 
min(widths[0], col_max) + col_spacing\n\n        for first, second in iter_rows(rows, 
len(widths)):\n            self.write(f\"{'':>{self.current_indent}}{first}\")\n      
if not second:\n                self.write(\"\\n\")\n                continue\n       
if term_len(first) <= first_col - col_spacing:\n                self.write(\" \" * 
(first_col - term_len(first)))\n            else:\n                
self.write(\"\\n\")\n                self.write(\" \" * (first_col + 
self.current_indent))\n\n            text_width = max(self.width - first_col - 2, 
10)\n            wrapped_text = wrap_text(second, text_width, 
preserve_paragraphs=True)\n            lines = wrapped_text.splitlines()\n\n          
if lines:\n                self.write(f\"{lines[0]}\\n\")\n\n                for line 
in lines[1:]:\n                    self.write(f\"{'':>{first_col + 
self.current_indent}}{line}\\n\")\n            else:\n                
self.write(\"\\n\")\n\n    @contextmanager\n    def section(self, name: str) -> 
cabc.Iterator[None]:\n        \"\"\"Helpful context manager that writes a paragraph, a
heading,\n        and the indents.\n\n        :param name: the section name that is 
written as heading.\n        \"\"\"\n        self.write_paragraph()\n        
self.write_heading(name)\n        self.indent()\n        try:\n            yield\n    
finally:\n            self.dedent()\n\n    @contextmanager\n    def indentation(self) 
-> cabc.Iterator[None]:\n        \"\"\"A context manager that increases the 
indentation.\"\"\"\n        self.indent()\n        try:\n            yield\n        
finally:\n            self.dedent()\n\n    def getvalue(self) -> str:\n        
\"\"\"Returns the buffer contents.\"\"\"\n        return \"\".join(self.buffer)"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 116, "end_line": 133, "size": 18, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
indent_increment: int = 2,\n        width: int | None = None,\n        max_width: int 
| None = None,\n    ) -> None:\n        import shutil\n\n        self.indent_increment
= indent_increment\n        if max_width is None:\n            max_width = 80\n       
if width is None:\n            width = FORCED_WIDTH\n            if width is None:\n  
width = max(min(shutil.get_terminal_size().columns, max_width) - 2, 50)\n        
self.width = width\n        self.current_indent: int = 0\n        self.buffer: list = 
[]"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 135, "end_line": 137, "size": 3, 
"parent_context": "class_definition", "content": "def write(self, string: str) -> 
None:\n        \"\"\"Writes a unicode string into the internal buffer.\"\"\"\n        
self.buffer.append(string)"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 139, "end_line": 141, "size": 3, 
"parent_context": "class_definition", "content": "def indent(self) -> None:\n        
\"\"\"Increases the indentation.\"\"\"\n        self.current_indent += 
self.indent_increment"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 143, "end_line": 145, "size": 3, 
"parent_context": "class_definition", "content": "def dedent(self) -> None:\n        
\"\"\"Decreases the indentation.\"\"\"\n        self.current_indent -= 
self.indent_increment"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 147, "end_line": 183, "size": 37, 
"parent_context": "class_definition", "content": "def write_usage(self, prog: str, 
args: str = \"\", prefix: str | None = None) -> None:\n        \"\"\"Writes a usage 
line into the buffer.\n\n        :param prog: the program name.\n        :param args: 
whitespace separated list of arguments.\n        :param prefix: The prefix for the 
first line. Defaults to\n            ``\"Usage: \"``.\n        \"\"\"\n        if 
prefix is None:\n            prefix = f\"{_('Usage:')} \"\n\n        usage_prefix = 
f\"{prefix:>{self.current_indent}}{prog} \"\n        text_width = self.width - 
self.current_indent\n\n        if text_width >= (term_len(usage_prefix) + 20):\n      
# The arguments will fit to the right of the prefix.\n            indent = \" \" * 
term_len(usage_prefix)\n            self.write(\n                wrap_text(\n         
args,\n                    text_width,\n                    
initial_indent=usage_prefix,\n                    subsequent_indent=indent,\n         
)\n            )\n        else:\n            # The prefix is too long, put the 
arguments on the next line.\n            self.write(usage_prefix)\n            
self.write(\"\\n\")\n            indent = \" \" * (max(self.current_indent, 
term_len(prefix)) + 4)\n            self.write(\n                wrap_text(\n         
args, text_width, initial_indent=indent, subsequent_indent=indent\n                )\n
)\n\n        self.write(\"\\n\")"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 185, "end_line": 187, "size": 3, 
"parent_context": "class_definition", "content": "def write_heading(self, heading: 
str) -> None:\n        \"\"\"Writes a heading into the buffer.\"\"\"\n        
self.write(f\"{'':>{self.current_indent}}{heading}:\\n\")"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 189, "end_line": 192, "size": 4, 
"parent_context": "class_definition", "content": "def write_paragraph(self) -> None:\n
\"\"\"Writes a paragraph into the buffer.\"\"\"\n        if self.buffer:\n            
self.write(\"\\n\")"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 194, "end_line": 208, "size": 15, 
"parent_context": "class_definition", "content": "def write_text(self, text: str) -> 
None:\n        \"\"\"Writes re-indented text into the buffer.  This rewraps and\n     
preserves paragraphs.\n        \"\"\"\n        indent = \" \" * self.current_indent\n 
self.write(\n            wrap_text(\n                text,\n                
self.width,\n                initial_indent=indent,\n                
subsequent_indent=indent,\n                preserve_paragraphs=True,\n            )\n 
)\n        self.write(\"\\n\")"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 210, "end_line": 252, "size": 43, 
"parent_context": "class_definition", "content": "def write_dl(\n        self,\n      
rows: cabc.Sequence[tuple],\n        col_max: int = 30,\n        col_spacing: int = 
2,\n    ) -> None:\n        \"\"\"Writes a definition list into the buffer.  This is 
how options\n        and commands are usually formatted.\n\n        :param rows: a 
list of two item tuples for the terms and values.\n        :param col_max: the maximum
width of the first column.\n        :param col_spacing: the number of spaces between 
the first and\n                            second column.\n        \"\"\"\n        
rows = list(rows)\n        widths = measure_table(rows)\n        if len(widths) != 
2:\n            raise TypeError(\"Expected two columns for definition list\")\n\n     
first_col = min(widths[0], col_max) + col_spacing\n\n        for first, second in 
iter_rows(rows, len(widths)):\n            
self.write(f\"{'':>{self.current_indent}}{first}\")\n            if not second:\n     
self.write(\"\\n\")\n                continue\n            if term_len(first) <= 
first_col - col_spacing:\n                self.write(\" \" * (first_col - 
term_len(first)))\n            else:\n                self.write(\"\\n\")\n           
self.write(\" \" * (first_col + self.current_indent))\n\n            text_width = 
max(self.width - first_col - 2, 10)\n            wrapped_text = wrap_text(second, 
text_width, preserve_paragraphs=True)\n            lines = 
wrapped_text.splitlines()\n\n            if lines:\n                
self.write(f\"{lines[0]}\\n\")\n\n                for line in lines[1:]:\n            
self.write(f\"{'':>{first_col + self.current_indent}}{line}\\n\")\n            else:\n
self.write(\"\\n\")"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 254, "end_line": 267, "size": 14, 
"parent_context": "class_definition", "content": "@contextmanager\n    def 
section(self, name: str) -> cabc.Iterator[None]:\n        \"\"\"Helpful context 
manager that writes a paragraph, a heading,\n        and the indents.\n\n        
:param name: the section name that is written as heading.\n        \"\"\"\n        
self.write_paragraph()\n        self.write_heading(name)\n        self.indent()\n     
try:\n            yield\n        finally:\n            self.dedent()"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 255, "end_line": 267, "size": 13, 
"parent_context": "decorated_definition", "content": "def section(self, name: str) -> 
cabc.Iterator[None]:\n        \"\"\"Helpful context manager that writes a paragraph, a
heading,\n        and the indents.\n\n        :param name: the section name that is 
written as heading.\n        \"\"\"\n        self.write_paragraph()\n        
self.write_heading(name)\n        self.indent()\n        try:\n            yield\n    
finally:\n            self.dedent()"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 269, "end_line": 276, "size": 8, 
"parent_context": "class_definition", "content": "@contextmanager\n    def 
indentation(self) -> cabc.Iterator[None]:\n        \"\"\"A context manager that 
increases the indentation.\"\"\"\n        self.indent()\n        try:\n            
yield\n        finally:\n            self.dedent()"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 270, "end_line": 276, "size": 7, 
"parent_context": "decorated_definition", "content": "def indentation(self) -> 
cabc.Iterator[None]:\n        \"\"\"A context manager that increases the 
indentation.\"\"\"\n        self.indent()\n        try:\n            yield\n        
finally:\n            self.dedent()"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 278, "end_line": 280, "size": 3, 
"parent_context": "class_definition", "content": "def getvalue(self) -> str:\n        
\"\"\"Returns the buffer contents.\"\"\"\n        return \"\".join(self.buffer)"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": 
"function_definition", "start_line": 283, "end_line": 301, "size": 19, 
"parent_context": "", "content": "def join_options(options: cabc.Sequence) -> tuple:\n
\"\"\"Given a list of option strings this joins them in the most appropriate\n    way 
and returns them in the form ``(formatted_string,\n    any_prefix_is_slash)`` where 
the second item in the tuple is a flag that\n    indicates if any of the option 
prefixes was a slash.\n    \"\"\"\n    rv = []\n    any_prefix_is_slash = False\n\n   
for opt in options:\n        prefix = _split_opt(opt)[0]\n\n        if prefix == 
\"/\":\n            any_prefix_is_slash = True\n\n        rv.append((len(prefix), 
opt))\n\n    rv.sort(key=lambda x: x[0])\n    return \", \".join(x[1] for x in rv), 
any_prefix_is_slash"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": "lambda",
"start_line": 300, "end_line": 300, "size": 1, "parent_context": 
"function_definition", "content": "lambda x: x[0]"}
{"file": "click/src/click/formatting.py", "language": "python", "node_type": "lambda",
"start_line": 300, "end_line": 300, "size": 1, "parent_context": "lambda", "content": 
"lambda"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"class_definition", "start_line": 87, "end_line": 100, "size": 14, "parent_context": 
"", "content": "class Py_buffer(Structure):\n        _fields_ = [  # noqa: RUF012\n   
(\"buf\", c_void_p),\n            (\"obj\", py_object),\n            (\"len\", 
c_ssize_t),\n            (\"itemsize\", c_ssize_t),\n            (\"readonly\", 
c_int),\n            (\"ndim\", c_int),\n            (\"format\", c_char_p),\n        
(\"shape\", c_ssize_p),\n            (\"strides\", c_ssize_p),\n            
(\"suboffsets\", c_ssize_p),\n            (\"internal\", c_void_p),\n        ]"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 105, "end_line": 115, "size": 11, 
"parent_context": "", "content": "def get_buffer(obj: Buffer, writable: bool = False) 
-> Array:\n        buf = Py_buffer()\n        flags: int = PyBUF_WRITABLE if writable 
else PyBUF_SIMPLE\n        PyObject_GetBuffer(py_object(obj), byref(buf), flags)\n\n  
try:\n            buffer_type = c_char * buf.len\n            out: Array = 
buffer_type.from_address(buf.buf)\n            return out\n        finally:\n         
PyBuffer_Release(byref(buf))"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"class_definition", "start_line": 118, "end_line": 124, "size": 7, "parent_context": 
"", "content": "class _WindowsConsoleRawIOBase(io.RawIOBase):\n    def __init__(self, 
handle: int | None) -> None:\n        self.handle = handle\n\n    def isatty(self) -> 
t.Literal[True]:\n        super().isatty()\n        return True"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 119, "end_line": 120, "size": 2, 
"parent_context": "class_definition", "content": "def __init__(self, handle: int | 
None) -> None:\n        self.handle = handle"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 122, "end_line": 124, "size": 3, 
"parent_context": "class_definition", "content": "def isatty(self) -> 
t.Literal[True]:\n        super().isatty()\n        return True"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"class_definition", "start_line": 127, "end_line": 159, "size": 33, "parent_context": 
"", "content": "class _WindowsConsoleReader(_WindowsConsoleRawIOBase):\n    def 
readable(self) -> t.Literal[True]:\n        return True\n\n    def readinto(self, b: 
Buffer) -> int:\n        bytes_to_be_read = len(b)\n        if not bytes_to_be_read:\n
return 0\n        elif bytes_to_be_read % 2:\n            raise ValueError(\n         
\"cannot read odd number of bytes from UTF-16-LE encoded console\"\n            )\n\n 
buffer = get_buffer(b, writable=True)\n        code_units_to_be_read = 
bytes_to_be_read // 2\n        code_units_read = c_ulong()\n\n        rv = 
ReadConsoleW(\n            HANDLE(self.handle),\n            buffer,\n            
code_units_to_be_read,\n            byref(code_units_read),\n            None,\n      
)\n        if GetLastError() == ERROR_OPERATION_ABORTED:\n            # wait for 
KeyboardInterrupt\n            time.sleep(0.1)\n        if not rv:\n            raise 
OSError(f\"Windows error: {GetLastError()}\")\n\n        if buffer[0] == EOF:\n       
return 0\n        return 2 * code_units_read.value"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 128, "end_line": 129, "size": 2, 
"parent_context": "class_definition", "content": "def readable(self) -> 
t.Literal[True]:\n        return True"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 131, "end_line": 159, "size": 29, 
"parent_context": "class_definition", "content": "def readinto(self, b: Buffer) -> 
int:\n        bytes_to_be_read = len(b)\n        if not bytes_to_be_read:\n           
return 0\n        elif bytes_to_be_read % 2:\n            raise ValueError(\n         
\"cannot read odd number of bytes from UTF-16-LE encoded console\"\n            )\n\n 
buffer = get_buffer(b, writable=True)\n        code_units_to_be_read = 
bytes_to_be_read // 2\n        code_units_read = c_ulong()\n\n        rv = 
ReadConsoleW(\n            HANDLE(self.handle),\n            buffer,\n            
code_units_to_be_read,\n            byref(code_units_read),\n            None,\n      
)\n        if GetLastError() == ERROR_OPERATION_ABORTED:\n            # wait for 
KeyboardInterrupt\n            time.sleep(0.1)\n        if not rv:\n            raise 
OSError(f\"Windows error: {GetLastError()}\")\n\n        if buffer[0] == EOF:\n       
return 0\n        return 2 * code_units_read.value"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"class_definition", "start_line": 162, "end_line": 191, "size": 30, "parent_context": 
"", "content": "class _WindowsConsoleWriter(_WindowsConsoleRawIOBase):\n    def 
writable(self) -> t.Literal[True]:\n        return True\n\n    @staticmethod\n    def 
_get_error_message(errno: int) -> str:\n        if errno == ERROR_SUCCESS:\n          
return \"ERROR_SUCCESS\"\n        elif errno == ERROR_NOT_ENOUGH_MEMORY:\n            
return \"ERROR_NOT_ENOUGH_MEMORY\"\n        return f\"Windows error {errno}\"\n\n    
def write(self, b: Buffer) -> int:\n        bytes_to_be_written = len(b)\n        buf 
= get_buffer(b)\n        code_units_to_be_written = min(bytes_to_be_written, 
MAX_BYTES_WRITTEN) // 2\n        code_units_written = c_ulong()\n\n        
WriteConsoleW(\n            HANDLE(self.handle),\n            buf,\n            
code_units_to_be_written,\n            byref(code_units_written),\n            None,\n
)\n        bytes_written = 2 * code_units_written.value\n\n        if bytes_written ==
0 and bytes_to_be_written > 0:\n            raise 
OSError(self._get_error_message(GetLastError()))\n        return bytes_written"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 163, "end_line": 164, "size": 2, 
"parent_context": "class_definition", "content": "def writable(self) -> 
t.Literal[True]:\n        return True"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 166, "end_line": 172, "size": 7, 
"parent_context": "class_definition", "content": "@staticmethod\n    def 
_get_error_message(errno: int) -> str:\n        if errno == ERROR_SUCCESS:\n          
return \"ERROR_SUCCESS\"\n        elif errno == ERROR_NOT_ENOUGH_MEMORY:\n            
return \"ERROR_NOT_ENOUGH_MEMORY\"\n        return f\"Windows error {errno}\""}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 167, "end_line": 172, "size": 6, 
"parent_context": "decorated_definition", "content": "def _get_error_message(errno: 
int) -> str:\n        if errno == ERROR_SUCCESS:\n            return 
\"ERROR_SUCCESS\"\n        elif errno == ERROR_NOT_ENOUGH_MEMORY:\n            return 
\"ERROR_NOT_ENOUGH_MEMORY\"\n        return f\"Windows error {errno}\""}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 174, "end_line": 191, "size": 18, 
"parent_context": "class_definition", "content": "def write(self, b: Buffer) -> int:\n
bytes_to_be_written = len(b)\n        buf = get_buffer(b)\n        
code_units_to_be_written = min(bytes_to_be_written, MAX_BYTES_WRITTEN) // 2\n        
code_units_written = c_ulong()\n\n        WriteConsoleW(\n            
HANDLE(self.handle),\n            buf,\n            code_units_to_be_written,\n       
byref(code_units_written),\n            None,\n        )\n        bytes_written = 2 * 
code_units_written.value\n\n        if bytes_written == 0 and bytes_to_be_written > 
0:\n            raise OSError(self._get_error_message(GetLastError()))\n        return
bytes_written"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"class_definition", "start_line": 194, "end_line": 223, "size": 30, "parent_context": 
"", "content": "class ConsoleStream:\n    def __init__(self, text_stream: t.TextIO, 
byte_stream: t.BinaryIO) -> None:\n        self._text_stream = text_stream\n        
self.buffer = byte_stream\n\n    @property\n    def name(self) -> str:\n        return
self.buffer.name\n\n    def write(self, x: t.AnyStr) -> int:\n        if isinstance(x,
str):\n            return self._text_stream.write(x)\n        try:\n            
self.flush()\n        except Exception:\n            pass\n        return 
self.buffer.write(x)\n\n    def writelines(self, lines: cabc.Iterable) -> None:\n     
for line in lines:\n            self.write(line)\n\n    def __getattr__(self, name: 
str) -> t.Any:\n        return getattr(self._text_stream, name)\n\n    def 
isatty(self) -> bool:\n        return self.buffer.isatty()\n\n    def __repr__(self) 
-> str:\n        return f\"<ConsoleStream name={self.name!r} 
encoding={self.encoding!r}>\""}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 195, "end_line": 197, "size": 3, 
"parent_context": "class_definition", "content": "def __init__(self, text_stream: 
t.TextIO, byte_stream: t.BinaryIO) -> None:\n        self._text_stream = text_stream\n
self.buffer = byte_stream"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 199, "end_line": 201, "size": 3, 
"parent_context": "class_definition", "content": "@property\n    def name(self) -> 
str:\n        return self.buffer.name"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 200, "end_line": 201, "size": 2, 
"parent_context": "decorated_definition", "content": "def name(self) -> str:\n        
return self.buffer.name"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 203, "end_line": 210, "size": 8, 
"parent_context": "class_definition", "content": "def write(self, x: t.AnyStr) -> 
int:\n        if isinstance(x, str):\n            return self._text_stream.write(x)\n 
try:\n            self.flush()\n        except Exception:\n            pass\n        
return self.buffer.write(x)"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 212, "end_line": 214, "size": 3, 
"parent_context": "class_definition", "content": "def writelines(self, lines: 
cabc.Iterable) -> None:\n        for line in lines:\n            self.write(line)"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 216, "end_line": 217, "size": 2, 
"parent_context": "class_definition", "content": "def __getattr__(self, name: str) -> 
t.Any:\n        return getattr(self._text_stream, name)"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 219, "end_line": 220, "size": 2, 
"parent_context": "class_definition", "content": "def isatty(self) -> bool:\n        
return self.buffer.isatty()"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 222, "end_line": 223, "size": 2, 
"parent_context": "class_definition", "content": "def __repr__(self) -> str:\n        
return f\"<ConsoleStream name={self.name!r} encoding={self.encoding!r}>\""}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 226, "end_line": 233, "size": 8, 
"parent_context": "", "content": "def _get_text_stdin(buffer_stream: t.BinaryIO) -> 
t.TextIO:\n    text_stream = _NonClosingTextIOWrapper(\n        
io.BufferedReader(_WindowsConsoleReader(STDIN_HANDLE)),\n        \"utf-16-le\",\n     
\"strict\",\n        line_buffering=True,\n    )\n    return t.cast(t.TextIO, 
ConsoleStream(text_stream, buffer_stream))"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 236, "end_line": 243, "size": 8, 
"parent_context": "", "content": "def _get_text_stdout(buffer_stream: t.BinaryIO) -> 
t.TextIO:\n    text_stream = _NonClosingTextIOWrapper(\n        
io.BufferedWriter(_WindowsConsoleWriter(STDOUT_HANDLE)),\n        \"utf-16-le\",\n    
\"strict\",\n        line_buffering=True,\n    )\n    return t.cast(t.TextIO, 
ConsoleStream(text_stream, buffer_stream))"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 246, "end_line": 253, "size": 8, 
"parent_context": "", "content": "def _get_text_stderr(buffer_stream: t.BinaryIO) -> 
t.TextIO:\n    text_stream = _NonClosingTextIOWrapper(\n        
io.BufferedWriter(_WindowsConsoleWriter(STDERR_HANDLE)),\n        \"utf-16-le\",\n    
\"strict\",\n        line_buffering=True,\n    )\n    return t.cast(t.TextIO, 
ConsoleStream(text_stream, buffer_stream))"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 263, "end_line": 273, "size": 11, 
"parent_context": "", "content": "def _is_console(f: t.TextIO) -> bool:\n    if not 
hasattr(f, \"fileno\"):\n        return False\n\n    try:\n        fileno = 
f.fileno()\n    except (OSError, io.UnsupportedOperation):\n        return False\n\n  
handle = msvcrt.get_osfhandle(fileno)\n    return bool(GetConsoleMode(handle, 
byref(DWORD())))"}
{"file": "click/src/click/_winconsole.py", "language": "python", "node_type": 
"function_definition", "start_line": 276, "end_line": 296, "size": 21, 
"parent_context": "", "content": "def _get_windows_console_stream(\n    f: t.TextIO, 
encoding: str | None, errors: str | None\n) -> t.TextIO | None:\n    if (\n        
get_buffer is None\n        or encoding not in {\"utf-16-le\", None}\n        or 
errors not in {\"strict\", None}\n        or not _is_console(f)\n    ):\n        
return None\n\n    func = _stream_factories.get(f.fileno())\n    if func is None:\n   
return None\n\n    b = getattr(f, \"buffer\", None)\n\n    if b is None:\n        
return None\n\n    return func(b)"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 19, "end_line": 23, "size": 5, "parent_context": 
"", "content": "def _join_param_hints(param_hint: cabc.Sequence | str | None) -> str |
None:\n    if param_hint is not None and not isinstance(param_hint, str):\n        
return \" / \".join(repr(x) for x in param_hint)\n\n    return param_hint"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"class_definition", "start_line": 26, "end_line": 53, "size": 28, "parent_context": 
"", "content": "class ClickException(Exception):\n    \"\"\"An exception that Click 
can handle and show to the user.\"\"\"\n\n    #: The exit code for this exception.\n  
exit_code = 1\n\n    def __init__(self, message: str) -> None:\n        
super().__init__(message)\n        # The context will be removed by the time we print 
the message, so cache\n        # the color settings here to be used later on (in 
`show`)\n        self.show_color: bool | None = resolve_color_default()\n        
self.message = message\n\n    def format_message(self) -> str:\n        return 
self.message\n\n    def __str__(self) -> str:\n        return self.message\n\n    def 
show(self, file: t.IO | None = None) -> None:\n        if file is None:\n            
file = get_text_stderr()\n\n        echo(\n            _(\"Error: 
{message}\").format(message=self.format_message()),\n            file=file,\n         
color=self.show_color,\n        )"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 32, "end_line": 37, "size": 6, "parent_context": 
"class_definition", "content": "def __init__(self, message: str) -> None:\n        
super().__init__(message)\n        # The context will be removed by the time we print 
the message, so cache\n        # the color settings here to be used later on (in 
`show`)\n        self.show_color: bool | None = resolve_color_default()\n        
self.message = message"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 39, "end_line": 40, "size": 2, "parent_context": 
"class_definition", "content": "def format_message(self) -> str:\n        return 
self.message"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 42, "end_line": 43, "size": 2, "parent_context": 
"class_definition", "content": "def __str__(self) -> str:\n        return 
self.message"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 45, "end_line": 53, "size": 9, "parent_context": 
"class_definition", "content": "def show(self, file: t.IO | None = None) -> None:\n   
if file is None:\n            file = get_text_stderr()\n\n        echo(\n            
_(\"Error: {message}\").format(message=self.format_message()),\n            
file=file,\n            color=self.show_color,\n        )"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"class_definition", "start_line": 56, "end_line": 92, "size": 37, "parent_context": 
"", "content": "class UsageError(ClickException):\n    \"\"\"An internal exception 
that signals a usage error.  This typically\n    aborts any further handling.\n\n    
:param message: the error message to display.\n    :param ctx: optionally the context 
that caused this error.  Click will\n                fill in the context automatically
in some situations.\n    \"\"\"\n\n    exit_code = 2\n\n    def __init__(self, 
message: str, ctx: Context | None = None) -> None:\n        
super().__init__(message)\n        self.ctx = ctx\n        self.cmd: Command | None = 
self.ctx.command if self.ctx else None\n\n    def show(self, file: t.IO | None = None)
-> None:\n        if file is None:\n            file = get_text_stderr()\n        
color = None\n        hint = \"\"\n        if (\n            self.ctx is not None\n   
and self.ctx.command.get_help_option(self.ctx) is not None\n        ):\n            
hint = _(\"Try '{command} {option}' for help.\").format(\n                
command=self.ctx.command_path, option=self.ctx.help_option_names[0]\n            )\n  
hint = f\"{hint}\\n\"\n        if self.ctx is not None:\n            color = 
self.ctx.color\n            echo(f\"{self.ctx.get_usage()}\\n{hint}\", file=file, 
color=color)\n        echo(\n            _(\"Error: 
{message}\").format(message=self.format_message()),\n            file=file,\n         
color=color,\n        )"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 67, "end_line": 70, "size": 4, "parent_context": 
"class_definition", "content": "def __init__(self, message: str, ctx: Context | None =
None) -> None:\n        super().__init__(message)\n        self.ctx = ctx\n        
self.cmd: Command | None = self.ctx.command if self.ctx else None"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 72, "end_line": 92, "size": 21, "parent_context":
"class_definition", "content": "def show(self, file: t.IO | None = None) -> None:\n   
if file is None:\n            file = get_text_stderr()\n        color = None\n        
hint = \"\"\n        if (\n            self.ctx is not None\n            and 
self.ctx.command.get_help_option(self.ctx) is not None\n        ):\n            hint =
_(\"Try '{command} {option}' for help.\").format(\n                
command=self.ctx.command_path, option=self.ctx.help_option_names[0]\n            )\n  
hint = f\"{hint}\\n\"\n        if self.ctx is not None:\n            color = 
self.ctx.color\n            echo(f\"{self.ctx.get_usage()}\\n{hint}\", file=file, 
color=color)\n        echo(\n            _(\"Error: 
{message}\").format(message=self.format_message()),\n            file=file,\n         
color=color,\n        )"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"class_definition", "start_line": 95, "end_line": 134, "size": 40, "parent_context": 
"", "content": "class BadParameter(UsageError):\n    \"\"\"An exception that formats 
out a standardized error message for a\n    bad parameter.  This is useful when thrown
from a callback or type as\n    Click will attach contextual information to it (for 
instance, which\n    parameter it is).\n\n    .. versionadded:: 2.0\n\n    :param 
param: the parameter object that caused this error.  This can\n                  be 
left out, and Click will attach this info itself\n                  if possible.\n    
:param param_hint: a string that shows up as parameter name.  This\n                  
can be used as alternative to `param` in cases\n                       where custom 
validation should happen.  If it is\n                       a string it's used as 
such, if it's a list then\n                       each item is quoted and separated.\n
\"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        ctx: 
Context | None = None,\n        param: Parameter | None = None,\n        param_hint: 
cabc.Sequence | str | None = None,\n    ) -> None:\n        super().__init__(message, 
ctx)\n        self.param = param\n        self.param_hint = param_hint\n\n    def 
format_message(self) -> str:\n        if self.param_hint is not None:\n            
param_hint = self.param_hint\n        elif self.param is not None:\n            
param_hint = self.param.get_error_hint(self.ctx)  # type: ignore\n        else:\n     
return _(\"Invalid value: {message}\").format(message=self.message)\n\n        return 
_(\"Invalid value for {param_hint}: {message}\").format(\n            
param_hint=_join_param_hints(param_hint), message=self.message\n        )"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 113, "end_line": 122, "size": 10, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
message: str,\n        ctx: Context | None = None,\n        param: Parameter | None = 
None,\n        param_hint: cabc.Sequence | str | None = None,\n    ) -> None:\n       
super().__init__(message, ctx)\n        self.param = param\n        self.param_hint = 
param_hint"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 124, "end_line": 134, "size": 11, 
"parent_context": "class_definition", "content": "def format_message(self) -> str:\n  
if self.param_hint is not None:\n            param_hint = self.param_hint\n        
elif self.param is not None:\n            param_hint = 
self.param.get_error_hint(self.ctx)  # type: ignore\n        else:\n            return
_(\"Invalid value: {message}\").format(message=self.message)\n\n        return 
_(\"Invalid value for {param_hint}: {message}\").format(\n            
param_hint=_join_param_hints(param_hint), message=self.message\n        )"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"class_definition", "start_line": 137, "end_line": 205, "size": 69, "parent_context": 
"", "content": "class MissingParameter(BadParameter):\n    \"\"\"Raised if click 
required an option or argument but it was not\n    provided when invoking the 
script.\n\n    .. versionadded:: 4.0\n\n    :param param_type: a string that indicates
the type of the parameter.\n                       The default is to inherit the 
parameter type from\n                       the given `param`.  Valid values are 
``'parameter'``,\n                       ``'option'`` or ``'argument'``.\n    
\"\"\"\n\n    def __init__(\n        self,\n        message: str | None = None,\n     
ctx: Context | None = None,\n        param: Parameter | None = None,\n        
param_hint: cabc.Sequence | str | None = None,\n        param_type: str | None = 
None,\n    ) -> None:\n        super().__init__(message or \"\", ctx, param, 
param_hint)\n        self.param_type = param_type\n\n    def format_message(self) -> 
str:\n        if self.param_hint is not None:\n            param_hint: cabc.Sequence |
str | None = self.param_hint\n        elif self.param is not None:\n            
param_hint = self.param.get_error_hint(self.ctx)  # type: ignore\n        else:\n     
param_hint = None\n\n        param_hint = _join_param_hints(param_hint)\n        
param_hint = f\" {param_hint}\" if param_hint else \"\"\n\n        param_type = 
self.param_type\n        if param_type is None and self.param is not None:\n          
param_type = self.param.param_type_name\n\n        msg = self.message\n        if 
self.param is not None:\n            msg_extra = 
self.param.type.get_missing_message(\n                param=self.param, ctx=self.ctx\n
)\n            if msg_extra:\n                if msg:\n                    msg += f\".
{msg_extra}\"\n                else:\n                    msg = msg_extra\n\n        
msg = f\" {msg}\" if msg else \"\"\n\n        # Translate param_type for known 
types.\n        if param_type == \"argument\":\n            missing = _(\"Missing 
argument\")\n        elif param_type == \"option\":\n            missing = _(\"Missing
option\")\n        elif param_type == \"parameter\":\n            missing = 
_(\"Missing parameter\")\n        else:\n            missing = _(\"Missing 
{param_type}\").format(param_type=param_type)\n\n        return 
f\"{missing}{param_hint}.{msg}\"\n\n    def __str__(self) -> str:\n        if not 
self.message:\n            param_name = self.param.name if self.param else None\n     
return _(\"Missing parameter: {param_name}\").format(param_name=param_name)\n        
else:\n            return self.message"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 149, "end_line": 158, "size": 10, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
message: str | None = None,\n        ctx: Context | None = None,\n        param: 
Parameter | None = None,\n        param_hint: cabc.Sequence | str | None = None,\n    
param_type: str | None = None,\n    ) -> None:\n        super().__init__(message or 
\"\", ctx, param, param_hint)\n        self.param_type = param_type"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 160, "end_line": 198, "size": 39, 
"parent_context": "class_definition", "content": "def format_message(self) -> str:\n  
if self.param_hint is not None:\n            param_hint: cabc.Sequence | str | None = 
self.param_hint\n        elif self.param is not None:\n            param_hint = 
self.param.get_error_hint(self.ctx)  # type: ignore\n        else:\n            
param_hint = None\n\n        param_hint = _join_param_hints(param_hint)\n        
param_hint = f\" {param_hint}\" if param_hint else \"\"\n\n        param_type = 
self.param_type\n        if param_type is None and self.param is not None:\n          
param_type = self.param.param_type_name\n\n        msg = self.message\n        if 
self.param is not None:\n            msg_extra = 
self.param.type.get_missing_message(\n                param=self.param, ctx=self.ctx\n
)\n            if msg_extra:\n                if msg:\n                    msg += f\".
{msg_extra}\"\n                else:\n                    msg = msg_extra\n\n        
msg = f\" {msg}\" if msg else \"\"\n\n        # Translate param_type for known 
types.\n        if param_type == \"argument\":\n            missing = _(\"Missing 
argument\")\n        elif param_type == \"option\":\n            missing = _(\"Missing
option\")\n        elif param_type == \"parameter\":\n            missing = 
_(\"Missing parameter\")\n        else:\n            missing = _(\"Missing 
{param_type}\").format(param_type=param_type)\n\n        return 
f\"{missing}{param_hint}.{msg}\""}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 200, "end_line": 205, "size": 6, 
"parent_context": "class_definition", "content": "def __str__(self) -> str:\n        
if not self.message:\n            param_name = self.param.name if self.param else 
None\n            return _(\"Missing parameter: 
{param_name}\").format(param_name=param_name)\n        else:\n            return 
self.message"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"class_definition", "start_line": 208, "end_line": 239, "size": 32, "parent_context": 
"", "content": "class NoSuchOption(UsageError):\n    \"\"\"Raised if click attempted 
to handle an option that does not\n    exist.\n\n    .. versionadded:: 4.0\n    
\"\"\"\n\n    def __init__(\n        self,\n        option_name: str,\n        
message: str | None = None,\n        possibilities: cabc.Sequence | None = None,\n    
ctx: Context | None = None,\n    ) -> None:\n        if message is None:\n            
message = _(\"No such option: {name}\").format(name=option_name)\n\n        
super().__init__(message, ctx)\n        self.option_name = option_name\n        
self.possibilities = possibilities\n\n    def format_message(self) -> str:\n        if
not self.possibilities:\n            return self.message\n\n        possibility_str = 
\", \".join(sorted(self.possibilities))\n        suggest = ngettext(\n            
\"Did you mean {possibility}?\",\n            \"(Possible options: 
{possibilities})\",\n            len(self.possibilities),\n        
).format(possibility=possibility_str, possibilities=possibility_str)\n        return 
f\"{self.message} {suggest}\""}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 215, "end_line": 227, "size": 13, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
option_name: str,\n        message: str | None = None,\n        possibilities: 
cabc.Sequence | None = None,\n        ctx: Context | None = None,\n    ) -> None:\n   
if message is None:\n            message = _(\"No such option: 
{name}\").format(name=option_name)\n\n        super().__init__(message, ctx)\n        
self.option_name = option_name\n        self.possibilities = possibilities"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 229, "end_line": 239, "size": 11, 
"parent_context": "class_definition", "content": "def format_message(self) -> str:\n  
if not self.possibilities:\n            return self.message\n\n        possibility_str
= \", \".join(sorted(self.possibilities))\n        suggest = ngettext(\n            
\"Did you mean {possibility}?\",\n            \"(Possible options: 
{possibilities})\",\n            len(self.possibilities),\n        
).format(possibility=possibility_str, possibilities=possibility_str)\n        return 
f\"{self.message} {suggest}\""}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"class_definition", "start_line": 242, "end_line": 256, "size": 15, "parent_context": 
"", "content": "class BadOptionUsage(UsageError):\n    \"\"\"Raised if an option is 
generally supplied but the use of the option\n    was incorrect.  This is for instance
raised if the number of arguments\n    for an option is not correct.\n\n    .. 
versionadded:: 4.0\n\n    :param option_name: the name of the option being used 
incorrectly.\n    \"\"\"\n\n    def __init__(\n        self, option_name: str, 
message: str, ctx: Context | None = None\n    ) -> None:\n        
super().__init__(message, ctx)\n        self.option_name = option_name"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 252, "end_line": 256, "size": 5, 
"parent_context": "class_definition", "content": "def __init__(\n        self, 
option_name: str, message: str, ctx: Context | None = None\n    ) -> None:\n        
super().__init__(message, ctx)\n        self.option_name = option_name"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"class_definition", "start_line": 259, "end_line": 265, "size": 7, "parent_context": 
"", "content": "class BadArgumentUsage(UsageError):\n    \"\"\"Raised if an argument 
is generally supplied but the use of the argument\n    was incorrect.  This is for 
instance raised if the number of values\n    for an argument is not correct.\n\n    ..
versionadded:: 6.0\n    \"\"\""}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"class_definition", "start_line": 268, "end_line": 274, "size": 7, "parent_context": 
"", "content": "class NoArgsIsHelpError(UsageError):\n    def __init__(self, ctx: 
Context) -> None:\n        self.ctx: Context\n        super().__init__(ctx.get_help(),
ctx=ctx)\n\n    def show(self, file: t.IO | None = None) -> None:\n        
echo(self.format_message(), file=file, err=True, color=self.ctx.color)"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 269, "end_line": 271, "size": 3, 
"parent_context": "class_definition", "content": "def __init__(self, ctx: Context) -> 
None:\n        self.ctx: Context\n        super().__init__(ctx.get_help(), ctx=ctx)"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 273, "end_line": 274, "size": 2, 
"parent_context": "class_definition", "content": "def show(self, file: t.IO | None = 
None) -> None:\n        echo(self.format_message(), file=file, err=True, 
color=self.ctx.color)"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"class_definition", "start_line": 277, "end_line": 291, "size": 15, "parent_context": 
"", "content": "class FileError(ClickException):\n    \"\"\"Raised if a file cannot be
opened.\"\"\"\n\n    def __init__(self, filename: str, hint: str | None = None) -> 
None:\n        if hint is None:\n            hint = _(\"unknown error\")\n\n        
super().__init__(hint)\n        self.ui_filename: str = format_filename(filename)\n   
self.filename = filename\n\n    def format_message(self) -> str:\n        return 
_(\"Could not open file {filename!r}: {message}\").format(\n            
filename=self.ui_filename, message=self.message\n        )"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 280, "end_line": 286, "size": 7, 
"parent_context": "class_definition", "content": "def __init__(self, filename: str, 
hint: str | None = None) -> None:\n        if hint is None:\n            hint = 
_(\"unknown error\")\n\n        super().__init__(hint)\n        self.ui_filename: str 
= format_filename(filename)\n        self.filename = filename"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 288, "end_line": 291, "size": 4, 
"parent_context": "class_definition", "content": "def format_message(self) -> str:\n  
return _(\"Could not open file {filename!r}: {message}\").format(\n            
filename=self.ui_filename, message=self.message\n        )"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"class_definition", "start_line": 294, "end_line": 295, "size": 2, "parent_context": 
"", "content": "class Abort(RuntimeError):\n    \"\"\"An internal signalling exception
that signals Click to abort.\"\"\""}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"class_definition", "start_line": 298, "end_line": 308, "size": 11, "parent_context": 
"", "content": "class Exit(RuntimeError):\n    \"\"\"An exception that indicates that 
the application should exit with some\n    status code.\n\n    :param code: the status
code to exit with.\n    \"\"\"\n\n    __slots__ = (\"exit_code\",)\n\n    def 
__init__(self, code: int = 0) -> None:\n        self.exit_code: int = code"}
{"file": "click/src/click/exceptions.py", "language": "python", "node_type": 
"function_definition", "start_line": 307, "end_line": 308, "size": 2, 
"parent_context": "class_definition", "content": "def __init__(self, code: int = 0) ->
None:\n        self.exit_code: int = code"}
{"file": "click/src/click/__init__.py", "language": "python", "node_type": 
"function_definition", "start_line": 74, "end_line": 123, "size": 50, 
"parent_context": "", "content": "def __getattr__(name: str) -> object:\n    import 
warnings\n\n    if name == \"BaseCommand\":\n        from .core import 
_BaseCommand\n\n        warnings.warn(\n            \"'BaseCommand' is deprecated and 
will be removed in Click 9.0. Use\"\n            \" 'Command' instead.\",\n           
DeprecationWarning,\n            stacklevel=2,\n        )\n        return 
_BaseCommand\n\n    if name == \"MultiCommand\":\n        from .core import 
_MultiCommand\n\n        warnings.warn(\n            \"'MultiCommand' is deprecated 
and will be removed in Click 9.0. Use\"\n            \" 'Group' instead.\",\n         
DeprecationWarning,\n            stacklevel=2,\n        )\n        return 
_MultiCommand\n\n    if name == \"OptionParser\":\n        from .parser import 
_OptionParser\n\n        warnings.warn(\n            \"'OptionParser' is deprecated 
and will be removed in Click 9.0. The\"\n            \" old parser is available in 
'optparse'.\",\n            DeprecationWarning,\n            stacklevel=2,\n        
)\n        return _OptionParser\n\n    if name == \"__version__\":\n        import 
importlib.metadata\n        import warnings\n\n        warnings.warn(\n            
\"The '__version__' attribute is deprecated and will be removed in\"\n            \" 
Click 9.1. Use feature detection or\"\n            \" 
'importlib.metadata.version(\\\"click\\\")' instead.\",\n            
DeprecationWarning,\n            stacklevel=2,\n        )\n        return 
importlib.metadata.version(\"click\")\n\n    raise AttributeError(name)"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 28, "end_line": 36, "size": 9, "parent_context": 
"", "content": "def pass_context(f: t.Callable[te.Concatenate[Context, P], R]) -> 
t.Callable[P, R]:\n    \"\"\"Marks a callback as wanting to receive the current 
context\n    object as first argument.\n    \"\"\"\n\n    def new_func(*args: P.args, 
**kwargs: P.kwargs) -> R:\n        return f(get_current_context(), *args, 
**kwargs)\n\n    return update_wrapper(new_func, f)"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 33, "end_line": 34, "size": 2, "parent_context": 
"function_definition", "content": "def new_func(*args: P.args, **kwargs: P.kwargs) -> 
R:\n        return f(get_current_context(), *args, **kwargs)"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 39, "end_line": 48, "size": 10, "parent_context":
"", "content": "def pass_obj(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, 
R]:\n    \"\"\"Similar to :func:`pass_context`, but only pass the object on the\n    
context onwards (:attr:`Context.obj`).  This is useful if that object\n    represents 
the state of a nested system.\n    \"\"\"\n\n    def new_func(*args: P.args, **kwargs:
P.kwargs) -> R:\n        return f(get_current_context().obj, *args, **kwargs)\n\n    
return update_wrapper(new_func, f)"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 45, "end_line": 46, "size": 2, "parent_context": 
"function_definition", "content": "def new_func(*args: P.args, **kwargs: P.kwargs) -> 
R:\n        return f(get_current_context().obj, *args, **kwargs)"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 51, "end_line": 97, "size": 47, "parent_context":
"", "content": "def make_pass_decorator(\n    object_type: type[T], ensure: bool = 
False\n) -> t.Callable[[t.Callable[te.Concatenate[T, P], R]], t.Callable[P, R]]:\n    
\"\"\"Given an object type this creates a decorator that will work\n    similar to 
:func:`pass_obj` but instead of passing the object of the\n    current context, it 
will find the innermost context of type\n    :func:`object_type`.\n\n    This 
generates a decorator that works roughly like this::\n\n        from functools import 
update_wrapper\n\n        def decorator(f):\n            @pass_context\n            
def new_func(ctx, *args, **kwargs):\n                obj = 
ctx.find_object(object_type)\n                return ctx.invoke(f, obj, *args, 
**kwargs)\n            return update_wrapper(new_func, f)\n        return 
decorator\n\n    :param object_type: the type of the object to pass.\n    :param 
ensure: if set to `True`, a new object will be created and\n                   
remembered on the context if it's not there yet.\n    \"\"\"\n\n    def decorator(f: 
t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:\n        def new_func(*args:
P.args, **kwargs: P.kwargs) -> R:\n            ctx = get_current_context()\n\n        
obj: T | None\n            if ensure:\n                obj = 
ctx.ensure_object(object_type)\n            else:\n                obj = 
ctx.find_object(object_type)\n\n            if obj is None:\n                raise 
RuntimeError(\n                    \"Managed to invoke callback without a context\"\n 
f\" object of type {object_type.__name__!r}\"\n                    \" existing.\"\n   
)\n\n            return ctx.invoke(f, obj, *args, **kwargs)\n\n        return 
update_wrapper(new_func, f)\n\n    return decorator"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 76, "end_line": 95, "size": 20, "parent_context":
"function_definition", "content": "def decorator(f: t.Callable[te.Concatenate[T, P], 
R]) -> t.Callable[P, R]:\n        def new_func(*args: P.args, **kwargs: P.kwargs) -> 
R:\n            ctx = get_current_context()\n\n            obj: T | None\n            
if ensure:\n                obj = ctx.ensure_object(object_type)\n            else:\n 
obj = ctx.find_object(object_type)\n\n            if obj is None:\n                
raise RuntimeError(\n                    \"Managed to invoke callback without a 
context\"\n                    f\" object of type {object_type.__name__!r}\"\n        
\" existing.\"\n                )\n\n            return ctx.invoke(f, obj, *args, 
**kwargs)\n\n        return update_wrapper(new_func, f)"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 77, "end_line": 93, "size": 17, "parent_context":
"function_definition", "content": "def new_func(*args: P.args, **kwargs: P.kwargs) -> 
R:\n            ctx = get_current_context()\n\n            obj: T | None\n            
if ensure:\n                obj = ctx.ensure_object(object_type)\n            else:\n 
obj = ctx.find_object(object_type)\n\n            if obj is None:\n                
raise RuntimeError(\n                    \"Managed to invoke callback without a 
context\"\n                    f\" object of type {object_type.__name__!r}\"\n        
\" existing.\"\n                )\n\n            return ctx.invoke(f, obj, *args, 
**kwargs)"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 100, "end_line": 130, "size": 31, 
"parent_context": "", "content": "def pass_meta_key(\n    key: str, *, 
doc_description: str | None = None\n) -> t.Callable[[t.Callable[te.Concatenate[T, P], 
R]], t.Callable[P, R]]:\n    \"\"\"Create a decorator that passes a key from\n    
:attr:`click.Context.meta` as the first argument to the decorated\n    function.\n\n  
:param key: Key in ``Context.meta`` to pass.\n    :param doc_description: Description 
of the object being passed,\n        inserted into the decorator's docstring. Defaults
to \"the 'key'\n        key from Context.meta\".\n\n    .. versionadded:: 8.0\n    
\"\"\"\n\n    def decorator(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, 
R]:\n        def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n            ctx = 
get_current_context()\n            obj = ctx.meta\n            return ctx.invoke(f, 
obj, *args, **kwargs)\n\n        return update_wrapper(new_func, f)\n\n    if 
doc_description is None:\n        doc_description = f\"the {key!r} key from 
:attr:`click.Context.meta`\"\n\n    decorator.__doc__ = (\n        f\"Decorator that 
passes {doc_description} as the first argument\"\n        \" to the decorated 
function.\"\n    )\n    return decorator"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 115, "end_line": 121, "size": 7, 
"parent_context": "function_definition", "content": "def decorator(f: 
t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:\n        def new_func(*args:
P.args, **kwargs: P.kwargs) -> R:\n            ctx = get_current_context()\n          
obj = ctx.meta\n            return ctx.invoke(f, obj, *args, **kwargs)\n\n        
return update_wrapper(new_func, f)"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 116, "end_line": 119, "size": 4, 
"parent_context": "function_definition", "content": "def new_func(*args: P.args, 
**kwargs: P.kwargs) -> R:\n            ctx = get_current_context()\n            obj = 
ctx.meta\n            return ctx.invoke(f, obj, *args, **kwargs)"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 137, "end_line": 138, "size": 2, 
"parent_context": "", "content": "@t.overload\ndef command(name: _AnyCallable) -> 
Command: ..."}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 138, "end_line": 138, "size": 1, 
"parent_context": "decorated_definition", "content": "def command(name: _AnyCallable) 
-> Command: ..."}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 143, "end_line": 148, "size": 6, 
"parent_context": "", "content": "@t.overload\ndef command(\n    name: str | None,\n  
cls: type[CmdType],\n    **attrs: t.Any,\n) -> t.Callable[[_AnyCallable], CmdType]: 
..."}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 144, "end_line": 148, "size": 5, 
"parent_context": "decorated_definition", "content": "def command(\n    name: str | 
None,\n    cls: type[CmdType],\n    **attrs: t.Any,\n) -> t.Callable[[_AnyCallable], 
CmdType]: ..."}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 152, "end_line": 158, "size": 7, 
"parent_context": "", "content": "@t.overload\ndef command(\n    name: None = None,\n 
*,\n    cls: type[CmdType],\n    **attrs: t.Any,\n) -> t.Callable[[_AnyCallable], 
CmdType]: ..."}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 153, "end_line": 158, "size": 6, 
"parent_context": "decorated_definition", "content": "def command(\n    name: None = 
None,\n    *,\n    cls: type[CmdType],\n    **attrs: t.Any,\n) -> 
t.Callable[[_AnyCallable], CmdType]: ..."}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 162, "end_line": 165, "size": 4, 
"parent_context": "", "content": "@t.overload\ndef command(\n    name: str | None = 
..., cls: None = None, **attrs: t.Any\n) -> t.Callable[[_AnyCallable], Command]: ..."}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 163, "end_line": 165, "size": 3, 
"parent_context": "decorated_definition", "content": "def command(\n    name: str | 
None = ..., cls: None = None, **attrs: t.Any\n) -> t.Callable[[_AnyCallable], 
Command]: ..."}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 168, "end_line": 255, "size": 88, 
"parent_context": "", "content": "def command(\n    name: str | _AnyCallable | None = 
None,\n    cls: type[CmdType] | None = None,\n    **attrs: t.Any,\n) -> Command | 
t.Callable[[_AnyCallable], Command | CmdType]:\n    r\"\"\"Creates a new 
:class:`Command` and uses the decorated function as\n    callback.  This will also 
automatically attach all decorated\n    :func:`option`\\s and :func:`argument`\\s as 
parameters to the command.\n\n    The name of the command defaults to the name of the 
function, converted to\n    lowercase, with underscores ``_`` replaced by dashes 
``-``, and the suffixes\n    ``_command``, ``_cmd``, ``_group``, and ``_grp`` are 
removed. For example,\n    ``init_data_command`` becomes ``init-data``.\n\n    All 
keyword arguments are forwarded to the underlying command class.\n    For the 
``params`` argument, any decorated params are appended to\n    the end of the 
list.\n\n    Once decorated the function turns into a :class:`Command` instance\n    
that can be invoked as a command line utility or be attached to a\n    command 
:class:`Group`.\n\n    :param name: The name of the command. Defaults to modifying the
function's\n        name as described above.\n    :param cls: The command class to 
create. Defaults to :class:`Command`.\n\n    .. versionchanged:: 8.2\n        The 
suffixes ``_command``, ``_cmd``, ``_group``, and ``_grp`` are\n        removed when 
generating the name.\n\n    .. versionchanged:: 8.1\n        This decorator can be 
applied without parentheses.\n\n    .. versionchanged:: 8.1\n        The ``params`` 
argument can be used. Decorated params are\n        appended to the end of the list.\n
\"\"\"\n\n    func: t.Callable[[_AnyCallable], t.Any] | None = None\n\n    if 
callable(name):\n        func = name\n        name = None\n        assert cls is None,
\"Use 'command(cls=cls)(callable)' to specify a class.\"\n        assert not attrs, 
\"Use 'command(**kwargs)(callable)' to provide arguments.\"\n\n    if cls is None:\n  
cls = t.cast(\"type[CmdType]\", Command)\n\n    def decorator(f: _AnyCallable) -> 
CmdType:\n        if isinstance(f, Command):\n            raise TypeError(\"Attempted 
to convert a callback into a command twice.\")\n\n        attr_params = 
attrs.pop(\"params\", None)\n        params = attr_params if attr_params is not None 
else []\n\n        try:\n            decorator_params = f.__click_params__  # type: 
ignore\n        except AttributeError:\n            pass\n        else:\n            
del f.__click_params__  # type: ignore\n            
params.extend(reversed(decorator_params))\n\n        if attrs.get(\"help\") is None:\n
attrs[\"help\"] = f.__doc__\n\n        if t.TYPE_CHECKING:\n            assert cls is 
not None\n            assert not callable(name)\n\n        if name is not None:\n     
cmd_name = name\n        else:\n            cmd_name = 
f.__name__.lower().replace(\"_\", \"-\")\n            cmd_left, sep, suffix = 
cmd_name.rpartition(\"-\")\n\n            if sep and suffix in {\"command\", \"cmd\", 
\"group\", \"grp\"}:\n                cmd_name = cmd_left\n\n        cmd = 
cls(name=cmd_name, callback=f, params=params, **attrs)\n        cmd.__doc__ = 
f.__doc__\n        return cmd\n\n    if func is not None:\n        return 
decorator(func)\n\n    return decorator"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 217, "end_line": 250, "size": 34, 
"parent_context": "function_definition", "content": "def decorator(f: _AnyCallable) ->
CmdType:\n        if isinstance(f, Command):\n            raise TypeError(\"Attempted 
to convert a callback into a command twice.\")\n\n        attr_params = 
attrs.pop(\"params\", None)\n        params = attr_params if attr_params is not None 
else []\n\n        try:\n            decorator_params = f.__click_params__  # type: 
ignore\n        except AttributeError:\n            pass\n        else:\n            
del f.__click_params__  # type: ignore\n            
params.extend(reversed(decorator_params))\n\n        if attrs.get(\"help\") is None:\n
attrs[\"help\"] = f.__doc__\n\n        if t.TYPE_CHECKING:\n            assert cls is 
not None\n            assert not callable(name)\n\n        if name is not None:\n     
cmd_name = name\n        else:\n            cmd_name = 
f.__name__.lower().replace(\"_\", \"-\")\n            cmd_left, sep, suffix = 
cmd_name.rpartition(\"-\")\n\n            if sep and suffix in {\"command\", \"cmd\", 
\"group\", \"grp\"}:\n                cmd_name = cmd_left\n\n        cmd = 
cls(name=cmd_name, callback=f, params=params, **attrs)\n        cmd.__doc__ = 
f.__doc__\n        return cmd"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 262, "end_line": 263, "size": 2, 
"parent_context": "", "content": "@t.overload\ndef group(name: _AnyCallable) -> Group:
..."}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 263, "end_line": 263, "size": 1, 
"parent_context": "decorated_definition", "content": "def group(name: _AnyCallable) ->
Group: ..."}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 268, "end_line": 273, "size": 6, 
"parent_context": "", "content": "@t.overload\ndef group(\n    name: str | None,\n    
cls: type[GrpType],\n    **attrs: t.Any,\n) -> t.Callable[[_AnyCallable], GrpType]: 
..."}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 269, "end_line": 273, "size": 5, 
"parent_context": "decorated_definition", "content": "def group(\n    name: str | 
None,\n    cls: type[GrpType],\n    **attrs: t.Any,\n) -> t.Callable[[_AnyCallable], 
GrpType]: ..."}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 277, "end_line": 283, "size": 7, 
"parent_context": "", "content": "@t.overload\ndef group(\n    name: None = None,\n   
*,\n    cls: type[GrpType],\n    **attrs: t.Any,\n) -> t.Callable[[_AnyCallable], 
GrpType]: ..."}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 278, "end_line": 283, "size": 6, 
"parent_context": "decorated_definition", "content": "def group(\n    name: None = 
None,\n    *,\n    cls: type[GrpType],\n    **attrs: t.Any,\n) -> 
t.Callable[[_AnyCallable], GrpType]: ..."}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 287, "end_line": 290, "size": 4, 
"parent_context": "", "content": "@t.overload\ndef group(\n    name: str | None = ...,
cls: None = None, **attrs: t.Any\n) -> t.Callable[[_AnyCallable], Group]: ..."}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 288, "end_line": 290, "size": 3, 
"parent_context": "decorated_definition", "content": "def group(\n    name: str | None
= ..., cls: None = None, **attrs: t.Any\n) -> t.Callable[[_AnyCallable], Group]: ..."}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 293, "end_line": 311, "size": 19, 
"parent_context": "", "content": "def group(\n    name: str | _AnyCallable | None = 
None,\n    cls: type[GrpType] | None = None,\n    **attrs: t.Any,\n) -> Group | 
t.Callable[[_AnyCallable], Group | GrpType]:\n    \"\"\"Creates a new :class:`Group` 
with a function as callback.  This\n    works otherwise the same as :func:`command` 
just that the `cls`\n    parameter is set to :class:`Group`.\n\n    .. 
versionchanged:: 8.1\n        This decorator can be applied without parentheses.\n    
\"\"\"\n    if cls is None:\n        cls = t.cast(\"type[GrpType]\", Group)\n\n    if 
callable(name):\n        return command(cls=cls, **attrs)(name)\n\n    return 
command(name, cls, **attrs)"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 314, "end_line": 321, "size": 8, 
"parent_context": "", "content": "def _param_memo(f: t.Callable[..., t.Any], param: 
Parameter) -> None:\n    if isinstance(f, Command):\n        f.params.append(param)\n 
else:\n        if not hasattr(f, \"__click_params__\"):\n            
f.__click_params__ = []  # type: ignore\n\n        f.__click_params__.append(param)  #
type: ignore"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 324, "end_line": 349, "size": 26, 
"parent_context": "", "content": "def argument(\n    *param_decls: str, cls: 
type[Argument] | None = None, **attrs: t.Any\n) -> t.Callable[[FC], FC]:\n    
\"\"\"Attaches an argument to the command.  All positional arguments are\n    passed 
as parameter declarations to :class:`Argument`; all keyword\n    arguments are 
forwarded unchanged (except ``cls``).\n    This is equivalent to creating an 
:class:`Argument` instance manually\n    and attaching it to the 
:attr:`Command.params` list.\n\n    For the default argument class, refer to 
:class:`Argument` and\n    :class:`Parameter` for descriptions of parameters.\n\n    
:param cls: the argument class to instantiate.  This defaults to\n                
:class:`Argument`.\n    :param param_decls: Passed as positional arguments to the 
constructor of\n        ``cls``.\n    :param attrs: Passed as keyword arguments to the
constructor of ``cls``.\n    \"\"\"\n    if cls is None:\n        cls = Argument\n\n  
def decorator(f: FC) -> FC:\n        _param_memo(f, cls(param_decls, **attrs))\n      
return f\n\n    return decorator"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 345, "end_line": 347, "size": 3, 
"parent_context": "function_definition", "content": "def decorator(f: FC) -> FC:\n    
_param_memo(f, cls(param_decls, **attrs))\n        return f"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 352, "end_line": 377, "size": 26, 
"parent_context": "", "content": "def option(\n    *param_decls: str, cls: 
type[Option] | None = None, **attrs: t.Any\n) -> t.Callable[[FC], FC]:\n    
\"\"\"Attaches an option to the command.  All positional arguments are\n    passed as 
parameter declarations to :class:`Option`; all keyword\n    arguments are forwarded 
unchanged (except ``cls``).\n    This is equivalent to creating an :class:`Option` 
instance manually\n    and attaching it to the :attr:`Command.params` list.\n\n    For
the default option class, refer to :class:`Option` and\n    :class:`Parameter` for 
descriptions of parameters.\n\n    :param cls: the option class to instantiate.  This 
defaults to\n                :class:`Option`.\n    :param param_decls: Passed as 
positional arguments to the constructor of\n        ``cls``.\n    :param attrs: Passed
as keyword arguments to the constructor of ``cls``.\n    \"\"\"\n    if cls is None:\n
cls = Option\n\n    def decorator(f: FC) -> FC:\n        _param_memo(f, 
cls(param_decls, **attrs))\n        return f\n\n    return decorator"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 373, "end_line": 375, "size": 3, 
"parent_context": "function_definition", "content": "def decorator(f: FC) -> FC:\n    
_param_memo(f, cls(param_decls, **attrs))\n        return f"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 380, "end_line": 401, "size": 22, 
"parent_context": "", "content": "def confirmation_option(*param_decls: str, **kwargs:
t.Any) -> t.Callable[[FC], FC]:\n    \"\"\"Add a ``--yes`` option which shows a prompt
before continuing if\n    not passed. If the prompt is declined, the program will 
exit.\n\n    :param param_decls: One or more option names. Defaults to the single\n   
value ``\"--yes\"``.\n    :param kwargs: Extra arguments are passed to 
:func:`option`.\n    \"\"\"\n\n    def callback(ctx: Context, param: Parameter, value:
bool) -> None:\n        if not value:\n            ctx.abort()\n\n    if not 
param_decls:\n        param_decls = (\"--yes\",)\n\n    kwargs.setdefault(\"is_flag\",
True)\n    kwargs.setdefault(\"callback\", callback)\n    
kwargs.setdefault(\"expose_value\", False)\n    kwargs.setdefault(\"prompt\", \"Do you
want to continue?\")\n    kwargs.setdefault(\"help\", \"Confirm the action without 
prompting.\")\n    return option(*param_decls, **kwargs)"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 389, "end_line": 391, "size": 3, 
"parent_context": "function_definition", "content": "def callback(ctx: Context, param:
Parameter, value: bool) -> None:\n        if not value:\n            ctx.abort()"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 404, "end_line": 418, "size": 15, 
"parent_context": "", "content": "def password_option(*param_decls: str, **kwargs: 
t.Any) -> t.Callable[[FC], FC]:\n    \"\"\"Add a ``--password`` option which prompts 
for a password, hiding\n    input and asking to enter the value again for 
confirmation.\n\n    :param param_decls: One or more option names. Defaults to the 
single\n        value ``\"--password\"``.\n    :param kwargs: Extra arguments are 
passed to :func:`option`.\n    \"\"\"\n    if not param_decls:\n        param_decls = 
(\"--password\",)\n\n    kwargs.setdefault(\"prompt\", True)\n    
kwargs.setdefault(\"confirmation_prompt\", True)\n    
kwargs.setdefault(\"hide_input\", True)\n    return option(*param_decls, **kwargs)"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 421, "end_line": 524, "size": 104, 
"parent_context": "", "content": "def version_option(\n    version: str | None = 
None,\n    *param_decls: str,\n    package_name: str | None = None,\n    prog_name: 
str | None = None,\n    message: str | None = None,\n    **kwargs: t.Any,\n) -> 
t.Callable[[FC], FC]:\n    \"\"\"Add a ``--version`` option which immediately prints 
the version\n    number and exits the program.\n\n    If ``version`` is not provided, 
Click will try to detect it using\n    :func:`importlib.metadata.version` to get the 
version for the\n    ``package_name``.\n\n    If ``package_name`` is not provided, 
Click will try to detect it by\n    inspecting the stack frames. This will be used to 
detect the\n    version, so it must match the name of the installed package.\n\n    
:param version: The version number to show. If not provided, Click\n        will try 
to detect it.\n    :param param_decls: One or more option names. Defaults to the 
single\n        value ``\"--version\"``.\n    :param package_name: The package name to
detect the version from. If\n        not provided, Click will try to detect it.\n    
:param prog_name: The name of the CLI to show in the message. If not\n        
provided, it will be detected from the command.\n    :param message: The message to 
show. The values ``%(prog)s``,\n        ``%(package)s``, and ``%(version)s`` are 
available. Defaults to\n        ``\"%(prog)s, version %(version)s\"``.\n    :param 
kwargs: Extra arguments are passed to :func:`option`.\n    :raise RuntimeError: 
``version`` could not be detected.\n\n    .. versionchanged:: 8.0\n        Add the 
``package_name`` parameter, and the ``%(package)s``\n        value for messages.\n\n  
.. versionchanged:: 8.0\n        Use :mod:`importlib.metadata` instead of 
``pkg_resources``. The\n        version is detected based on the package name, not the
entry\n        point name. The Python package name must match the installed\n        
package name, or be passed with ``package_name=``.\n    \"\"\"\n    if message is 
None:\n        message = _(\"%(prog)s, version %(version)s\")\n\n    if version is 
None and package_name is None:\n        frame = inspect.currentframe()\n        f_back
= frame.f_back if frame is not None else None\n        f_globals = f_back.f_globals if
f_back is not None else None\n        # break reference cycle\n        # 
https://docs.python.org/3/library/inspect.html#the-interpreter-stack\n        del 
frame\n\n        if f_globals is not None:\n            package_name = 
f_globals.get(\"__name__\")\n\n            if package_name == \"__main__\":\n         
package_name = f_globals.get(\"__package__\")\n\n            if package_name:\n       
package_name = package_name.partition(\".\")[0]\n\n    def callback(ctx: Context, 
param: Parameter, value: bool) -> None:\n        if not value or 
ctx.resilient_parsing:\n            return\n\n        nonlocal prog_name\n        
nonlocal version\n\n        if prog_name is None:\n            prog_name = 
ctx.find_root().info_name\n\n        if version is None and package_name is not 
None:\n            import importlib.metadata\n\n            try:\n                
version = importlib.metadata.version(package_name)\n            except 
importlib.metadata.PackageNotFoundError:\n                raise RuntimeError(\n       
f\"{package_name!r} is not installed. Try passing\"\n                    \" 
'package_name' instead.\"\n                ) from None\n\n        if version is 
None:\n            raise RuntimeError(\n                f\"Could not determine the 
version for {package_name!r} automatically.\"\n            )\n\n        echo(\n       
message % {\"prog\": prog_name, \"package\": package_name, \"version\": version},\n   
color=ctx.color,\n        )\n        ctx.exit()\n\n    if not param_decls:\n        
param_decls = (\"--version\",)\n\n    kwargs.setdefault(\"is_flag\", True)\n    
kwargs.setdefault(\"expose_value\", False)\n    kwargs.setdefault(\"is_eager\", 
True)\n    kwargs.setdefault(\"help\", _(\"Show the version and exit.\"))\n    
kwargs[\"callback\"] = callback\n    return option(*param_decls, **kwargs)"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 484, "end_line": 514, "size": 31, 
"parent_context": "function_definition", "content": "def callback(ctx: Context, param:
Parameter, value: bool) -> None:\n        if not value or ctx.resilient_parsing:\n    
return\n\n        nonlocal prog_name\n        nonlocal version\n\n        if prog_name
is None:\n            prog_name = ctx.find_root().info_name\n\n        if version is 
None and package_name is not None:\n            import importlib.metadata\n\n         
try:\n                version = importlib.metadata.version(package_name)\n            
except importlib.metadata.PackageNotFoundError:\n                raise RuntimeError(\n
f\"{package_name!r} is not installed. Try passing\"\n                    \" 
'package_name' instead.\"\n                ) from None\n\n        if version is 
None:\n            raise RuntimeError(\n                f\"Could not determine the 
version for {package_name!r} automatically.\"\n            )\n\n        echo(\n       
message % {\"prog\": prog_name, \"package\": package_name, \"version\": version},\n   
color=ctx.color,\n        )\n        ctx.exit()"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 527, "end_line": 551, "size": 25, 
"parent_context": "", "content": "def help_option(*param_decls: str, **kwargs: t.Any) 
-> t.Callable[[FC], FC]:\n    \"\"\"Pre-configured ``--help`` option which immediately
prints the help page\n    and exits the program.\n\n    :param param_decls: One or 
more option names. Defaults to the single\n        value ``\"--help\"``.\n    :param 
kwargs: Extra arguments are passed to :func:`option`.\n    \"\"\"\n\n    def 
show_help(ctx: Context, param: Parameter, value: bool) -> None:\n        
\"\"\"Callback that print the help page on ``<stdout>`` and exits.\"\"\"\n        if 
value and not ctx.resilient_parsing:\n            echo(ctx.get_help(), 
color=ctx.color)\n            ctx.exit()\n\n    if not param_decls:\n        
param_decls = (\"--help\",)\n\n    kwargs.setdefault(\"is_flag\", True)\n    
kwargs.setdefault(\"expose_value\", False)\n    kwargs.setdefault(\"is_eager\", 
True)\n    kwargs.setdefault(\"help\", _(\"Show this message and exit.\"))\n    
kwargs.setdefault(\"callback\", show_help)\n\n    return option(*param_decls, 
**kwargs)"}
{"file": "click/src/click/decorators.py", "language": "python", "node_type": 
"function_definition", "start_line": 536, "end_line": 540, "size": 5, 
"parent_context": "function_definition", "content": "def show_help(ctx: Context, 
param: Parameter, value: bool) -> None:\n        \"\"\"Callback that print the help 
page on ``<stdout>`` and exits.\"\"\"\n        if value and not 
ctx.resilient_parsing:\n            echo(ctx.get_help(), color=ctx.color)\n           
ctx.exit()"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 19, "end_line": 54, "size": 36, "parent_context":
"", "content": "def shell_complete(\n    cli: Command,\n    ctx_args: 
cabc.MutableMapping,\n    prog_name: str,\n    complete_var: str,\n    instruction: 
str,\n) -> int:\n    \"\"\"Perform shell completion for the given CLI program.\n\n    
:param cli: Command being called.\n    :param ctx_args: Extra arguments to pass to\n  
``cli.make_context``.\n    :param prog_name: Name of the executable in the shell.\n   
:param complete_var: Name of the environment variable that holds\n        the 
completion instruction.\n    :param instruction: Value of ``complete_var`` with the 
completion\n        instruction and shell, in the form ``instruction_shell``.\n    
:return: Status code to exit with.\n    \"\"\"\n    shell, _, instruction = 
instruction.partition(\"_\")\n    comp_cls = get_completion_class(shell)\n\n    if 
comp_cls is None:\n        return 1\n\n    comp = comp_cls(cli, ctx_args, prog_name, 
complete_var)\n\n    if instruction == \"source\":\n        echo(comp.source())\n     
return 0\n\n    if instruction == \"complete\":\n        echo(comp.complete())\n      
return 0\n\n    return 1"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"class_definition", "start_line": 57, "end_line": 91, "size": 35, "parent_context": 
"", "content": "class CompletionItem:\n    \"\"\"Represents a completion value and 
metadata about the value. The\n    default metadata is ``type`` to indicate special 
shell handling,\n    and ``help`` if a shell supports showing a help string next to 
the\n    value.\n\n    Arbitrary parameters can be passed when creating the object, 
and\n    accessed using ``item.attr``. If an attribute wasn't passed,\n    accessing 
it returns ``None``.\n\n    :param value: The completion suggestion.\n    :param type:
Tells the shell script to provide special completion\n        support for the type. 
Click uses ``\"dir\"`` and ``\"file\"``.\n    :param help: String shown next to the 
value if supported.\n    :param kwargs: Arbitrary metadata. The built-in 
implementations\n        don't use this, but custom type completions paired with 
custom\n        shell support could use it.\n    \"\"\"\n\n    __slots__ = (\"value\",
\"type\", \"help\", \"_info\")\n\n    def __init__(\n        self,\n        value: 
t.Any,\n        type: str = \"plain\",\n        help: str | None = None,\n        
**kwargs: t.Any,\n    ) -> None:\n        self.value: t.Any = value\n        
self.type: str = type\n        self.help: str | None = help\n        self._info = 
kwargs\n\n    def __getattr__(self, name: str) -> t.Any:\n        return 
self._info.get(name)"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 78, "end_line": 88, "size": 11, "parent_context":
"class_definition", "content": "def __init__(\n        self,\n        value: t.Any,\n 
type: str = \"plain\",\n        help: str | None = None,\n        **kwargs: t.Any,\n  
) -> None:\n        self.value: t.Any = value\n        self.type: str = type\n        
self.help: str | None = help\n        self._info = kwargs"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 90, "end_line": 91, "size": 2, "parent_context": 
"class_definition", "content": "def __getattr__(self, name: str) -> t.Any:\n        
return self._info.get(name)"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"class_definition", "start_line": 200, "end_line": 301, "size": 102, "parent_context":
"", "content": "class ShellComplete:\n    \"\"\"Base class for providing shell 
completion support. A subclass for\n    a given shell will override attributes and 
methods to implement the\n    completion instructions (``source`` and 
``complete``).\n\n    :param cli: Command being called.\n    :param prog_name: Name of
the executable in the shell.\n    :param complete_var: Name of the environment 
variable that holds\n        the completion instruction.\n\n    .. versionadded:: 
8.0\n    \"\"\"\n\n    name: t.ClassVar\n    \"\"\"Name to register the shell as with 
:func:`add_completion_class`.\n    This is used in completion instructions 
(``{name}_source`` and\n    ``{name}_complete``).\n    \"\"\"\n\n    source_template: 
t.ClassVar\n    \"\"\"Completion script template formatted by :meth:`source`. This 
must\n    be provided by subclasses.\n    \"\"\"\n\n    def __init__(\n        self,\n
cli: Command,\n        ctx_args: cabc.MutableMapping,\n        prog_name: str,\n      
complete_var: str,\n    ) -> None:\n        self.cli = cli\n        self.ctx_args = 
ctx_args\n        self.prog_name = prog_name\n        self.complete_var = 
complete_var\n\n    @property\n    def func_name(self) -> str:\n        \"\"\"The name
of the shell function defined by the completion\n        script.\n        \"\"\"\n    
safe_name = re.sub(r\"\\W*\", \"\", self.prog_name.replace(\"-\", \"_\"), 
flags=re.ASCII)\n        return f\"_{safe_name}_completion\"\n\n    def 
source_vars(self) -> dict:\n        \"\"\"Vars for formatting 
:attr:`source_template`.\n\n        By default this provides ``complete_func``, 
``complete_var``,\n        and ``prog_name``.\n        \"\"\"\n        return {\n     
\"complete_func\": self.func_name,\n            \"complete_var\": self.complete_var,\n
\"prog_name\": self.prog_name,\n        }\n\n    def source(self) -> str:\n        
\"\"\"Produce the shell script that defines the completion\n        function. By 
default this ``%``-style formats\n        :attr:`source_template` with the dict 
returned by\n        :meth:`source_vars`.\n        \"\"\"\n        return 
self.source_template % self.source_vars()\n\n    def get_completion_args(self) -> 
tuple[list, str]:\n        \"\"\"Use the env vars defined by the shell script to 
return a\n        tuple of ``args, incomplete``. This must be implemented by\n        
subclasses.\n        \"\"\"\n        raise NotImplementedError\n\n    def 
get_completions(self, args: list, incomplete: str) -> list[CompletionItem]:\n        
\"\"\"Determine the context and last complete command or parameter\n        from the 
complete args. Call that object's ``shell_complete``\n        method to get the 
completions for the incomplete value.\n\n        :param args: List of complete args 
before the incomplete value.\n        :param incomplete: Value being completed. May be
empty.\n        \"\"\"\n        ctx = _resolve_context(self.cli, self.ctx_args, 
self.prog_name, args)\n        obj, incomplete = _resolve_incomplete(ctx, args, 
incomplete)\n        return obj.shell_complete(ctx, incomplete)\n\n    def 
format_completion(self, item: CompletionItem) -> str:\n        \"\"\"Format a 
completion item into the form recognized by the\n        shell script. This must be 
implemented by subclasses.\n\n        :param item: Completion item to format.\n       
\"\"\"\n        raise NotImplementedError\n\n    def complete(self) -> str:\n        
\"\"\"Produce the completion data to send back to the shell.\n\n        By default 
this calls :meth:`get_completion_args`, gets the\n        completions, then calls 
:meth:`format_completion` for each\n        completion.\n        \"\"\"\n        args,
incomplete = self.get_completion_args()\n        completions = 
self.get_completions(args, incomplete)\n        out = \n        return 
\"\\n\".join(out)"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 224, "end_line": 234, "size": 11, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
cli: Command,\n        ctx_args: cabc.MutableMapping,\n        prog_name: str,\n      
complete_var: str,\n    ) -> None:\n        self.cli = cli\n        self.ctx_args = 
ctx_args\n        self.prog_name = prog_name\n        self.complete_var = 
complete_var"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 236, "end_line": 242, "size": 7, 
"parent_context": "class_definition", "content": "@property\n    def func_name(self) 
-> str:\n        \"\"\"The name of the shell function defined by the completion\n     
script.\n        \"\"\"\n        safe_name = re.sub(r\"\\W*\", \"\", 
self.prog_name.replace(\"-\", \"_\"), flags=re.ASCII)\n        return 
f\"_{safe_name}_completion\""}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 237, "end_line": 242, "size": 6, 
"parent_context": "decorated_definition", "content": "def func_name(self) -> str:\n   
\"\"\"The name of the shell function defined by the completion\n        script.\n     
\"\"\"\n        safe_name = re.sub(r\"\\W*\", \"\", self.prog_name.replace(\"-\", 
\"_\"), flags=re.ASCII)\n        return f\"_{safe_name}_completion\""}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 244, "end_line": 254, "size": 11, 
"parent_context": "class_definition", "content": "def source_vars(self) -> dict:\n    
\"\"\"Vars for formatting :attr:`source_template`.\n\n        By default this provides
``complete_func``, ``complete_var``,\n        and ``prog_name``.\n        \"\"\"\n    
return {\n            \"complete_func\": self.func_name,\n            
\"complete_var\": self.complete_var,\n            \"prog_name\": self.prog_name,\n    
}"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 256, "end_line": 262, "size": 7, 
"parent_context": "class_definition", "content": "def source(self) -> str:\n        
\"\"\"Produce the shell script that defines the completion\n        function. By 
default this ``%``-style formats\n        :attr:`source_template` with the dict 
returned by\n        :meth:`source_vars`.\n        \"\"\"\n        return 
self.source_template % self.source_vars()"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 264, "end_line": 269, "size": 6, 
"parent_context": "class_definition", "content": "def get_completion_args(self) -> 
tuple[list, str]:\n        \"\"\"Use the env vars defined by the shell script to 
return a\n        tuple of ``args, incomplete``. This must be implemented by\n        
subclasses.\n        \"\"\"\n        raise NotImplementedError"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 271, "end_line": 281, "size": 11, 
"parent_context": "class_definition", "content": "def get_completions(self, args: 
list, incomplete: str) -> list[CompletionItem]:\n        \"\"\"Determine the context 
and last complete command or parameter\n        from the complete args. Call that 
object's ``shell_complete``\n        method to get the completions for the incomplete 
value.\n\n        :param args: List of complete args before the incomplete value.\n   
:param incomplete: Value being completed. May be empty.\n        \"\"\"\n        ctx =
_resolve_context(self.cli, self.ctx_args, self.prog_name, args)\n        obj, 
incomplete = _resolve_incomplete(ctx, args, incomplete)\n        return 
obj.shell_complete(ctx, incomplete)"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 283, "end_line": 289, "size": 7, 
"parent_context": "class_definition", "content": "def format_completion(self, item: 
CompletionItem) -> str:\n        \"\"\"Format a completion item into the form 
recognized by the\n        shell script. This must be implemented by subclasses.\n\n  
:param item: Completion item to format.\n        \"\"\"\n        raise 
NotImplementedError"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 291, "end_line": 301, "size": 11, 
"parent_context": "class_definition", "content": "def complete(self) -> str:\n        
\"\"\"Produce the completion data to send back to the shell.\n\n        By default 
this calls :meth:`get_completion_args`, gets the\n        completions, then calls 
:meth:`format_completion` for each\n        completion.\n        \"\"\"\n        args,
incomplete = self.get_completion_args()\n        completions = 
self.get_completions(args, incomplete)\n        out = \n        return 
\"\\n\".join(out)"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"class_definition", "start_line": 304, "end_line": 360, "size": 57, "parent_context": 
"", "content": "class BashComplete(ShellComplete):\n    \"\"\"Shell completion for 
Bash.\"\"\"\n\n    name = \"bash\"\n    source_template = _SOURCE_BASH\n\n    
@staticmethod\n    def _check_version() -> None:\n        import shutil\n        
import subprocess\n\n        bash_exe = shutil.which(\"bash\")\n\n        if bash_exe 
is None:\n            match = None\n        else:\n            output = 
subprocess.run(\n                ,\n                stdout=subprocess.PIPE,\n         
)\n            match = re.search(r\"^(\\d+)\\.(\\d+)\\.\\d+\", 
output.stdout.decode())\n\n        if match is not None:\n            major, minor = 
match.groups()\n\n            if major < \"4\" or major == \"4\" and minor < \"4\":\n 
echo(\n                    _(\n                        \"Shell completion is not 
supported for Bash\"\n                        \" versions older than 4.4.\"\n         
),\n                    err=True,\n                )\n        else:\n            
echo(\n                _(\"Couldn't detect Bash version, shell completion is not 
supported.\"),\n                err=True,\n            )\n\n    def source(self) -> 
str:\n        self._check_version()\n        return super().source()\n\n    def 
get_completion_args(self) -> tuple[list, str]:\n        cwords = 
split_arg_string(os.environ[\"COMP_WORDS\"])\n        cword = 
int(os.environ[\"COMP_CWORD\"])\n        args = cwords[1:cword]\n\n        try:\n     
incomplete = cwords\n        except IndexError:\n            incomplete = \"\"\n\n    
return args, incomplete\n\n    def format_completion(self, item: CompletionItem) -> 
str:\n        return f\"{item.type},{item.value}\""}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 310, "end_line": 341, "size": 32, 
"parent_context": "class_definition", "content": "@staticmethod\n    def 
_check_version() -> None:\n        import shutil\n        import subprocess\n\n       
bash_exe = shutil.which(\"bash\")\n\n        if bash_exe is None:\n            match =
None\n        else:\n            output = subprocess.run(\n                ,\n        
stdout=subprocess.PIPE,\n            )\n            match = 
re.search(r\"^(\\d+)\\.(\\d+)\\.\\d+\", output.stdout.decode())\n\n        if match is
not None:\n            major, minor = match.groups()\n\n            if major < \"4\" 
or major == \"4\" and minor < \"4\":\n                echo(\n                    _(\n 
\"Shell completion is not supported for Bash\"\n                        \" versions 
older than 4.4.\"\n                    ),\n                    err=True,\n            
)\n        else:\n            echo(\n                _(\"Couldn't detect Bash version,
shell completion is not supported.\"),\n                err=True,\n            )"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 311, "end_line": 341, "size": 31, 
"parent_context": "decorated_definition", "content": "def _check_version() -> None:\n 
import shutil\n        import subprocess\n\n        bash_exe = 
shutil.which(\"bash\")\n\n        if bash_exe is None:\n            match = None\n    
else:\n            output = subprocess.run(\n                ,\n                
stdout=subprocess.PIPE,\n            )\n            match = 
re.search(r\"^(\\d+)\\.(\\d+)\\.\\d+\", output.stdout.decode())\n\n        if match is
not None:\n            major, minor = match.groups()\n\n            if major < \"4\" 
or major == \"4\" and minor < \"4\":\n                echo(\n                    _(\n 
\"Shell completion is not supported for Bash\"\n                        \" versions 
older than 4.4.\"\n                    ),\n                    err=True,\n            
)\n        else:\n            echo(\n                _(\"Couldn't detect Bash version,
shell completion is not supported.\"),\n                err=True,\n            )"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 343, "end_line": 345, "size": 3, 
"parent_context": "class_definition", "content": "def source(self) -> str:\n        
self._check_version()\n        return super().source()"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 347, "end_line": 357, "size": 11, 
"parent_context": "class_definition", "content": "def get_completion_args(self) -> 
tuple[list, str]:\n        cwords = split_arg_string(os.environ[\"COMP_WORDS\"])\n    
cword = int(os.environ[\"COMP_CWORD\"])\n        args = cwords[1:cword]\n\n        
try:\n            incomplete = cwords\n        except IndexError:\n            
incomplete = \"\"\n\n        return args, incomplete"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 359, "end_line": 360, "size": 2, 
"parent_context": "class_definition", "content": "def format_completion(self, item: 
CompletionItem) -> str:\n        return f\"{item.type},{item.value}\""}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"class_definition", "start_line": 363, "end_line": 396, "size": 34, "parent_context": 
"", "content": "class ZshComplete(ShellComplete):\n    \"\"\"Shell completion for 
Zsh.\"\"\"\n\n    name = \"zsh\"\n    source_template = _SOURCE_ZSH\n\n    def 
get_completion_args(self) -> tuple[list, str]:\n        cwords = 
split_arg_string(os.environ[\"COMP_WORDS\"])\n        cword = 
int(os.environ[\"COMP_CWORD\"])\n        args = cwords[1:cword]\n\n        try:\n     
incomplete = cwords\n        except IndexError:\n            incomplete = \"\"\n\n    
return args, incomplete\n\n    def format_completion(self, item: CompletionItem) -> 
str:\n        help_ = item.help or \"_\"\n        # The zsh completion script uses 
`_describe` on items with help\n        # texts (which splits the item help from the 
item value at the\n        # first unescaped colon) and `compadd` on items without 
help\n        # text (which uses the item value as-is and does not support\n        # 
colon escaping).  So escape colons in the item value if and\n        # only if the 
item help is not the sentinel \"_\" value, as used\n        # by the completion 
script.\n        #\n        # (The zsh completion script is potentially widely 
deployed, and\n        # thus harder to fix than this method.)\n        #\n        # 
See issue #1812 and issue #2703 for further context.\n        value = 
item.value.replace(\":\", r\"\\:\") if help_ != \"_\" else item.value\n        return 
f\"{item.type}\\n{value}\\n{help_}\""}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 369, "end_line": 379, "size": 11, 
"parent_context": "class_definition", "content": "def get_completion_args(self) -> 
tuple[list, str]:\n        cwords = split_arg_string(os.environ[\"COMP_WORDS\"])\n    
cword = int(os.environ[\"COMP_CWORD\"])\n        args = cwords[1:cword]\n\n        
try:\n            incomplete = cwords\n        except IndexError:\n            
incomplete = \"\"\n\n        return args, incomplete"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 381, "end_line": 396, "size": 16, 
"parent_context": "class_definition", "content": "def format_completion(self, item: 
CompletionItem) -> str:\n        help_ = item.help or \"_\"\n        # The zsh 
completion script uses `_describe` on items with help\n        # texts (which splits 
the item help from the item value at the\n        # first unescaped colon) and 
`compadd` on items without help\n        # text (which uses the item value as-is and 
does not support\n        # colon escaping).  So escape colons in the item value if 
and\n        # only if the item help is not the sentinel \"_\" value, as used\n       
# by the completion script.\n        #\n        # (The zsh completion script is 
potentially widely deployed, and\n        # thus harder to fix than this method.)\n   
#\n        # See issue #1812 and issue #2703 for further context.\n        value = 
item.value.replace(\":\", r\"\\:\") if help_ != \"_\" else item.value\n        return 
f\"{item.type}\\n{value}\\n{help_}\""}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"class_definition", "start_line": 399, "end_line": 421, "size": 23, "parent_context": 
"", "content": "class FishComplete(ShellComplete):\n    \"\"\"Shell completion for 
Fish.\"\"\"\n\n    name = \"fish\"\n    source_template = _SOURCE_FISH\n\n    def 
get_completion_args(self) -> tuple[list, str]:\n        cwords = 
split_arg_string(os.environ[\"COMP_WORDS\"])\n        incomplete = 
os.environ[\"COMP_CWORD\"]\n        args = cwords[1:]\n\n        # Fish stores the 
partial word in both COMP_WORDS and\n        # COMP_CWORD, remove it from complete 
args.\n        if incomplete and args and args[-1] == incomplete:\n            
args.pop()\n\n        return args, incomplete\n\n    def format_completion(self, item:
CompletionItem) -> str:\n        if item.help:\n            return 
f\"{item.type},{item.value}\\t{item.help}\"\n\n        return 
f\"{item.type},{item.value}\""}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 405, "end_line": 415, "size": 11, 
"parent_context": "class_definition", "content": "def get_completion_args(self) -> 
tuple[list, str]:\n        cwords = split_arg_string(os.environ[\"COMP_WORDS\"])\n    
incomplete = os.environ[\"COMP_CWORD\"]\n        args = cwords[1:]\n\n        # Fish 
stores the partial word in both COMP_WORDS and\n        # COMP_CWORD, remove it from 
complete args.\n        if incomplete and args and args[-1] == incomplete:\n          
args.pop()\n\n        return args, incomplete"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 417, "end_line": 421, "size": 5, 
"parent_context": "class_definition", "content": "def format_completion(self, item: 
CompletionItem) -> str:\n        if item.help:\n            return 
f\"{item.type},{item.value}\\t{item.help}\"\n\n        return 
f\"{item.type},{item.value}\""}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 434, "end_line": 451, "size": 18, 
"parent_context": "", "content": "def add_completion_class(\n    cls: 
ShellCompleteType, name: str | None = None\n) -> ShellCompleteType:\n    
\"\"\"Register a :class:`ShellComplete` subclass under the given name.\n    The name 
will be provided by the completion instruction environment\n    variable during 
completion.\n\n    :param cls: The completion class that will handle completion for 
the\n        shell.\n    :param name: Name to register the class under. Defaults to 
the\n        class's ``name`` attribute.\n    \"\"\"\n    if name is None:\n        
name = cls.name\n\n    _available_shells = cls\n\n    return cls"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 454, "end_line": 461, "size": 8, 
"parent_context": "", "content": "def get_completion_class(shell: str) -> 
type[ShellComplete] | None:\n    \"\"\"Look up a registered :class:`ShellComplete` 
subclass by the name\n    provided by the completion instruction environment variable.
If the\n    name isn't registered, returns ``None``.\n\n    :param shell: Name the 
class is registered under.\n    \"\"\"\n    return _available_shells.get(shell)"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 464, "end_line": 498, "size": 35, 
"parent_context": "", "content": "def split_arg_string(string: str) -> list:\n    
\"\"\"Split an argument string as with :func:`shlex.split`, but don't\n    fail if the
string is incomplete. Ignores a missing closing quote or\n    incomplete escape 
sequence and uses the partial token as-is.\n\n    .. code-block:: python\n\n        
split_arg_string(\"example 'my file\")\n        [\"example\", \"my file\"]\n\n        
split_arg_string(\"example my\\\\\")\n        [\"example\", \"my\"]\n\n    :param 
string: String to split.\n\n    .. versionchanged:: 8.2\n        Moved to 
``shell_completion`` from ``parser``.\n    \"\"\"\n    import shlex\n\n    lex = 
shlex.shlex(string, posix=True)\n    lex.whitespace_split = True\n    lex.commenters =
\"\"\n    out = []\n\n    try:\n        for token in lex:\n            
out.append(token)\n    except ValueError:\n        # Raised when end-of-string is 
reached in an invalid state. Use\n        # the partial token as-is. The quote or 
escape character is in\n        # lex.state, not lex.token.\n        
out.append(lex.token)\n\n    return out"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 501, "end_line": 523, "size": 23, 
"parent_context": "", "content": "def _is_incomplete_argument(ctx: Context, param: 
Parameter) -> bool:\n    \"\"\"Determine if the given parameter is an argument that 
can still\n    accept values.\n\n    :param ctx: Invocation context for the command 
represented by the\n        parsed complete args.\n    :param param: Argument object 
being checked.\n    \"\"\"\n    if not isinstance(param, Argument):\n        return 
False\n\n    assert param.name is not None\n    # Will be None if expose_value is 
False.\n    value = ctx.params.get(param.name)\n    return (\n        param.nargs == 
-1\n        or ctx.get_parameter_source(param.name) is not 
ParameterSource.COMMANDLINE\n        or (\n            param.nargs > 1\n            
and isinstance(value, (tuple, list))\n            and len(value) < param.nargs\n      
)\n    )"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 526, "end_line": 532, "size": 7, 
"parent_context": "", "content": "def _start_of_option(ctx: Context, value: str) -> 
bool:\n    \"\"\"Check if the value looks like the start of an option.\"\"\"\n    if 
not value:\n        return False\n\n    c = value[0]\n    return c in 
ctx._opt_prefixes"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 535, "end_line": 556, "size": 22, 
"parent_context": "", "content": "def _is_incomplete_option(ctx: Context, args: list, 
param: Parameter) -> bool:\n    \"\"\"Determine if the given parameter is an option 
that needs a value.\n\n    :param args: List of complete args before the incomplete 
value.\n    :param param: Option object being checked.\n    \"\"\"\n    if not 
isinstance(param, Option):\n        return False\n\n    if param.is_flag or 
param.count:\n        return False\n\n    last_option = None\n\n    for index, arg in 
enumerate(reversed(args)):\n        if index + 1 > param.nargs:\n            break\n\n
if _start_of_option(ctx, arg):\n            last_option = arg\n\n    return 
last_option is not None and last_option in param.opts"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 559, "end_line": 617, "size": 59, 
"parent_context": "", "content": "def _resolve_context(\n    cli: Command,\n    
ctx_args: cabc.MutableMapping,\n    prog_name: str,\n    args: list,\n) -> Context:\n 
\"\"\"Produce the context hierarchy starting with the command and\n    traversing the 
complete arguments. This only follows the commands,\n    it doesn't trigger input 
prompts or callbacks.\n\n    :param cli: Command being called.\n    :param prog_name: 
Name of the executable in the shell.\n    :param args: List of complete args before 
the incomplete value.\n    \"\"\"\n    ctx_args[\"resilient_parsing\"] = True\n    
with cli.make_context(prog_name, args.copy(), **ctx_args) as ctx:\n        args = 
ctx._protected_args + ctx.args\n\n        while args:\n            command = 
ctx.command\n\n            if isinstance(command, Group):\n                if not 
command.chain:\n                    name, cmd, args = command.resolve_command(ctx, 
args)\n\n                    if cmd is None:\n                        return ctx\n\n  
with cmd.make_context(\n                        name, args, parent=ctx, 
resilient_parsing=True\n                    ) as sub_ctx:\n                        ctx
= sub_ctx\n                        args = ctx._protected_args + ctx.args\n            
else:\n                    sub_ctx = ctx\n\n                    while args:\n         
name, cmd, args = command.resolve_command(ctx, args)\n\n                        if cmd
is None:\n                            return ctx\n\n                        with 
cmd.make_context(\n                            name,\n                            
args,\n                            parent=ctx,\n                            
allow_extra_args=True,\n                            allow_interspersed_args=False,\n  
resilient_parsing=True,\n                        ) as sub_sub_ctx:\n                  
sub_ctx = sub_sub_ctx\n                            args = sub_ctx.args\n\n            
ctx = sub_ctx\n                    args = [*sub_ctx._protected_args, *sub_ctx.args]\n 
else:\n                break\n\n    return ctx"}
{"file": "click/src/click/shell_completion.py", "language": "python", "node_type": 
"function_definition", "start_line": 620, "end_line": 664, "size": 45, 
"parent_context": "", "content": "def _resolve_incomplete(\n    ctx: Context, args: 
list, incomplete: str\n) -> tuple[Command | Parameter, str]:\n    \"\"\"Find the Click
object that will handle the completion of the\n    incomplete value. Return the object
and the incomplete value.\n\n    :param ctx: Invocation context for the command 
represented by\n        the parsed complete args.\n    :param args: List of complete 
args before the incomplete value.\n    :param incomplete: Value being completed. May 
be empty.\n    \"\"\"\n    # Different shells treat an \"=\" between a long option 
name and\n    # value differently. Might keep the value joined, return the \"=\"\n    
# as a separate item, or return the split name and value. Always\n    # split and 
discard the \"=\" to make completion easier.\n    if incomplete == \"=\":\n        
incomplete = \"\"\n    elif \"=\" in incomplete and _start_of_option(ctx, 
incomplete):\n        name, _, incomplete = incomplete.partition(\"=\")\n        
args.append(name)\n\n    # The \"--\" marker tells Click to stop treating values as 
options\n    # even if they start with the option character. If it hasn't been\n    # 
given and the incomplete arg looks like an option, the current\n    # command will 
provide option name completions.\n    if \"--\" not in args and _start_of_option(ctx, 
incomplete):\n        return ctx.command, incomplete\n\n    params = 
ctx.command.get_params(ctx)\n\n    # If the last complete arg is an option name with 
an incomplete\n    # value, the option will provide value completions.\n    for param 
in params:\n        if _is_incomplete_option(ctx, args, param):\n            return 
param, incomplete\n\n    # It's not an option name or value. The first argument 
without a\n    # parsed value will provide value completions.\n    for param in 
params:\n        if _is_incomplete_argument(ctx, param):\n            return param, 
incomplete\n\n    # There were no unparsed arguments, the command may be a group 
that\n    # will provide command name completions.\n    return ctx.command, 
incomplete"}
{"file": "click/src/click/globals.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 12, "end_line": 13, "size": 2, "parent_context":
"", "content": "@t.overload\ndef get_current_context(silent: t.Literal[False] = False)
-> Context: ..."}
{"file": "click/src/click/globals.py", "language": "python", "node_type": 
"function_definition", "start_line": 13, "end_line": 13, "size": 1, "parent_context": 
"decorated_definition", "content": "def get_current_context(silent: t.Literal[False] =
False) -> Context: ..."}
{"file": "click/src/click/globals.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 16, "end_line": 17, "size": 2, "parent_context":
"", "content": "@t.overload\ndef get_current_context(silent: bool = ...) -> Context | 
None: ..."}
{"file": "click/src/click/globals.py", "language": "python", "node_type": 
"function_definition", "start_line": 17, "end_line": 17, "size": 1, "parent_context": 
"decorated_definition", "content": "def get_current_context(silent: bool = ...) -> 
Context | None: ..."}
{"file": "click/src/click/globals.py", "language": "python", "node_type": 
"function_definition", "start_line": 20, "end_line": 41, "size": 22, "parent_context":
"", "content": "def get_current_context(silent: bool = False) -> Context | None:\n    
\"\"\"Returns the current click context.  This can be used as a way to\n    access the
current context object from anywhere.  This is a more implicit\n    alternative to the
:func:`pass_context` decorator.  This function is\n    primarily useful for helpers 
such as :func:`echo` which might be\n    interested in changing its behavior based on 
the current context.\n\n    To push the current context, :meth:`Context.scope` can be 
used.\n\n    .. versionadded:: 5.0\n\n    :param silent: if set to `True` the return 
value is `None` if no context\n                   is available.  The default behavior 
is to raise a\n                   :exc:`RuntimeError`.\n    \"\"\"\n    try:\n        
return t.cast(\"Context\", _local.stack[-1])\n    except (AttributeError, IndexError) 
as e:\n        if not silent:\n            raise RuntimeError(\"There is no active 
click context.\") from e\n\n    return None"}
{"file": "click/src/click/globals.py", "language": "python", "node_type": 
"function_definition", "start_line": 44, "end_line": 46, "size": 3, "parent_context": 
"", "content": "def push_context(ctx: Context) -> None:\n    \"\"\"Pushes a new 
context to the current stack.\"\"\"\n    _local.__dict__.setdefault(\"stack\", 
[]).append(ctx)"}
{"file": "click/src/click/globals.py", "language": "python", "node_type": 
"function_definition", "start_line": 49, "end_line": 51, "size": 3, "parent_context": 
"", "content": "def pop_context() -> None:\n    \"\"\"Removes the top level from the 
stack.\"\"\"\n    _local.stack.pop()"}
{"file": "click/src/click/globals.py", "language": "python", "node_type": 
"function_definition", "start_line": 54, "end_line": 67, "size": 14, "parent_context":
"", "content": "def resolve_color_default(color: bool | None = None) -> bool | None:\n
\"\"\"Internal helper to get the default value of the color flag.  If a\n    value is 
passed it's returned unchanged, otherwise it's looked up from\n    the current 
context.\n    \"\"\"\n    if color is not None:\n        return color\n\n    ctx = 
get_current_context(silent=True)\n\n    if ctx is not None:\n        return 
ctx.color\n\n    return None"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"class_definition", "start_line": 26, "end_line": 57, "size": 32, "parent_context": 
"", "content": "class EchoingStdin:\n    def __init__(self, input: t.BinaryIO, output:
t.BinaryIO) -> None:\n        self._input = input\n        self._output = output\n    
self._paused = False\n\n    def __getattr__(self, x: str) -> t.Any:\n        return 
getattr(self._input, x)\n\n    def _echo(self, rv: bytes) -> bytes:\n        if not 
self._paused:\n            self._output.write(rv)\n\n        return rv\n\n    def 
read(self, n: int = -1) -> bytes:\n        return self._echo(self._input.read(n))\n\n 
def read1(self, n: int = -1) -> bytes:\n        return 
self._echo(self._input.read1(n))  # type: ignore\n\n    def readline(self, n: int = 
-1) -> bytes:\n        return self._echo(self._input.readline(n))\n\n    def 
readlines(self) -> list:\n        return \n\n    def __iter__(self) -> 
cabc.Iterator:\n        return iter(self._echo(x) for x in self._input)\n\n    def 
__repr__(self) -> str:\n        return repr(self._input)"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 27, "end_line": 30, "size": 4, "parent_context": 
"class_definition", "content": "def __init__(self, input: t.BinaryIO, output: 
t.BinaryIO) -> None:\n        self._input = input\n        self._output = output\n    
self._paused = False"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 32, "end_line": 33, "size": 2, "parent_context": 
"class_definition", "content": "def __getattr__(self, x: str) -> t.Any:\n        
return getattr(self._input, x)"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 35, "end_line": 39, "size": 5, "parent_context": 
"class_definition", "content": "def _echo(self, rv: bytes) -> bytes:\n        if not 
self._paused:\n            self._output.write(rv)\n\n        return rv"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 41, "end_line": 42, "size": 2, "parent_context": 
"class_definition", "content": "def read(self, n: int = -1) -> bytes:\n        return 
self._echo(self._input.read(n))"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 44, "end_line": 45, "size": 2, "parent_context": 
"class_definition", "content": "def read1(self, n: int = -1) -> bytes:\n        return
self._echo(self._input.read1(n))  # type: ignore"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 47, "end_line": 48, "size": 2, "parent_context": 
"class_definition", "content": "def readline(self, n: int = -1) -> bytes:\n        
return self._echo(self._input.readline(n))"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 50, "end_line": 51, "size": 2, "parent_context": 
"class_definition", "content": "def readlines(self) -> list:\n        return "}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 53, "end_line": 54, "size": 2, "parent_context": 
"class_definition", "content": "def __iter__(self) -> cabc.Iterator:\n        return 
iter(self._echo(x) for x in self._input)"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 56, "end_line": 57, "size": 2, "parent_context": 
"class_definition", "content": "def __repr__(self) -> str:\n        return 
repr(self._input)"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 60, "end_line": 67, "size": 8, "parent_context":
"", "content": "@contextlib.contextmanager\ndef _pause_echo(stream: EchoingStdin | 
None) -> cabc.Iterator[None]:\n    if stream is None:\n        yield\n    else:\n     
stream._paused = True\n        yield\n        stream._paused = False"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 61, "end_line": 67, "size": 7, "parent_context": 
"decorated_definition", "content": "def _pause_echo(stream: EchoingStdin | None) -> 
cabc.Iterator[None]:\n    if stream is None:\n        yield\n    else:\n        
stream._paused = True\n        yield\n        stream._paused = False"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"class_definition", "start_line": 70, "end_line": 86, "size": 17, "parent_context": 
"", "content": "class BytesIOCopy(io.BytesIO):\n    \"\"\"Patch ``io.BytesIO`` to let 
the written stream be copied to another.\n\n    .. versionadded:: 8.2\n    \"\"\"\n\n 
def __init__(self, copy_to: io.BytesIO) -> None:\n        super().__init__()\n        
self.copy_to = copy_to\n\n    def flush(self) -> None:\n        super().flush()\n     
self.copy_to.flush()\n\n    def write(self, b: ReadableBuffer) -> int:\n        
self.copy_to.write(b)\n        return super().write(b)"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 76, "end_line": 78, "size": 3, "parent_context": 
"class_definition", "content": "def __init__(self, copy_to: io.BytesIO) -> None:\n    
super().__init__()\n        self.copy_to = copy_to"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 80, "end_line": 82, "size": 3, "parent_context": 
"class_definition", "content": "def flush(self) -> None:\n        super().flush()\n   
self.copy_to.flush()"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 84, "end_line": 86, "size": 3, "parent_context": 
"class_definition", "content": "def write(self, b: ReadableBuffer) -> int:\n        
self.copy_to.write(b)\n        return super().write(b)"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"class_definition", "start_line": 89, "end_line": 112, "size": 24, "parent_context": 
"", "content": "class StreamMixer:\n    \"\"\"Mixes `<stdout>` and `<stderr>` 
streams.\n\n    The result is available in the ``output`` attribute.\n\n    .. 
versionadded:: 8.2\n    \"\"\"\n\n    def __init__(self) -> None:\n        
self.output: io.BytesIO = io.BytesIO()\n        self.stdout: io.BytesIO = 
BytesIOCopy(copy_to=self.output)\n        self.stderr: io.BytesIO = 
BytesIOCopy(copy_to=self.output)\n\n    def __del__(self) -> None:\n        \"\"\"\n  
Guarantee that embedded file-like objects are closed in a\n        predictable order, 
protecting against races between\n        self.output being closed and other streams 
being flushed on close\n\n        .. versionadded:: 8.2.2\n        \"\"\"\n        
self.stderr.close()\n        self.stdout.close()\n        self.output.close()"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 97, "end_line": 100, "size": 4, "parent_context":
"class_definition", "content": "def __init__(self) -> None:\n        self.output: 
io.BytesIO = io.BytesIO()\n        self.stdout: io.BytesIO = 
BytesIOCopy(copy_to=self.output)\n        self.stderr: io.BytesIO = 
BytesIOCopy(copy_to=self.output)"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 102, "end_line": 112, "size": 11, 
"parent_context": "class_definition", "content": "def __del__(self) -> None:\n        
\"\"\"\n        Guarantee that embedded file-like objects are closed in a\n        
predictable order, protecting against races between\n        self.output being closed 
and other streams being flushed on close\n\n        .. versionadded:: 8.2.2\n        
\"\"\"\n        self.stderr.close()\n        self.stdout.close()\n        
self.output.close()"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"class_definition", "start_line": 115, "end_line": 136, "size": 22, "parent_context": 
"", "content": "class _NamedTextIOWrapper(io.TextIOWrapper):\n    def __init__(\n     
self, buffer: t.BinaryIO, name: str, mode: str, **kwargs: t.Any\n    ) -> None:\n     
super().__init__(buffer, **kwargs)\n        self._name = name\n        self._mode = 
mode\n\n    @property\n    def name(self) -> str:\n        return self._name\n\n    
@property\n    def mode(self) -> str:\n        return self._mode\n\n    def 
__next__(self) -> str:  # type: ignore\n        try:\n            line = 
super().__next__()\n        except StopIteration as e:\n            raise EOFError() 
from e\n        return line"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 116, "end_line": 121, "size": 6, 
"parent_context": "class_definition", "content": "def __init__(\n        self, buffer:
t.BinaryIO, name: str, mode: str, **kwargs: t.Any\n    ) -> None:\n        
super().__init__(buffer, **kwargs)\n        self._name = name\n        self._mode = 
mode"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 123, "end_line": 125, "size": 3, 
"parent_context": "class_definition", "content": "@property\n    def name(self) -> 
str:\n        return self._name"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 124, "end_line": 125, "size": 2, 
"parent_context": "decorated_definition", "content": "def name(self) -> str:\n        
return self._name"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 127, "end_line": 129, "size": 3, 
"parent_context": "class_definition", "content": "@property\n    def mode(self) -> 
str:\n        return self._mode"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 128, "end_line": 129, "size": 2, 
"parent_context": "decorated_definition", "content": "def mode(self) -> str:\n        
return self._mode"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 131, "end_line": 136, "size": 6, 
"parent_context": "class_definition", "content": "def __next__(self) -> str:  # type: 
ignore\n        try:\n            line = super().__next__()\n        except 
StopIteration as e:\n            raise EOFError() from e\n        return line"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 139, "end_line": 156, "size": 18, 
"parent_context": "", "content": "def make_input_stream(\n    input: str | bytes | 
t.IO | None, charset: str\n) -> t.BinaryIO:\n    # Is already an input stream.\n    if
hasattr(input, \"read\"):\n        rv = _find_binary_reader(t.cast(\"t.IO\", 
input))\n\n        if rv is not None:\n            return rv\n\n        raise 
TypeError(\"Could not find binary reader for input stream.\")\n\n    if input is 
None:\n        input = b\"\"\n    elif isinstance(input, str):\n        input = 
input.encode(charset)\n\n    return io.BytesIO(input)"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"class_definition", "start_line": 159, "end_line": 234, "size": 76, "parent_context": 
"", "content": "class Result:\n    \"\"\"Holds the captured result of an invoked CLI 
script.\n\n    :param runner: The runner that created the result\n    :param 
stdout_bytes: The standard output as bytes.\n    :param stderr_bytes: The standard 
error as bytes.\n    :param output_bytes: A mix of ``stdout_bytes`` and 
``stderr_bytes``, as the\n        user would see  it in its terminal.\n    :param 
return_value: The value returned from the invoked command.\n    :param exit_code: The 
exit code as integer.\n    :param exception: The exception that happened if one did.\n
:param exc_info: Exception information (exception type, exception instance,\n        
traceback type).\n\n    .. versionchanged:: 8.2\n        ``stderr_bytes`` no longer 
optional, ``output_bytes`` introduced and\n        ``mix_stderr`` has been 
removed.\n\n    .. versionadded:: 8.0\n        Added ``return_value``.\n    \"\"\"\n\n
def __init__(\n        self,\n        runner: CliRunner,\n        stdout_bytes: 
bytes,\n        stderr_bytes: bytes,\n        output_bytes: bytes,\n        
return_value: t.Any,\n        exit_code: int,\n        exception: BaseException | 
None,\n        exc_info: tuple[type[BaseException], BaseException, TracebackType]\n   
| None = None,\n    ):\n        self.runner = runner\n        self.stdout_bytes = 
stdout_bytes\n        self.stderr_bytes = stderr_bytes\n        self.output_bytes = 
output_bytes\n        self.return_value = return_value\n        self.exit_code = 
exit_code\n        self.exception = exception\n        self.exc_info = exc_info\n\n   
@property\n    def output(self) -> str:\n        \"\"\"The terminal output as unicode 
string, as the user would see it.\n\n        .. versionchanged:: 8.2\n            No 
longer a proxy for ``self.stdout``. Now has its own independent stream\n            
that is mixing `<stdout>` and `<stderr>`, in the order they were written.\n        
\"\"\"\n        return self.output_bytes.decode(self.runner.charset, 
\"replace\").replace(\n            \"\\r\\n\", \"\\n\"\n        )\n\n    @property\n  
def stdout(self) -> str:\n        \"\"\"The standard output as unicode string.\"\"\"\n
return self.stdout_bytes.decode(self.runner.charset, \"replace\").replace(\n          
\"\\r\\n\", \"\\n\"\n        )\n\n    @property\n    def stderr(self) -> str:\n       
\"\"\"The standard error as unicode string.\n\n        .. versionchanged:: 8.2\n      
No longer raise an exception, always returns the `<stderr>` string.\n        \"\"\"\n 
return self.stderr_bytes.decode(self.runner.charset, \"replace\").replace(\n          
\"\\r\\n\", \"\\n\"\n        )\n\n    def __repr__(self) -> str:\n        exc_str = 
repr(self.exception) if self.exception else \"okay\"\n        return 
f\"<{type(self).__name__} {exc_str}>\""}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 181, "end_line": 200, "size": 20, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
runner: CliRunner,\n        stdout_bytes: bytes,\n        stderr_bytes: bytes,\n      
output_bytes: bytes,\n        return_value: t.Any,\n        exit_code: int,\n        
exception: BaseException | None,\n        exc_info: tuple[type[BaseException], 
BaseException, TracebackType]\n        | None = None,\n    ):\n        self.runner = 
runner\n        self.stdout_bytes = stdout_bytes\n        self.stderr_bytes = 
stderr_bytes\n        self.output_bytes = output_bytes\n        self.return_value = 
return_value\n        self.exit_code = exit_code\n        self.exception = exception\n
self.exc_info = exc_info"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 202, "end_line": 212, "size": 11, 
"parent_context": "class_definition", "content": "@property\n    def output(self) -> 
str:\n        \"\"\"The terminal output as unicode string, as the user would see 
it.\n\n        .. versionchanged:: 8.2\n            No longer a proxy for 
``self.stdout``. Now has its own independent stream\n            that is mixing 
`<stdout>` and `<stderr>`, in the order they were written.\n        \"\"\"\n        
return self.output_bytes.decode(self.runner.charset, \"replace\").replace(\n          
\"\\r\\n\", \"\\n\"\n        )"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 203, "end_line": 212, "size": 10, 
"parent_context": "decorated_definition", "content": "def output(self) -> str:\n      
\"\"\"The terminal output as unicode string, as the user would see it.\n\n        .. 
versionchanged:: 8.2\n            No longer a proxy for ``self.stdout``. Now has its 
own independent stream\n            that is mixing `<stdout>` and `<stderr>`, in the 
order they were written.\n        \"\"\"\n        return 
self.output_bytes.decode(self.runner.charset, \"replace\").replace(\n            
\"\\r\\n\", \"\\n\"\n        )"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 214, "end_line": 219, "size": 6, 
"parent_context": "class_definition", "content": "@property\n    def stdout(self) -> 
str:\n        \"\"\"The standard output as unicode string.\"\"\"\n        return 
self.stdout_bytes.decode(self.runner.charset, \"replace\").replace(\n            
\"\\r\\n\", \"\\n\"\n        )"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 215, "end_line": 219, "size": 5, 
"parent_context": "decorated_definition", "content": "def stdout(self) -> str:\n      
\"\"\"The standard output as unicode string.\"\"\"\n        return 
self.stdout_bytes.decode(self.runner.charset, \"replace\").replace(\n            
\"\\r\\n\", \"\\n\"\n        )"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 221, "end_line": 230, "size": 10, 
"parent_context": "class_definition", "content": "@property\n    def stderr(self) -> 
str:\n        \"\"\"The standard error as unicode string.\n\n        .. 
versionchanged:: 8.2\n            No longer raise an exception, always returns the 
`<stderr>` string.\n        \"\"\"\n        return 
self.stderr_bytes.decode(self.runner.charset, \"replace\").replace(\n            
\"\\r\\n\", \"\\n\"\n        )"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 222, "end_line": 230, "size": 9, 
"parent_context": "decorated_definition", "content": "def stderr(self) -> str:\n      
\"\"\"The standard error as unicode string.\n\n        .. versionchanged:: 8.2\n      
No longer raise an exception, always returns the `<stderr>` string.\n        \"\"\"\n 
return self.stderr_bytes.decode(self.runner.charset, \"replace\").replace(\n          
\"\\r\\n\", \"\\n\"\n        )"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 232, "end_line": 234, "size": 3, 
"parent_context": "class_definition", "content": "def __repr__(self) -> str:\n        
exc_str = repr(self.exception) if self.exception else \"okay\"\n        return 
f\"<{type(self).__name__} {exc_str}>\""}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"class_definition", "start_line": 237, "end_line": 577, "size": 341, "parent_context":
"", "content": "class CliRunner:\n    \"\"\"The CLI runner provides functionality to 
invoke a Click command line\n    script for unittesting purposes in a isolated 
environment.  This only\n    works in single-threaded systems without any concurrency 
as it changes the\n    global interpreter state.\n\n    :param charset: the character 
set for the input and output data.\n    :param env: a dictionary with environment 
variables for overriding.\n    :param echo_stdin: if this is set to `True`, then 
reading from `<stdin>` writes\n                       to `<stdout>`.  This is useful 
for showing examples in\n                       some circumstances.  Note that regular
prompts\n                       will automatically echo the input.\n    :param 
catch_exceptions: Whether to catch any exceptions other than\n                        
``SystemExit`` when running :meth:`~CliRunner.invoke`.\n\n    .. versionchanged:: 
8.2\n        Added the ``catch_exceptions`` parameter.\n\n    .. versionchanged:: 
8.2\n        ``mix_stderr`` parameter has been removed.\n    \"\"\"\n\n    def 
__init__(\n        self,\n        charset: str = \"utf-8\",\n        env: cabc.Mapping
| None = None,\n        echo_stdin: bool = False,\n        catch_exceptions: bool = 
True,\n    ) -> None:\n        self.charset = charset\n        self.env: cabc.Mapping 
= env or {}\n        self.echo_stdin = echo_stdin\n        self.catch_exceptions = 
catch_exceptions\n\n    def get_default_prog_name(self, cli: Command) -> str:\n       
\"\"\"Given a command object it will return the default program name\n        for it. 
The default is the `name` attribute or ``\"root\"`` if not\n        set.\n        
\"\"\"\n        return cli.name or \"root\"\n\n    def make_env(\n        self, 
overrides: cabc.Mapping | None = None\n    ) -> cabc.Mapping:\n        \"\"\"Returns 
the environment overrides for invoking a script.\"\"\"\n        rv = dict(self.env)\n 
if overrides:\n            rv.update(overrides)\n        return rv\n\n    
@contextlib.contextmanager\n    def isolation(\n        self,\n        input: str | 
bytes | t.IO | None = None,\n        env: cabc.Mapping | None = None,\n        color: 
bool = False,\n    ) -> cabc.Iterator[tuple]:\n        \"\"\"A context manager that 
sets up the isolation for invoking of a\n        command line tool.  This sets up 
`<stdin>` with the given input data\n        and `os.environ` with the overrides from 
the given dictionary.\n        This also rebinds some internals in Click to be mocked 
(like the\n        prompt functionality).\n\n        This is automatically done in the
:meth:`invoke` method.\n\n        :param input: the input stream to put into 
`sys.stdin`.\n        :param env: the environment overrides as dictionary.\n        
:param color: whether the output should contain color codes. The\n                    
application can still override this explicitly.\n\n        .. versionadded:: 8.2\n    
An additional output stream is returned, which is a mix of\n            `<stdout>` and
`<stderr>` streams.\n\n        .. versionchanged:: 8.2\n            Always returns the
`<stderr>` stream.\n\n        .. versionchanged:: 8.0\n            `<stderr>` is 
opened with ``errors=\"backslashreplace\"``\n            instead of the default 
``\"strict\"``.\n\n        .. versionchanged:: 4.0\n            Added the ``color`` 
parameter.\n        \"\"\"\n        bytes_input = make_input_stream(input, 
self.charset)\n        echo_input = None\n\n        old_stdin = sys.stdin\n        
old_stdout = sys.stdout\n        old_stderr = sys.stderr\n        old_forced_width = 
formatting.FORCED_WIDTH\n        formatting.FORCED_WIDTH = 80\n\n        env = 
self.make_env(env)\n\n        stream_mixer = StreamMixer()\n\n        if 
self.echo_stdin:\n            bytes_input = echo_input = t.cast(\n                
t.BinaryIO, EchoingStdin(bytes_input, stream_mixer.stdout)\n            )\n\n        
sys.stdin = text_input = _NamedTextIOWrapper(\n            bytes_input, 
encoding=self.charset, name=\"<stdin>\", mode=\"r\"\n        )\n\n        if 
self.echo_stdin:\n            # Force unbuffered reads, otherwise TextIOWrapper reads 
a\n            # large chunk which is echoed early.\n            
text_input._CHUNK_SIZE = 1  # type: ignore\n\n        sys.stdout = 
_NamedTextIOWrapper(\n            stream_mixer.stdout, encoding=self.charset, 
name=\"<stdout>\", mode=\"w\"\n        )\n\n        sys.stderr = 
_NamedTextIOWrapper(\n            stream_mixer.stderr,\n            
encoding=self.charset,\n            name=\"<stderr>\",\n            mode=\"w\",\n     
errors=\"backslashreplace\",\n        )\n\n        @_pause_echo(echo_input)  # type: 
ignore\n        def visible_input(prompt: str | None = None) -> str:\n            
sys.stdout.write(prompt or \"\")\n            val = 
next(text_input).rstrip(\"\\r\\n\")\n            sys.stdout.write(f\"{val}\\n\")\n    
sys.stdout.flush()\n            return val\n\n        @_pause_echo(echo_input)  # 
type: ignore\n        def hidden_input(prompt: str | None = None) -> str:\n           
sys.stdout.write(f\"{prompt or ''}\\n\")\n            sys.stdout.flush()\n            
return next(text_input).rstrip(\"\\r\\n\")\n\n        @_pause_echo(echo_input)  # 
type: ignore\n        def _getchar(echo: bool) -> str:\n            char = 
sys.stdin.read(1)\n\n            if echo:\n                sys.stdout.write(char)\n\n 
sys.stdout.flush()\n            return char\n\n        default_color = color\n\n      
def should_strip_ansi(\n            stream: t.IO | None = None, color: bool | None = 
None\n        ) -> bool:\n            if color is None:\n                return not 
default_color\n            return not color\n\n        old_visible_prompt_func = 
termui.visible_prompt_func\n        old_hidden_prompt_func = 
termui.hidden_prompt_func\n        old__getchar_func = termui._getchar\n        
old_should_strip_ansi = utils.should_strip_ansi  # type: ignore\n        
old__compat_should_strip_ansi = _compat.should_strip_ansi\n        
termui.visible_prompt_func = visible_input\n        termui.hidden_prompt_func = 
hidden_input\n        termui._getchar = _getchar\n        utils.should_strip_ansi = 
should_strip_ansi  # type: ignore\n        _compat.should_strip_ansi = 
should_strip_ansi\n\n        old_env = {}\n        try:\n            for key, value in
env.items():\n                old_env = os.environ.get(key)\n                if value 
is None:\n                    try:\n                        del os.environ\n          
except Exception:\n                        pass\n                else:\n              
os.environ = value\n            yield (stream_mixer.stdout, stream_mixer.stderr, 
stream_mixer.output)\n        finally:\n            for key, value in 
old_env.items():\n                if value is None:\n                    try:\n       
del os.environ\n                    except Exception:\n                        pass\n 
else:\n                    os.environ = value\n            sys.stdout = old_stdout\n  
sys.stderr = old_stderr\n            sys.stdin = old_stdin\n            
termui.visible_prompt_func = old_visible_prompt_func\n            
termui.hidden_prompt_func = old_hidden_prompt_func\n            termui._getchar = 
old__getchar_func\n            utils.should_strip_ansi = old_should_strip_ansi  # 
type: ignore\n            _compat.should_strip_ansi = old__compat_should_strip_ansi\n 
formatting.FORCED_WIDTH = old_forced_width\n\n    def invoke(\n        self,\n        
cli: Command,\n        args: str | cabc.Sequence | None = None,\n        input: str | 
bytes | t.IO | None = None,\n        env: cabc.Mapping | None = None,\n        
catch_exceptions: bool | None = None,\n        color: bool = False,\n        **extra: 
t.Any,\n    ) -> Result:\n        \"\"\"Invokes a command in an isolated environment. 
The arguments are\n        forwarded directly to the command line script, the `extra` 
keyword\n        arguments are passed to the :meth:`~clickpkg.Command.main` function 
of\n        the command.\n\n        This returns a :class:`Result` object.\n\n        
:param cli: the command to invoke\n        :param args: the arguments to invoke. It 
may be given as an iterable\n                     or a string. When given as string it
will be interpreted\n                     as a Unix shell command. More details at\n  
:func:`shlex.split`.\n        :param input: the input data for `sys.stdin`.\n        
:param env: the environment overrides.\n        :param catch_exceptions: Whether to 
catch any other exceptions than\n                                 ``SystemExit``. If 
:data:`None`, the value\n                                 from :class:`CliRunner` is 
used.\n        :param extra: the keyword arguments to pass to :meth:`main`.\n        
:param color: whether the output should contain color codes. The\n                    
application can still override this explicitly.\n\n        .. versionadded:: 8.2\n    
The result object has the ``output_bytes`` attribute with\n            the mix of 
``stdout_bytes`` and ``stderr_bytes``, as the user would\n            see it in its 
terminal.\n\n        .. versionchanged:: 8.2\n            The result object always 
returns the ``stderr_bytes`` stream.\n\n        .. versionchanged:: 8.0\n            
The result object has the ``return_value`` attribute with\n            the value 
returned from the invoked command.\n\n        .. versionchanged:: 4.0\n            
Added the ``color`` parameter.\n\n        .. versionchanged:: 3.0\n            Added 
the ``catch_exceptions`` parameter.\n\n        .. versionchanged:: 3.0\n            
The result object has the ``exc_info`` attribute with the\n            traceback if 
available.\n        \"\"\"\n        exc_info = None\n        if catch_exceptions is 
None:\n            catch_exceptions = self.catch_exceptions\n\n        with 
self.isolation(input=input, env=env, color=color) as outstreams:\n            
return_value = None\n            exception: BaseException | None = None\n            
exit_code = 0\n\n            if isinstance(args, str):\n                args = 
shlex.split(args)\n\n            try:\n                prog_name = 
extra.pop(\"prog_name\")\n            except KeyError:\n                prog_name = 
self.get_default_prog_name(cli)\n\n            try:\n                return_value = 
cli.main(args=args or (), prog_name=prog_name, **extra)\n            except SystemExit
as e:\n                exc_info = sys.exc_info()\n                e_code = 
t.cast(\"int | t.Any | None\", e.code)\n\n                if e_code is None:\n        
e_code = 0\n\n                if e_code != 0:\n                    exception = e\n\n  
if not isinstance(e_code, int):\n                    sys.stdout.write(str(e_code))\n  
sys.stdout.write(\"\\n\")\n                    e_code = 1\n\n                exit_code
= e_code\n\n            except Exception as e:\n                if not 
catch_exceptions:\n                    raise\n                exception = e\n         
exit_code = 1\n                exc_info = sys.exc_info()\n            finally:\n      
sys.stdout.flush()\n                sys.stderr.flush()\n                stdout = 
outstreams[0].getvalue()\n                stderr = outstreams[1].getvalue()\n         
output = outstreams[2].getvalue()\n\n        return Result(\n            
runner=self,\n            stdout_bytes=stdout,\n            stderr_bytes=stderr,\n    
output_bytes=output,\n            return_value=return_value,\n            
exit_code=exit_code,\n            exception=exception,\n            exc_info=exc_info,
# type: ignore\n        )\n\n    @contextlib.contextmanager\n    def 
isolated_filesystem(\n        self, temp_dir: str | os.PathLike | None = None\n    ) 
-> cabc.Iterator:\n        \"\"\"A context manager that creates a temporary directory 
and\n        changes the current working directory to it. This isolates tests\n       
that affect the contents of the CWD to prevent them from\n        interfering with 
each other.\n\n        :param temp_dir: Create the temporary directory under this\n   
directory. If given, the created directory is not removed\n            when 
exiting.\n\n        .. versionchanged:: 8.0\n            Added the ``temp_dir`` 
parameter.\n        \"\"\"\n        cwd = os.getcwd()\n        dt = 
tempfile.mkdtemp(dir=temp_dir)\n        os.chdir(dt)\n\n        try:\n            
yield dt\n        finally:\n            os.chdir(cwd)\n\n            if temp_dir is 
None:\n                try:\n                    shutil.rmtree(dt)\n                
except OSError:\n                    pass"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 259, "end_line": 269, "size": 11, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
charset: str = \"utf-8\",\n        env: cabc.Mapping | None = None,\n        
echo_stdin: bool = False,\n        catch_exceptions: bool = True,\n    ) -> None:\n   
self.charset = charset\n        self.env: cabc.Mapping = env or {}\n        
self.echo_stdin = echo_stdin\n        self.catch_exceptions = catch_exceptions"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 271, "end_line": 276, "size": 6, 
"parent_context": "class_definition", "content": "def get_default_prog_name(self, cli:
Command) -> str:\n        \"\"\"Given a command object it will return the default 
program name\n        for it.  The default is the `name` attribute or ``\"root\"`` if 
not\n        set.\n        \"\"\"\n        return cli.name or \"root\""}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 278, "end_line": 285, "size": 8, 
"parent_context": "class_definition", "content": "def make_env(\n        self, 
overrides: cabc.Mapping | None = None\n    ) -> cabc.Mapping:\n        \"\"\"Returns 
the environment overrides for invoking a script.\"\"\"\n        rv = dict(self.env)\n 
if overrides:\n            rv.update(overrides)\n        return rv"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 287, "end_line": 433, "size": 147, 
"parent_context": "class_definition", "content": "@contextlib.contextmanager\n    def 
isolation(\n        self,\n        input: str | bytes | t.IO | None = None,\n        
env: cabc.Mapping | None = None,\n        color: bool = False,\n    ) -> 
cabc.Iterator[tuple]:\n        \"\"\"A context manager that sets up the isolation for 
invoking of a\n        command line tool.  This sets up `<stdin>` with the given input
data\n        and `os.environ` with the overrides from the given dictionary.\n        
This also rebinds some internals in Click to be mocked (like the\n        prompt 
functionality).\n\n        This is automatically done in the :meth:`invoke` 
method.\n\n        :param input: the input stream to put into `sys.stdin`.\n        
:param env: the environment overrides as dictionary.\n        :param color: whether 
the output should contain color codes. The\n                      application can 
still override this explicitly.\n\n        .. versionadded:: 8.2\n            An 
additional output stream is returned, which is a mix of\n            `<stdout>` and 
`<stderr>` streams.\n\n        .. versionchanged:: 8.2\n            Always returns the
`<stderr>` stream.\n\n        .. versionchanged:: 8.0\n            `<stderr>` is 
opened with ``errors=\"backslashreplace\"``\n            instead of the default 
``\"strict\"``.\n\n        .. versionchanged:: 4.0\n            Added the ``color`` 
parameter.\n        \"\"\"\n        bytes_input = make_input_stream(input, 
self.charset)\n        echo_input = None\n\n        old_stdin = sys.stdin\n        
old_stdout = sys.stdout\n        old_stderr = sys.stderr\n        old_forced_width = 
formatting.FORCED_WIDTH\n        formatting.FORCED_WIDTH = 80\n\n        env = 
self.make_env(env)\n\n        stream_mixer = StreamMixer()\n\n        if 
self.echo_stdin:\n            bytes_input = echo_input = t.cast(\n                
t.BinaryIO, EchoingStdin(bytes_input, stream_mixer.stdout)\n            )\n\n        
sys.stdin = text_input = _NamedTextIOWrapper(\n            bytes_input, 
encoding=self.charset, name=\"<stdin>\", mode=\"r\"\n        )\n\n        if 
self.echo_stdin:\n            # Force unbuffered reads, otherwise TextIOWrapper reads 
a\n            # large chunk which is echoed early.\n            
text_input._CHUNK_SIZE = 1  # type: ignore\n\n        sys.stdout = 
_NamedTextIOWrapper(\n            stream_mixer.stdout, encoding=self.charset, 
name=\"<stdout>\", mode=\"w\"\n        )\n\n        sys.stderr = 
_NamedTextIOWrapper(\n            stream_mixer.stderr,\n            
encoding=self.charset,\n            name=\"<stderr>\",\n            mode=\"w\",\n     
errors=\"backslashreplace\",\n        )\n\n        @_pause_echo(echo_input)  # type: 
ignore\n        def visible_input(prompt: str | None = None) -> str:\n            
sys.stdout.write(prompt or \"\")\n            val = 
next(text_input).rstrip(\"\\r\\n\")\n            sys.stdout.write(f\"{val}\\n\")\n    
sys.stdout.flush()\n            return val\n\n        @_pause_echo(echo_input)  # 
type: ignore\n        def hidden_input(prompt: str | None = None) -> str:\n           
sys.stdout.write(f\"{prompt or ''}\\n\")\n            sys.stdout.flush()\n            
return next(text_input).rstrip(\"\\r\\n\")\n\n        @_pause_echo(echo_input)  # 
type: ignore\n        def _getchar(echo: bool) -> str:\n            char = 
sys.stdin.read(1)\n\n            if echo:\n                sys.stdout.write(char)\n\n 
sys.stdout.flush()\n            return char\n\n        default_color = color\n\n      
def should_strip_ansi(\n            stream: t.IO | None = None, color: bool | None = 
None\n        ) -> bool:\n            if color is None:\n                return not 
default_color\n            return not color\n\n        old_visible_prompt_func = 
termui.visible_prompt_func\n        old_hidden_prompt_func = 
termui.hidden_prompt_func\n        old__getchar_func = termui._getchar\n        
old_should_strip_ansi = utils.should_strip_ansi  # type: ignore\n        
old__compat_should_strip_ansi = _compat.should_strip_ansi\n        
termui.visible_prompt_func = visible_input\n        termui.hidden_prompt_func = 
hidden_input\n        termui._getchar = _getchar\n        utils.should_strip_ansi = 
should_strip_ansi  # type: ignore\n        _compat.should_strip_ansi = 
should_strip_ansi\n\n        old_env = {}\n        try:\n            for key, value in
env.items():\n                old_env = os.environ.get(key)\n                if value 
is None:\n                    try:\n                        del os.environ\n          
except Exception:\n                        pass\n                else:\n              
os.environ = value\n            yield (stream_mixer.stdout, stream_mixer.stderr, 
stream_mixer.output)\n        finally:\n            for key, value in 
old_env.items():\n                if value is None:\n                    try:\n       
del os.environ\n                    except Exception:\n                        pass\n 
else:\n                    os.environ = value\n            sys.stdout = old_stdout\n  
sys.stderr = old_stderr\n            sys.stdin = old_stdin\n            
termui.visible_prompt_func = old_visible_prompt_func\n            
termui.hidden_prompt_func = old_hidden_prompt_func\n            termui._getchar = 
old__getchar_func\n            utils.should_strip_ansi = old_should_strip_ansi  # 
type: ignore\n            _compat.should_strip_ansi = old__compat_should_strip_ansi\n 
formatting.FORCED_WIDTH = old_forced_width"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 288, "end_line": 433, "size": 146, 
"parent_context": "decorated_definition", "content": "def isolation(\n        self,\n 
input: str | bytes | t.IO | None = None,\n        env: cabc.Mapping | None = None,\n  
color: bool = False,\n    ) -> cabc.Iterator[tuple]:\n        \"\"\"A context manager 
that sets up the isolation for invoking of a\n        command line tool.  This sets up
`<stdin>` with the given input data\n        and `os.environ` with the overrides from 
the given dictionary.\n        This also rebinds some internals in Click to be mocked 
(like the\n        prompt functionality).\n\n        This is automatically done in the
:meth:`invoke` method.\n\n        :param input: the input stream to put into 
`sys.stdin`.\n        :param env: the environment overrides as dictionary.\n        
:param color: whether the output should contain color codes. The\n                    
application can still override this explicitly.\n\n        .. versionadded:: 8.2\n    
An additional output stream is returned, which is a mix of\n            `<stdout>` and
`<stderr>` streams.\n\n        .. versionchanged:: 8.2\n            Always returns the
`<stderr>` stream.\n\n        .. versionchanged:: 8.0\n            `<stderr>` is 
opened with ``errors=\"backslashreplace\"``\n            instead of the default 
``\"strict\"``.\n\n        .. versionchanged:: 4.0\n            Added the ``color`` 
parameter.\n        \"\"\"\n        bytes_input = make_input_stream(input, 
self.charset)\n        echo_input = None\n\n        old_stdin = sys.stdin\n        
old_stdout = sys.stdout\n        old_stderr = sys.stderr\n        old_forced_width = 
formatting.FORCED_WIDTH\n        formatting.FORCED_WIDTH = 80\n\n        env = 
self.make_env(env)\n\n        stream_mixer = StreamMixer()\n\n        if 
self.echo_stdin:\n            bytes_input = echo_input = t.cast(\n                
t.BinaryIO, EchoingStdin(bytes_input, stream_mixer.stdout)\n            )\n\n        
sys.stdin = text_input = _NamedTextIOWrapper(\n            bytes_input, 
encoding=self.charset, name=\"<stdin>\", mode=\"r\"\n        )\n\n        if 
self.echo_stdin:\n            # Force unbuffered reads, otherwise TextIOWrapper reads 
a\n            # large chunk which is echoed early.\n            
text_input._CHUNK_SIZE = 1  # type: ignore\n\n        sys.stdout = 
_NamedTextIOWrapper(\n            stream_mixer.stdout, encoding=self.charset, 
name=\"<stdout>\", mode=\"w\"\n        )\n\n        sys.stderr = 
_NamedTextIOWrapper(\n            stream_mixer.stderr,\n            
encoding=self.charset,\n            name=\"<stderr>\",\n            mode=\"w\",\n     
errors=\"backslashreplace\",\n        )\n\n        @_pause_echo(echo_input)  # type: 
ignore\n        def visible_input(prompt: str | None = None) -> str:\n            
sys.stdout.write(prompt or \"\")\n            val = 
next(text_input).rstrip(\"\\r\\n\")\n            sys.stdout.write(f\"{val}\\n\")\n    
sys.stdout.flush()\n            return val\n\n        @_pause_echo(echo_input)  # 
type: ignore\n        def hidden_input(prompt: str | None = None) -> str:\n           
sys.stdout.write(f\"{prompt or ''}\\n\")\n            sys.stdout.flush()\n            
return next(text_input).rstrip(\"\\r\\n\")\n\n        @_pause_echo(echo_input)  # 
type: ignore\n        def _getchar(echo: bool) -> str:\n            char = 
sys.stdin.read(1)\n\n            if echo:\n                sys.stdout.write(char)\n\n 
sys.stdout.flush()\n            return char\n\n        default_color = color\n\n      
def should_strip_ansi(\n            stream: t.IO | None = None, color: bool | None = 
None\n        ) -> bool:\n            if color is None:\n                return not 
default_color\n            return not color\n\n        old_visible_prompt_func = 
termui.visible_prompt_func\n        old_hidden_prompt_func = 
termui.hidden_prompt_func\n        old__getchar_func = termui._getchar\n        
old_should_strip_ansi = utils.should_strip_ansi  # type: ignore\n        
old__compat_should_strip_ansi = _compat.should_strip_ansi\n        
termui.visible_prompt_func = visible_input\n        termui.hidden_prompt_func = 
hidden_input\n        termui._getchar = _getchar\n        utils.should_strip_ansi = 
should_strip_ansi  # type: ignore\n        _compat.should_strip_ansi = 
should_strip_ansi\n\n        old_env = {}\n        try:\n            for key, value in
env.items():\n                old_env = os.environ.get(key)\n                if value 
is None:\n                    try:\n                        del os.environ\n          
except Exception:\n                        pass\n                else:\n              
os.environ = value\n            yield (stream_mixer.stdout, stream_mixer.stderr, 
stream_mixer.output)\n        finally:\n            for key, value in 
old_env.items():\n                if value is None:\n                    try:\n       
del os.environ\n                    except Exception:\n                        pass\n 
else:\n                    os.environ = value\n            sys.stdout = old_stdout\n  
sys.stderr = old_stderr\n            sys.stdin = old_stdin\n            
termui.visible_prompt_func = old_visible_prompt_func\n            
termui.hidden_prompt_func = old_hidden_prompt_func\n            termui._getchar = 
old__getchar_func\n            utils.should_strip_ansi = old_should_strip_ansi  # 
type: ignore\n            _compat.should_strip_ansi = old__compat_should_strip_ansi\n 
formatting.FORCED_WIDTH = old_forced_width"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 360, "end_line": 366, "size": 7, 
"parent_context": "function_definition", "content": "@_pause_echo(echo_input)  # type:
ignore\n        def visible_input(prompt: str | None = None) -> str:\n            
sys.stdout.write(prompt or \"\")\n            val = 
next(text_input).rstrip(\"\\r\\n\")\n            sys.stdout.write(f\"{val}\\n\")\n    
sys.stdout.flush()\n            return val"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 361, "end_line": 366, "size": 6, 
"parent_context": "decorated_definition", "content": "def visible_input(prompt: str | 
None = None) -> str:\n            sys.stdout.write(prompt or \"\")\n            val = 
next(text_input).rstrip(\"\\r\\n\")\n            sys.stdout.write(f\"{val}\\n\")\n    
sys.stdout.flush()\n            return val"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 368, "end_line": 372, "size": 5, 
"parent_context": "function_definition", "content": "@_pause_echo(echo_input)  # type:
ignore\n        def hidden_input(prompt: str | None = None) -> str:\n            
sys.stdout.write(f\"{prompt or ''}\\n\")\n            sys.stdout.flush()\n            
return next(text_input).rstrip(\"\\r\\n\")"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 369, "end_line": 372, "size": 4, 
"parent_context": "decorated_definition", "content": "def hidden_input(prompt: str | 
None = None) -> str:\n            sys.stdout.write(f\"{prompt or ''}\\n\")\n          
sys.stdout.flush()\n            return next(text_input).rstrip(\"\\r\\n\")"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 374, "end_line": 382, "size": 9, 
"parent_context": "function_definition", "content": "@_pause_echo(echo_input)  # type:
ignore\n        def _getchar(echo: bool) -> str:\n            char = 
sys.stdin.read(1)\n\n            if echo:\n                sys.stdout.write(char)\n\n 
sys.stdout.flush()\n            return char"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 375, "end_line": 382, "size": 8, 
"parent_context": "decorated_definition", "content": "def _getchar(echo: bool) -> 
str:\n            char = sys.stdin.read(1)\n\n            if echo:\n                
sys.stdout.write(char)\n\n            sys.stdout.flush()\n            return char"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 386, "end_line": 391, "size": 6, 
"parent_context": "function_definition", "content": "def should_strip_ansi(\n         
stream: t.IO | None = None, color: bool | None = None\n        ) -> bool:\n           
if color is None:\n                return not default_color\n            return not 
color"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 435, "end_line": 546, "size": 112, 
"parent_context": "class_definition", "content": "def invoke(\n        self,\n        
cli: Command,\n        args: str | cabc.Sequence | None = None,\n        input: str | 
bytes | t.IO | None = None,\n        env: cabc.Mapping | None = None,\n        
catch_exceptions: bool | None = None,\n        color: bool = False,\n        **extra: 
t.Any,\n    ) -> Result:\n        \"\"\"Invokes a command in an isolated environment. 
The arguments are\n        forwarded directly to the command line script, the `extra` 
keyword\n        arguments are passed to the :meth:`~clickpkg.Command.main` function 
of\n        the command.\n\n        This returns a :class:`Result` object.\n\n        
:param cli: the command to invoke\n        :param args: the arguments to invoke. It 
may be given as an iterable\n                     or a string. When given as string it
will be interpreted\n                     as a Unix shell command. More details at\n  
:func:`shlex.split`.\n        :param input: the input data for `sys.stdin`.\n        
:param env: the environment overrides.\n        :param catch_exceptions: Whether to 
catch any other exceptions than\n                                 ``SystemExit``. If 
:data:`None`, the value\n                                 from :class:`CliRunner` is 
used.\n        :param extra: the keyword arguments to pass to :meth:`main`.\n        
:param color: whether the output should contain color codes. The\n                    
application can still override this explicitly.\n\n        .. versionadded:: 8.2\n    
The result object has the ``output_bytes`` attribute with\n            the mix of 
``stdout_bytes`` and ``stderr_bytes``, as the user would\n            see it in its 
terminal.\n\n        .. versionchanged:: 8.2\n            The result object always 
returns the ``stderr_bytes`` stream.\n\n        .. versionchanged:: 8.0\n            
The result object has the ``return_value`` attribute with\n            the value 
returned from the invoked command.\n\n        .. versionchanged:: 4.0\n            
Added the ``color`` parameter.\n\n        .. versionchanged:: 3.0\n            Added 
the ``catch_exceptions`` parameter.\n\n        .. versionchanged:: 3.0\n            
The result object has the ``exc_info`` attribute with the\n            traceback if 
available.\n        \"\"\"\n        exc_info = None\n        if catch_exceptions is 
None:\n            catch_exceptions = self.catch_exceptions\n\n        with 
self.isolation(input=input, env=env, color=color) as outstreams:\n            
return_value = None\n            exception: BaseException | None = None\n            
exit_code = 0\n\n            if isinstance(args, str):\n                args = 
shlex.split(args)\n\n            try:\n                prog_name = 
extra.pop(\"prog_name\")\n            except KeyError:\n                prog_name = 
self.get_default_prog_name(cli)\n\n            try:\n                return_value = 
cli.main(args=args or (), prog_name=prog_name, **extra)\n            except SystemExit
as e:\n                exc_info = sys.exc_info()\n                e_code = 
t.cast(\"int | t.Any | None\", e.code)\n\n                if e_code is None:\n        
e_code = 0\n\n                if e_code != 0:\n                    exception = e\n\n  
if not isinstance(e_code, int):\n                    sys.stdout.write(str(e_code))\n  
sys.stdout.write(\"\\n\")\n                    e_code = 1\n\n                exit_code
= e_code\n\n            except Exception as e:\n                if not 
catch_exceptions:\n                    raise\n                exception = e\n         
exit_code = 1\n                exc_info = sys.exc_info()\n            finally:\n      
sys.stdout.flush()\n                sys.stderr.flush()\n                stdout = 
outstreams[0].getvalue()\n                stderr = outstreams[1].getvalue()\n         
output = outstreams[2].getvalue()\n\n        return Result(\n            
runner=self,\n            stdout_bytes=stdout,\n            stderr_bytes=stderr,\n    
output_bytes=output,\n            return_value=return_value,\n            
exit_code=exit_code,\n            exception=exception,\n            exc_info=exc_info,
# type: ignore\n        )"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 548, "end_line": 577, "size": 30, 
"parent_context": "class_definition", "content": "@contextlib.contextmanager\n    def 
isolated_filesystem(\n        self, temp_dir: str | os.PathLike | None = None\n    ) 
-> cabc.Iterator:\n        \"\"\"A context manager that creates a temporary directory 
and\n        changes the current working directory to it. This isolates tests\n       
that affect the contents of the CWD to prevent them from\n        interfering with 
each other.\n\n        :param temp_dir: Create the temporary directory under this\n   
directory. If given, the created directory is not removed\n            when 
exiting.\n\n        .. versionchanged:: 8.0\n            Added the ``temp_dir`` 
parameter.\n        \"\"\"\n        cwd = os.getcwd()\n        dt = 
tempfile.mkdtemp(dir=temp_dir)\n        os.chdir(dt)\n\n        try:\n            
yield dt\n        finally:\n            os.chdir(cwd)\n\n            if temp_dir is 
None:\n                try:\n                    shutil.rmtree(dt)\n                
except OSError:\n                    pass"}
{"file": "click/src/click/testing.py", "language": "python", "node_type": 
"function_definition", "start_line": 549, "end_line": 577, "size": 29, 
"parent_context": "decorated_definition", "content": "def isolated_filesystem(\n      
self, temp_dir: str | os.PathLike | None = None\n    ) -> cabc.Iterator:\n        
\"\"\"A context manager that creates a temporary directory and\n        changes the 
current working directory to it. This isolates tests\n        that affect the contents
of the CWD to prevent them from\n        interfering with each other.\n\n        
:param temp_dir: Create the temporary directory under this\n            directory. If 
given, the created directory is not removed\n            when exiting.\n\n        .. 
versionchanged:: 8.0\n            Added the ``temp_dir`` parameter.\n        \"\"\"\n 
cwd = os.getcwd()\n        dt = tempfile.mkdtemp(dir=temp_dir)\n        
os.chdir(dt)\n\n        try:\n            yield dt\n        finally:\n            
os.chdir(cwd)\n\n            if temp_dir is None:\n                try:\n             
shutil.rmtree(dt)\n                except OSError:\n                    pass"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 32, "end_line": 33, "size": 2, "parent_context": 
"", "content": "def _posixify(name: str) -> str:\n    return 
\"-\".join(name.split()).lower()"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 36, "end_line": 46, "size": 11, "parent_context":
"", "content": "def safecall(func: t.Callable[P, R]) -> t.Callable[P, R | None]:\n    
\"\"\"Wraps a function so that it swallows exceptions.\"\"\"\n\n    def wrapper(*args:
P.args, **kwargs: P.kwargs) -> R | None:\n        try:\n            return func(*args,
**kwargs)\n        except Exception:\n            pass\n        return None\n\n    
return update_wrapper(wrapper, func)"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 39, "end_line": 44, "size": 6, "parent_context": 
"function_definition", "content": "def wrapper(*args: P.args, **kwargs: P.kwargs) -> R
| None:\n        try:\n            return func(*args, **kwargs)\n        except 
Exception:\n            pass\n        return None"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 49, "end_line": 56, "size": 8, "parent_context": 
"", "content": "def make_str(value: t.Any) -> str:\n    \"\"\"Converts a value into a 
valid string.\"\"\"\n    if isinstance(value, bytes):\n        try:\n            
return value.decode(sys.getfilesystemencoding())\n        except UnicodeError:\n      
return value.decode(\"utf-8\", \"replace\")\n    return str(value)"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 59, "end_line": 106, "size": 48, 
"parent_context": "", "content": "def make_default_short_help(help: str, max_length: 
int = 45) -> str:\n    \"\"\"Returns a condensed version of help string.\"\"\"\n    # 
Consider only the first paragraph.\n    paragraph_end = help.find(\"\\n\\n\")\n\n    
if paragraph_end != -1:\n        help = help[:paragraph_end]\n\n    # Collapse 
newlines, tabs, and spaces.\n    words = help.split()\n\n    if not words:\n        
return \"\"\n\n    # The first paragraph started with a \"no rewrap\" marker, ignore 
it.\n    if words[0] == \"\\b\":\n        words = words[1:]\n\n    total_length = 0\n 
last_index = len(words) - 1\n\n    for i, word in enumerate(words):\n        
total_length += len(word) + (i > 0)\n\n        if total_length > max_length:  # too 
long, truncate\n            break\n\n        if word[-1] == \".\":  # sentence end, 
truncate without \"...\"\n            return \" \".join(words[: i + 1])\n\n        if 
total_length == max_length and i != last_index:\n            break  # not at sentence 
end, truncate with \"...\"\n    else:\n        return \" \".join(words)  # no 
truncation needed\n\n    # Account for the length of the suffix.\n    total_length += 
len(\"...\")\n\n    # remove words until the length is short enough\n    while i > 
0:\n        total_length -= len(words) + (i > 0)\n\n        if total_length <= 
max_length:\n            break\n\n        i -= 1\n\n    return \" \".join(words[:i]) +
\"...\""}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"class_definition", "start_line": 109, "end_line": 194, "size": 86, "parent_context": 
"", "content": "class LazyFile:\n    \"\"\"A lazy file works like a regular file but 
it does not fully open\n    the file but it does perform some basic checks early to 
see if the\n    filename parameter does make sense.  This is useful for safely 
opening\n    files for writing.\n    \"\"\"\n\n    def __init__(\n        self,\n     
filename: str | os.PathLike,\n        mode: str = \"r\",\n        encoding: str | None
= None,\n        errors: str | None = \"strict\",\n        atomic: bool = False,\n    
):\n        self.name: str = os.fspath(filename)\n        self.mode = mode\n        
self.encoding = encoding\n        self.errors = errors\n        self.atomic = atomic\n
self._f: t.IO | None\n        self.should_close: bool\n\n        if self.name == 
\"-\":\n            self._f, self.should_close = open_stream(filename, mode, encoding,
errors)\n        else:\n            if \"r\" in mode:\n                # Open and 
close the file in case we're opening it for\n                # reading so that we can 
catch at least some errors in\n                # some cases early.\n                
open(filename, mode).close()\n            self._f = None\n            
self.should_close = True\n\n    def __getattr__(self, name: str) -> t.Any:\n        
return getattr(self.open(), name)\n\n    def __repr__(self) -> str:\n        if 
self._f is not None:\n            return repr(self._f)\n        return f\"<unopened 
file '{format_filename(self.name)}' {self.mode}>\"\n\n    def open(self) -> t.IO:\n   
\"\"\"Opens the file if it's not yet open.  This call might fail with\n        a 
:exc:`FileError`.  Not handling this error will produce an error\n        that Click 
shows.\n        \"\"\"\n        if self._f is not None:\n            return self._f\n 
try:\n            rv, self.should_close = open_stream(\n                self.name, 
self.mode, self.encoding, self.errors, atomic=self.atomic\n            )\n        
except OSError as e:\n            from .exceptions import FileError\n\n            
raise FileError(self.name, hint=e.strerror) from e\n        self._f = rv\n        
return rv\n\n    def close(self) -> None:\n        \"\"\"Closes the underlying file, 
no matter what.\"\"\"\n        if self._f is not None:\n            
self._f.close()\n\n    def close_intelligently(self) -> None:\n        \"\"\"This 
function only closes the file if it was opened by the lazy\n        file wrapper.  For
instance this will never close stdin.\n        \"\"\"\n        if self.should_close:\n
self.close()\n\n    def __enter__(self) -> LazyFile:\n        return self\n\n    def 
__exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        
exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n 
self.close_intelligently()\n\n    def __iter__(self) -> cabc.Iterator:\n        
self.open()\n        return iter(self._f)  # type: ignore"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 116, "end_line": 141, "size": 26, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
filename: str | os.PathLike,\n        mode: str = \"r\",\n        encoding: str | None
= None,\n        errors: str | None = \"strict\",\n        atomic: bool = False,\n    
):\n        self.name: str = os.fspath(filename)\n        self.mode = mode\n        
self.encoding = encoding\n        self.errors = errors\n        self.atomic = atomic\n
self._f: t.IO | None\n        self.should_close: bool\n\n        if self.name == 
\"-\":\n            self._f, self.should_close = open_stream(filename, mode, encoding,
errors)\n        else:\n            if \"r\" in mode:\n                # Open and 
close the file in case we're opening it for\n                # reading so that we can 
catch at least some errors in\n                # some cases early.\n                
open(filename, mode).close()\n            self._f = None\n            
self.should_close = True"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 143, "end_line": 144, "size": 2, 
"parent_context": "class_definition", "content": "def __getattr__(self, name: str) -> 
t.Any:\n        return getattr(self.open(), name)"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 146, "end_line": 149, "size": 4, 
"parent_context": "class_definition", "content": "def __repr__(self) -> str:\n        
if self._f is not None:\n            return repr(self._f)\n        return f\"<unopened
file '{format_filename(self.name)}' {self.mode}>\""}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 151, "end_line": 167, "size": 17, 
"parent_context": "class_definition", "content": "def open(self) -> t.IO:\n        
\"\"\"Opens the file if it's not yet open.  This call might fail with\n        a 
:exc:`FileError`.  Not handling this error will produce an error\n        that Click 
shows.\n        \"\"\"\n        if self._f is not None:\n            return self._f\n 
try:\n            rv, self.should_close = open_stream(\n                self.name, 
self.mode, self.encoding, self.errors, atomic=self.atomic\n            )\n        
except OSError as e:\n            from .exceptions import FileError\n\n            
raise FileError(self.name, hint=e.strerror) from e\n        self._f = rv\n        
return rv"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 169, "end_line": 172, "size": 4, 
"parent_context": "class_definition", "content": "def close(self) -> None:\n        
\"\"\"Closes the underlying file, no matter what.\"\"\"\n        if self._f is not 
None:\n            self._f.close()"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 174, "end_line": 179, "size": 6, 
"parent_context": "class_definition", "content": "def close_intelligently(self) -> 
None:\n        \"\"\"This function only closes the file if it was opened by the lazy\n
file wrapper.  For instance this will never close stdin.\n        \"\"\"\n        if 
self.should_close:\n            self.close()"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 181, "end_line": 182, "size": 2, 
"parent_context": "class_definition", "content": "def __enter__(self) -> LazyFile:\n  
return self"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 184, "end_line": 190, "size": 7, 
"parent_context": "class_definition", "content": "def __exit__(\n        self,\n      
exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n     
tb: TracebackType | None,\n    ) -> None:\n        self.close_intelligently()"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 192, "end_line": 194, "size": 3, 
"parent_context": "class_definition", "content": "def __iter__(self) -> 
cabc.Iterator:\n        self.open()\n        return iter(self._f)  # type: ignore"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"class_definition", "start_line": 197, "end_line": 219, "size": 23, "parent_context": 
"", "content": "class KeepOpenFile:\n    def __init__(self, file: t.IO) -> None:\n    
self._file: t.IO = file\n\n    def __getattr__(self, name: str) -> t.Any:\n        
return getattr(self._file, name)\n\n    def __enter__(self) -> KeepOpenFile:\n        
return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException]
| None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n
) -> None:\n        pass\n\n    def __repr__(self) -> str:\n        return 
repr(self._file)\n\n    def __iter__(self) -> cabc.Iterator:\n        return 
iter(self._file)"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 198, "end_line": 199, "size": 2, 
"parent_context": "class_definition", "content": "def __init__(self, file: t.IO) -> 
None:\n        self._file: t.IO = file"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 201, "end_line": 202, "size": 2, 
"parent_context": "class_definition", "content": "def __getattr__(self, name: str) -> 
t.Any:\n        return getattr(self._file, name)"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 204, "end_line": 205, "size": 2, 
"parent_context": "class_definition", "content": "def __enter__(self) -> 
KeepOpenFile:\n        return self"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 207, "end_line": 213, "size": 7, 
"parent_context": "class_definition", "content": "def __exit__(\n        self,\n      
exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n     
tb: TracebackType | None,\n    ) -> None:\n        pass"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 215, "end_line": 216, "size": 2, 
"parent_context": "class_definition", "content": "def __repr__(self) -> str:\n        
return repr(self._file)"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 218, "end_line": 219, "size": 2, 
"parent_context": "class_definition", "content": "def __iter__(self) -> 
cabc.Iterator:\n        return iter(self._file)"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 222, "end_line": 322, "size": 101, 
"parent_context": "", "content": "def echo(\n    message: t.Any | None = None,\n    
file: t.IO | None = None,\n    nl: bool = True,\n    err: bool = False,\n    color: 
bool | None = None,\n) -> None:\n    \"\"\"Print a message and newline to stdout or a 
file. This should be\n    used instead of :func:`print` because it provides better 
support\n    for different data, files, and environments.\n\n    Compared to 
:func:`print`, this does the following:\n\n    -   Ensures that the output encoding is
not misconfigured on Linux.\n    -   Supports Unicode in the Windows console.\n    -  
Supports writing to binary outputs, and supports writing bytes\n        to text 
outputs.\n    -   Supports colors and styles on Windows.\n    -   Removes ANSI color 
and style codes if the output does not look\n        like an interactive terminal.\n  
-   Always flushes the output.\n\n    :param message: The string or bytes to output. 
Other objects are\n        converted to strings.\n    :param file: The file to write 
to. Defaults to ``stdout``.\n    :param err: Write to ``stderr`` instead of 
``stdout``.\n    :param nl: Print a newline after the message. Enabled by default.\n  
:param color: Force showing or hiding colors and other styles. By\n        default 
Click will remove color if the output does not look like\n        an interactive 
terminal.\n\n    .. versionchanged:: 6.0\n        Support Unicode output on the 
Windows console. Click does not\n        modify ``sys.stdout``, so 
``sys.stdout.write()`` and ``print()``\n        will still not support Unicode.\n\n   
.. versionchanged:: 4.0\n        Added the ``color`` parameter.\n\n    .. 
versionadded:: 3.0\n        Added the ``err`` parameter.\n\n    .. versionchanged:: 
2.0\n        Support colors on Windows if colorama is installed.\n    \"\"\"\n    if 
file is None:\n        if err:\n            file = _default_text_stderr()\n        
else:\n            file = _default_text_stdout()\n\n        # There are no standard 
streams attached to write to. For example,\n        # pythonw on Windows.\n        if 
file is None:\n            return\n\n    # Convert non bytes/text into the native 
string type.\n    if message is not None and not isinstance(message, (str, bytes, 
bytearray)):\n        out: str | bytes | bytearray | None = str(message)\n    else:\n 
out = message\n\n    if nl:\n        out = out or \"\"\n        if isinstance(out, 
str):\n            out += \"\\n\"\n        else:\n            out += b\"\\n\"\n\n    
if not out:\n        file.flush()\n        return\n\n    # If there is a message and 
the value looks like bytes, we manually\n    # need to find the binary stream and 
write the message in there.\n    # This is done separately so that most stream types 
will work as you\n    # would expect. Eg: you can write to StringIO for other cases.\n
if isinstance(out, (bytes, bytearray)):\n        binary_file = 
_find_binary_writer(file)\n\n        if binary_file is not None:\n            
file.flush()\n            binary_file.write(out)\n            binary_file.flush()\n   
return\n\n    # ANSI style code support. For no message or bytes, nothing happens.\n  
# When outputting to a file instead of a terminal, strip codes.\n    else:\n        
color = resolve_color_default(color)\n\n        if should_strip_ansi(file, color):\n  
out = strip_ansi(out)\n        elif WIN:\n            if auto_wrap_for_ansi is not 
None:\n                file = auto_wrap_for_ansi(file, color)  # type: ignore\n       
elif not color:\n                out = strip_ansi(out)\n\n    file.write(out)  # type:
ignore\n    file.flush()"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 325, "end_line": 334, "size": 10, 
"parent_context": "", "content": "def get_binary_stream(name: t.Literal[\"stdin\", 
\"stdout\", \"stderr\"]) -> t.BinaryIO:\n    \"\"\"Returns a system stream for byte 
processing.\n\n    :param name: the name of the stream to open.  Valid names are 
``'stdin'``,\n                 ``'stdout'`` and ``'stderr'``\n    \"\"\"\n    opener =
binary_streams.get(name)\n    if opener is None:\n        raise TypeError(f\"Unknown 
standard stream '{name}'\")\n    return opener()"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 337, "end_line": 355, "size": 19, 
"parent_context": "", "content": "def get_text_stream(\n    name: t.Literal[\"stdin\",
\"stdout\", \"stderr\"],\n    encoding: str | None = None,\n    errors: str | None = 
\"strict\",\n) -> t.TextIO:\n    \"\"\"Returns a system stream for text processing.  
This usually returns\n    a wrapped stream around a binary stream returned from\n    
:func:`get_binary_stream` but it also can take shortcuts for already\n    correctly 
configured streams.\n\n    :param name: the name of the stream to open.  Valid names 
are ``'stdin'``,\n                 ``'stdout'`` and ``'stderr'``\n    :param encoding:
overrides the detected default encoding.\n    :param errors: overrides the default 
error mode.\n    \"\"\"\n    opener = text_streams.get(name)\n    if opener is None:\n
raise TypeError(f\"Unknown standard stream '{name}'\")\n    return opener(encoding, 
errors)"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 358, "end_line": 404, "size": 47, 
"parent_context": "", "content": "def open_file(\n    filename: str | os.PathLike,\n  
mode: str = \"r\",\n    encoding: str | None = None,\n    errors: str | None = 
\"strict\",\n    lazy: bool = False,\n    atomic: bool = False,\n) -> t.IO:\n    
\"\"\"Open a file, with extra behavior to handle ``'-'`` to indicate\n    a standard 
stream, lazy open on write, and atomic write. Similar to\n    the behavior of the 
:class:`~click.File` param type.\n\n    If ``'-'`` is given to open ``stdout`` or 
``stdin``, the stream is\n    wrapped so that using it in a context manager will not 
close it.\n    This makes it possible to use the function without accidentally\n    
closing a standard stream:\n\n    .. code-block:: python\n\n        with 
open_file(filename) as f:\n            ...\n\n    :param filename: The name or Path of
the file to open, or ``'-'`` for\n        ``stdin``/``stdout``.\n    :param mode: The 
mode in which to open the file.\n    :param encoding: The encoding to decode or encode
a file opened in\n        text mode.\n    :param errors: The error handling mode.\n   
:param lazy: Wait to open the file until it is accessed. For read\n        mode, the 
file is temporarily opened to raise access errors\n        early, then closed until it
is read again.\n    :param atomic: Write to a temporary file and replace the given 
file\n        on close.\n\n    .. versionadded:: 3.0\n    \"\"\"\n    if lazy:\n      
return t.cast(\n            \"t.IO\", LazyFile(filename, mode, encoding, errors, 
atomic=atomic)\n        )\n\n    f, should_close = open_stream(filename, mode, 
encoding, errors, atomic=atomic)\n\n    if not should_close:\n        f = 
t.cast(\"t.IO\", KeepOpenFile(f))\n\n    return f"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 407, "end_line": 446, "size": 40, 
"parent_context": "", "content": "def format_filename(\n    filename: str | bytes | 
os.PathLike | os.PathLike,\n    shorten: bool = False,\n) -> str:\n    \"\"\"Format a 
filename as a string for display. Ensures the filename can be\n    displayed by 
replacing any invalid bytes or surrogate escapes in the name\n    with the replacement
character ``\ufffd``.\n\n    Invalid bytes or surrogate escapes will raise an error 
when written to a\n    stream with ``errors=\"strict\"``. This will typically happen 
with ``stdout``\n    when the locale is something like ``en_GB.UTF-8``.\n\n    Many 
scenarios *are* safe to write surrogates though, due to PEP 538 and\n    PEP 540, 
including:\n\n    -   Writing to ``stderr``, which uses 
``errors=\"backslashreplace\"``.\n    -   The system has ``LANG=C.UTF-8``, ``C``, or 
``POSIX``. Python opens\n        stdout and stderr with 
``errors=\"surrogateescape\"``.\n    -   None of ``LANG/LC_*`` are set. Python assumes
``LANG=C.UTF-8``.\n    -   Python is started in UTF-8 mode  with  ``PYTHONUTF8=1`` or 
``-X utf8``.\n        Python opens stdout and stderr with 
``errors=\"surrogateescape\"``.\n\n    :param filename: formats a filename for UI 
display.  This will also convert\n                     the filename into unicode 
without failing.\n    :param shorten: this optionally shortens the filename to strip 
of the\n                    path that leads up to it.\n    \"\"\"\n    if shorten:\n  
filename = os.path.basename(filename)\n    else:\n        filename = 
os.fspath(filename)\n\n    if isinstance(filename, bytes):\n        filename = 
filename.decode(sys.getfilesystemencoding(), \"replace\")\n    else:\n        filename
= filename.encode(\"utf-8\", \"surrogateescape\").decode(\n            \"utf-8\", 
\"replace\"\n        )\n\n    return filename"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 449, "end_line": 495, "size": 47, 
"parent_context": "", "content": "def get_app_dir(app_name: str, roaming: bool = True,
force_posix: bool = False) -> str:\n    r\"\"\"Returns the config folder for the 
application.  The default behavior\n    is to return whatever is most appropriate for 
the operating system.\n\n    To give you an idea, for an app called ``\"Foo Bar\"``, 
something like\n    the following folders could be returned:\n\n    Mac OS X:\n      
``~/Library/Application Support/Foo Bar``\n    Mac OS X (POSIX):\n      
``~/.foo-bar``\n    Unix:\n      ``~/.config/foo-bar``\n    Unix (POSIX):\n      
``~/.foo-bar``\n    Windows (roaming):\n      
``C:\\Users\\<user>\\AppData\\Roaming\\Foo Bar``\n    Windows (not roaming):\n      
``C:\\Users\\<user>\\AppData\\Local\\Foo Bar``\n\n    .. versionadded:: 2.0\n\n    
:param app_name: the application name.  This should be properly capitalized\n         
and can contain whitespace.\n    :param roaming: controls if the folder should be 
roaming or not on Windows.\n                    Has no effect otherwise.\n    :param 
force_posix: if this is set to `True` then on any POSIX system the\n                  
folder will be stored in the home folder with a leading\n                        dot 
instead of the XDG config home or darwin's\n                        application 
support folder.\n    \"\"\"\n    if WIN:\n        key = \"APPDATA\" if roaming else 
\"LOCALAPPDATA\"\n        folder = os.environ.get(key)\n        if folder is None:\n  
folder = os.path.expanduser(\"~\")\n        return os.path.join(folder, app_name)\n   
if force_posix:\n        return 
os.path.join(os.path.expanduser(f\"~/.{_posixify(app_name)}\"))\n    if sys.platform 
== \"darwin\":\n        return os.path.join(\n            
os.path.expanduser(\"~/Library/Application Support\"), app_name\n        )\n    return
os.path.join(\n        os.environ.get(\"XDG_CONFIG_HOME\", 
os.path.expanduser(\"~/.config\")),\n        _posixify(app_name),\n    )"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"class_definition", "start_line": 498, "end_line": 520, "size": 23, "parent_context": 
"", "content": "class PacifyFlushWrapper:\n    \"\"\"This wrapper is used to catch and
suppress BrokenPipeErrors resulting\n    from ``.flush()`` being called on broken pipe
during the shutdown/final-GC\n    of the Python interpreter. Notably ``.flush()`` is 
always called on\n    ``sys.stdout`` and ``sys.stderr``. So as to have minimal impact 
on any\n    other cleanup code, and the case where the underlying file is not a 
broken\n    pipe, all calls and attributes are proxied.\n    \"\"\"\n\n    def 
__init__(self, wrapped: t.IO) -> None:\n        self.wrapped = wrapped\n\n    def 
flush(self) -> None:\n        try:\n            self.wrapped.flush()\n        except 
OSError as e:\n            import errno\n\n            if e.errno != errno.EPIPE:\n   
raise\n\n    def __getattr__(self, attr: str) -> t.Any:\n        return 
getattr(self.wrapped, attr)"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 507, "end_line": 508, "size": 2, 
"parent_context": "class_definition", "content": "def __init__(self, wrapped: t.IO) ->
None:\n        self.wrapped = wrapped"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 510, "end_line": 517, "size": 8, 
"parent_context": "class_definition", "content": "def flush(self) -> None:\n        
try:\n            self.wrapped.flush()\n        except OSError as e:\n            
import errno\n\n            if e.errno != errno.EPIPE:\n                raise"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 519, "end_line": 520, "size": 2, 
"parent_context": "class_definition", "content": "def __getattr__(self, attr: str) -> 
t.Any:\n        return getattr(self.wrapped, attr)"}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 523, "end_line": 575, "size": 53, 
"parent_context": "", "content": "def _detect_program_name(\n    path: str | None = 
None, _main: ModuleType | None = None\n) -> str:\n    \"\"\"Determine the command used
to run the program, for use in help\n    text. If a file or entry point was executed, 
the file name is\n    returned. If ``python -m`` was used to execute a module or 
package,\n    ``python -m name`` is returned.\n\n    This doesn't try to be too 
precise, the goal is to give a concise\n    name for help text. Files are only shown 
as their name without the\n    path. ``python`` is only shown for modules, and the 
full path to\n    ``sys.executable`` is not shown.\n\n    :param path: The Python file
being executed. Python puts this in\n        ``sys.argv[0]``, which is used by 
default.\n    :param _main: The ``__main__`` module. This should only be passed\n     
during internal testing.\n\n    .. versionadded:: 8.0\n        Based on command args 
detection in the Werkzeug reloader.\n\n    :meta private:\n    \"\"\"\n    if _main is
None:\n        _main = sys.modules[\"__main__\"]\n\n    if not path:\n        path = 
sys.argv[0]\n\n    # The value of __package__ indicates how Python was called. It 
may\n    # not exist if a setuptools script is installed as an egg. It may be\n    # 
set incorrectly for entry points created with pip on Windows.\n    # It is set to \"\"
inside a Shiv or PEX zipapp.\n    if getattr(_main, \"__package__\", None) in {None, 
\"\"} or (\n        os.name == \"nt\"\n        and _main.__package__ == \"\"\n        
and not os.path.exists(path)\n        and os.path.exists(f\"{path}.exe\")\n    ):\n   
# Executed a file, like \"python app.py\".\n        return os.path.basename(path)\n\n 
# Executed a module, like \"python -m example\".\n    # Rewritten by Python from \"-m 
script\" to \"/path/to/script.py\".\n    # Need to look at main module to determine 
how it was executed.\n    py_module = t.cast(str, _main.__package__)\n    name = 
os.path.splitext(os.path.basename(path))[0]\n\n    # A submodule like 
\"example.cli\".\n    if name != \"__main__\":\n        py_module = 
f\"{py_module}.{name}\"\n\n    return f\"python -m {py_module.lstrip('.')}\""}
{"file": "click/src/click/utils.py", "language": "python", "node_type": 
"function_definition", "start_line": 578, "end_line": 627, "size": 50, 
"parent_context": "", "content": "def _expand_args(\n    args: cabc.Iterable,\n    
*,\n    user: bool = True,\n    env: bool = True,\n    glob_recursive: bool = True,\n)
-> list:\n    \"\"\"Simulate Unix shell expansion with Python functions.\n\n    See 
:func:`glob.glob`, :func:`os.path.expanduser`, and\n    
:func:`os.path.expandvars`.\n\n    This is intended for use on Windows, where the 
shell does not do any\n    expansion. It may not exactly match what a Unix shell would
do.\n\n    :param args: List of command line arguments to expand.\n    :param user: 
Expand user home directory.\n    :param env: Expand environment variables.\n    :param
glob_recursive: ``**`` matches directories recursively.\n\n    .. versionchanged:: 
8.1\n        Invalid glob patterns are treated as empty expansions rather\n        
than raising an error.\n\n    .. versionadded:: 8.0\n\n    :meta private:\n    
\"\"\"\n    from glob import glob\n\n    out = []\n\n    for arg in args:\n        if 
user:\n            arg = os.path.expanduser(arg)\n\n        if env:\n            arg =
os.path.expandvars(arg)\n\n        try:\n            matches = glob(arg, 
recursive=glob_recursive)\n        except re.error:\n            matches = []\n\n     
if not matches:\n            out.append(arg)\n        else:\n            
out.extend(matches)\n\n    return out"}
{"file": "click/src/click/_textwrap.py", "language": "python", "node_type": 
"class_definition", "start_line": 8, "end_line": 51, "size": 44, "parent_context": "",
"content": "class TextWrapper(textwrap.TextWrapper):\n    def _handle_long_word(\n    
self,\n        reversed_chunks: list,\n        cur_line: list,\n        cur_len: 
int,\n        width: int,\n    ) -> None:\n        space_left = max(width - cur_len, 
1)\n\n        if self.break_long_words:\n            last = reversed_chunks[-1]\n     
cut = last[:space_left]\n            res = last\n            cur_line.append(cut)\n   
reversed_chunks[-1] = res\n        elif not cur_line:\n            
cur_line.append(reversed_chunks.pop())\n\n    @contextmanager\n    def 
extra_indent(self, indent: str) -> cabc.Iterator[None]:\n        old_initial_indent = 
self.initial_indent\n        old_subsequent_indent = self.subsequent_indent\n        
self.initial_indent += indent\n        self.subsequent_indent += indent\n\n        
try:\n            yield\n        finally:\n            self.initial_indent = 
old_initial_indent\n            self.subsequent_indent = old_subsequent_indent\n\n    
def indent_only(self, text: str) -> str:\n        rv = []\n\n        for idx, line in 
enumerate(text.splitlines()):\n            indent = self.initial_indent\n\n           
if idx > 0:\n                indent = self.subsequent_indent\n\n            
rv.append(f\"{indent}{line}\")\n\n        return \"\\n\".join(rv)"}
{"file": "click/src/click/_textwrap.py", "language": "python", "node_type": 
"function_definition", "start_line": 9, "end_line": 25, "size": 17, "parent_context": 
"class_definition", "content": "def _handle_long_word(\n        self,\n        
reversed_chunks: list,\n        cur_line: list,\n        cur_len: int,\n        width:
int,\n    ) -> None:\n        space_left = max(width - cur_len, 1)\n\n        if 
self.break_long_words:\n            last = reversed_chunks[-1]\n            cut = 
last[:space_left]\n            res = last\n            cur_line.append(cut)\n         
reversed_chunks[-1] = res\n        elif not cur_line:\n            
cur_line.append(reversed_chunks.pop())"}
{"file": "click/src/click/_textwrap.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 27, "end_line": 38, "size": 12, 
"parent_context": "class_definition", "content": "@contextmanager\n    def 
extra_indent(self, indent: str) -> cabc.Iterator[None]:\n        old_initial_indent = 
self.initial_indent\n        old_subsequent_indent = self.subsequent_indent\n        
self.initial_indent += indent\n        self.subsequent_indent += indent\n\n        
try:\n            yield\n        finally:\n            self.initial_indent = 
old_initial_indent\n            self.subsequent_indent = old_subsequent_indent"}
{"file": "click/src/click/_textwrap.py", "language": "python", "node_type": 
"function_definition", "start_line": 28, "end_line": 38, "size": 11, "parent_context":
"decorated_definition", "content": "def extra_indent(self, indent: str) -> 
cabc.Iterator[None]:\n        old_initial_indent = self.initial_indent\n        
old_subsequent_indent = self.subsequent_indent\n        self.initial_indent += 
indent\n        self.subsequent_indent += indent\n\n        try:\n            yield\n 
finally:\n            self.initial_indent = old_initial_indent\n            
self.subsequent_indent = old_subsequent_indent"}
{"file": "click/src/click/_textwrap.py", "language": "python", "node_type": 
"function_definition", "start_line": 40, "end_line": 51, "size": 12, "parent_context":
"class_definition", "content": "def indent_only(self, text: str) -> str:\n        rv =
[]\n\n        for idx, line in enumerate(text.splitlines()):\n            indent = 
self.initial_indent\n\n            if idx > 0:\n                indent = 
self.subsequent_indent\n\n            rv.append(f\"{indent}{line}\")\n\n        return
\"\\n\".join(rv)"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"class_definition", "start_line": 44, "end_line": 367, "size": 324, "parent_context": 
"", "content": "class ProgressBar(t.Generic[V]):\n    def __init__(\n        self,\n  
iterable: cabc.Iterable[V] | None,\n        length: int | None = None,\n        
fill_char: str = \"#\",\n        empty_char: str = \" \",\n        bar_template: str =
\"%(bar)s\",\n        info_sep: str = \"  \",\n        hidden: bool = False,\n        
show_eta: bool = True,\n        show_percent: bool | None = None,\n        show_pos: 
bool = False,\n        item_show_func: t.Callable[[V | None], str | None] | None = 
None,\n        label: str | None = None,\n        file: t.TextIO | None = None,\n     
color: bool | None = None,\n        update_min_steps: int = 1,\n        width: int = 
30,\n    ) -> None:\n        self.fill_char = fill_char\n        self.empty_char = 
empty_char\n        self.bar_template = bar_template\n        self.info_sep = 
info_sep\n        self.hidden = hidden\n        self.show_eta = show_eta\n        
self.show_percent = show_percent\n        self.show_pos = show_pos\n        
self.item_show_func = item_show_func\n        self.label: str = label or \"\"\n\n     
if file is None:\n            file = _default_text_stdout()\n\n            # There are
no standard streams attached to write to. For example,\n            # pythonw on 
Windows.\n            if file is None:\n                file = StringIO()\n\n        
self.file = file\n        self.color = color\n        self.update_min_steps = 
update_min_steps\n        self._completed_intervals = 0\n        self.width: int = 
width\n        self.autowidth: bool = width == 0\n\n        if length is None:\n      
from operator import length_hint\n\n            length = length_hint(iterable, -1)\n\n
if length == -1:\n                length = None\n        if iterable is None:\n       
if length is None:\n                raise TypeError(\"iterable or length is 
required\")\n            iterable = t.cast(\"cabc.Iterable[V]\", range(length))\n     
self.iter: cabc.Iterable[V] = iter(iterable)\n        self.length = length\n        
self.pos: int = 0\n        self.avg: list = []\n        self.last_eta: float\n        
self.start: float\n        self.start = self.last_eta = time.time()\n        
self.eta_known: bool = False\n        self.finished: bool = False\n        
self.max_width: int | None = None\n        self.entered: bool = False\n        
self.current_item: V | None = None\n        self._is_atty = isatty(self.file)\n       
self._last_line: str | None = None\n\n    def __enter__(self) -> ProgressBar[V]:\n    
self.entered = True\n        self.render_progress()\n        return self\n\n    def 
__exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        
exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n 
self.render_finish()\n\n    def __iter__(self) -> cabc.Iterator[V]:\n        if not 
self.entered:\n            raise RuntimeError(\"You need to use progress bars in a 
with block.\")\n        self.render_progress()\n        return self.generator()\n\n   
def __next__(self) -> V:\n        # Iteration is defined in terms of a generator 
function,\n        # returned by iter(self); use that to define next(). This works\n  
# because `self.iter` is an iterable consumed by that generator,\n        # so it is 
re-entry safe. Calling `next(self.generator())`\n        # twice works and does \"what
you want\".\n        return next(iter(self))\n\n    def render_finish(self) -> None:\n
if self.hidden or not self._is_atty:\n            return\n        
self.file.write(AFTER_BAR)\n        self.file.flush()\n\n    @property\n    def 
pct(self) -> float:\n        if self.finished:\n            return 1.0\n        return
min(self.pos / (float(self.length or 1) or 1), 1.0)\n\n    @property\n    def 
time_per_iteration(self) -> float:\n        if not self.avg:\n            return 0.0\n
return sum(self.avg) / float(len(self.avg))\n\n    @property\n    def eta(self) -> 
float:\n        if self.length is not None and not self.finished:\n            return 
self.time_per_iteration * (self.length - self.pos)\n        return 0.0\n\n    def 
format_eta(self) -> str:\n        if self.eta_known:\n            t = int(self.eta)\n 
seconds = t % 60\n            t //= 60\n            minutes = t % 60\n            t 
//= 60\n            hours = t % 24\n            t //= 24\n            if t > 0:\n     
return f\"{t}d {hours:02}:{minutes:02}:{seconds:02}\"\n            else:\n            
return f\"{hours:02}:{minutes:02}:{seconds:02}\"\n        return \"\"\n\n    def 
format_pos(self) -> str:\n        pos = str(self.pos)\n        if self.length is not 
None:\n            pos += f\"/{self.length}\"\n        return pos\n\n    def 
format_pct(self) -> str:\n        return f\"{int(self.pct * 100): 4}%\"[1:]\n\n    def
format_bar(self) -> str:\n        if self.length is not None:\n            bar_length 
= int(self.pct * self.width)\n            bar = self.fill_char * bar_length\n         
bar += self.empty_char * (self.width - bar_length)\n        elif self.finished:\n     
bar = self.fill_char * self.width\n        else:\n            chars = 
list(self.empty_char * (self.width or 1))\n            if self.time_per_iteration != 
0:\n                chars[\n                    int(\n                        
(math.cos(self.pos * self.time_per_iteration) / 2.0 + 0.5)\n                        * 
self.width\n                    )\n                ] = self.fill_char\n            bar
= \"\".join(chars)\n        return bar\n\n    def format_progress_line(self) -> str:\n
show_percent = self.show_percent\n\n        info_bits = []\n        if self.length is 
not None and show_percent is None:\n            show_percent = not self.show_pos\n\n  
if self.show_pos:\n            info_bits.append(self.format_pos())\n        if 
show_percent:\n            info_bits.append(self.format_pct())\n        if 
self.show_eta and self.eta_known and not self.finished:\n            
info_bits.append(self.format_eta())\n        if self.item_show_func is not None:\n    
item_info = self.item_show_func(self.current_item)\n            if item_info is not 
None:\n                info_bits.append(item_info)\n\n        return (\n            
self.bar_template\n            % {\n                \"label\": self.label,\n          
\"bar\": self.format_bar(),\n                \"info\": 
self.info_sep.join(info_bits),\n            }\n        ).rstrip()\n\n    def 
render_progress(self) -> None:\n        import shutil\n\n        if self.hidden:\n    
return\n\n        if not self._is_atty:\n            # Only output the label once if 
the output is not a TTY.\n            if self._last_line != self.label:\n             
self._last_line = self.label\n                echo(self.label, file=self.file, 
color=self.color)\n            return\n\n        buf = []\n        # Update width in 
case the terminal has been resized\n        if self.autowidth:\n            old_width 
= self.width\n            self.width = 0\n            clutter_length = 
term_len(self.format_progress_line())\n            new_width = max(0, 
shutil.get_terminal_size().columns - clutter_length)\n            if new_width < 
old_width and self.max_width is not None:\n                buf.append(BEFORE_BAR)\n   
buf.append(\" \" * self.max_width)\n                self.max_width = new_width\n      
self.width = new_width\n\n        clear_width = self.width\n        if self.max_width 
is not None:\n            clear_width = self.max_width\n\n        
buf.append(BEFORE_BAR)\n        line = self.format_progress_line()\n        line_len =
term_len(line)\n        if self.max_width is None or self.max_width < line_len:\n     
self.max_width = line_len\n\n        buf.append(line)\n        buf.append(\" \" * 
(clear_width - line_len))\n        line = \"\".join(buf)\n        # Render the line 
only if it changed.\n\n        if line != self._last_line:\n            
self._last_line = line\n            echo(line, file=self.file, color=self.color, 
nl=False)\n            self.file.flush()\n\n    def make_step(self, n_steps: int) -> 
None:\n        self.pos += n_steps\n        if self.length is not None and self.pos >=
self.length:\n            self.finished = True\n\n        if (time.time() - 
self.last_eta) < 1.0:\n            return\n\n        self.last_eta = time.time()\n\n  
# self.avg is a rolling list of length <= 7 of steps where steps are\n        # 
defined as time elapsed divided by the total progress through\n        # 
self.length.\n        if self.pos:\n            step = (time.time() - self.start) / 
self.pos\n        else:\n            step = time.time() - self.start\n\n        
self.avg = self.avg[-6:] + \n\n        self.eta_known = self.length is not None\n\n   
def update(self, n_steps: int, current_item: V | None = None) -> None:\n        
\"\"\"Update the progress bar by advancing a specified number of\n        steps, and 
optionally set the ``current_item`` for this new\n        position.\n\n        :param 
n_steps: Number of steps to advance.\n        :param current_item: Optional item to 
set as ``current_item``\n            for the updated position.\n\n        .. 
versionchanged:: 8.0\n            Added the ``current_item`` optional parameter.\n\n  
.. versionchanged:: 8.0\n            Only render when the number of steps meets the\n 
``update_min_steps`` threshold.\n        \"\"\"\n        if current_item is not 
None:\n            self.current_item = current_item\n\n        
self._completed_intervals += n_steps\n\n        if self._completed_intervals >= 
self.update_min_steps:\n            self.make_step(self._completed_intervals)\n       
self.render_progress()\n            self._completed_intervals = 0\n\n    def 
finish(self) -> None:\n        self.eta_known = False\n        self.current_item = 
None\n        self.finished = True\n\n    def generator(self) -> cabc.Iterator[V]:\n  
\"\"\"Return a generator which yields the items added to the bar\n        during 
construction, and updates the progress bar *after* the\n        yielded block 
returns.\n        \"\"\"\n        # WARNING: the iterator interface for `ProgressBar` 
relies on\n        # this and only works because this is a simple generator which\n   
# doesn't create or manage additional state. If this function\n        # changes, the 
impact should be evaluated both against\n        # `iter(bar)` and `next(bar)`. 
`next()` in particular may call\n        # `self.generator()` repeatedly, and this 
must remain safe in\n        # order for that interface to work.\n        if not 
self.entered:\n            raise RuntimeError(\"You need to use progress bars in a 
with block.\")\n\n        if not self._is_atty:\n            yield from self.iter\n   
else:\n            for rv in self.iter:\n                self.current_item = rv\n\n   
# This allows show_item_func to be updated before the\n                # item is 
processed. Only trigger at the beginning of\n                # the update interval.\n 
if self._completed_intervals == 0:\n                    self.render_progress()\n\n    
yield rv\n                self.update(1)\n\n            self.finish()\n            
self.render_progress()"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 45, "end_line": 114, "size": 70, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
iterable: cabc.Iterable[V] | None,\n        length: int | None = None,\n        
fill_char: str = \"#\",\n        empty_char: str = \" \",\n        bar_template: str =
\"%(bar)s\",\n        info_sep: str = \"  \",\n        hidden: bool = False,\n        
show_eta: bool = True,\n        show_percent: bool | None = None,\n        show_pos: 
bool = False,\n        item_show_func: t.Callable[[V | None], str | None] | None = 
None,\n        label: str | None = None,\n        file: t.TextIO | None = None,\n     
color: bool | None = None,\n        update_min_steps: int = 1,\n        width: int = 
30,\n    ) -> None:\n        self.fill_char = fill_char\n        self.empty_char = 
empty_char\n        self.bar_template = bar_template\n        self.info_sep = 
info_sep\n        self.hidden = hidden\n        self.show_eta = show_eta\n        
self.show_percent = show_percent\n        self.show_pos = show_pos\n        
self.item_show_func = item_show_func\n        self.label: str = label or \"\"\n\n     
if file is None:\n            file = _default_text_stdout()\n\n            # There are
no standard streams attached to write to. For example,\n            # pythonw on 
Windows.\n            if file is None:\n                file = StringIO()\n\n        
self.file = file\n        self.color = color\n        self.update_min_steps = 
update_min_steps\n        self._completed_intervals = 0\n        self.width: int = 
width\n        self.autowidth: bool = width == 0\n\n        if length is None:\n      
from operator import length_hint\n\n            length = length_hint(iterable, -1)\n\n
if length == -1:\n                length = None\n        if iterable is None:\n       
if length is None:\n                raise TypeError(\"iterable or length is 
required\")\n            iterable = t.cast(\"cabc.Iterable[V]\", range(length))\n     
self.iter: cabc.Iterable[V] = iter(iterable)\n        self.length = length\n        
self.pos: int = 0\n        self.avg: list = []\n        self.last_eta: float\n        
self.start: float\n        self.start = self.last_eta = time.time()\n        
self.eta_known: bool = False\n        self.finished: bool = False\n        
self.max_width: int | None = None\n        self.entered: bool = False\n        
self.current_item: V | None = None\n        self._is_atty = isatty(self.file)\n       
self._last_line: str | None = None"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 116, "end_line": 119, "size": 4, 
"parent_context": "class_definition", "content": "def __enter__(self) -> 
ProgressBar[V]:\n        self.entered = True\n        self.render_progress()\n        
return self"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 121, "end_line": 127, "size": 7, 
"parent_context": "class_definition", "content": "def __exit__(\n        self,\n      
exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n     
tb: TracebackType | None,\n    ) -> None:\n        self.render_finish()"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 129, "end_line": 133, "size": 5, 
"parent_context": "class_definition", "content": "def __iter__(self) -> 
cabc.Iterator[V]:\n        if not self.entered:\n            raise RuntimeError(\"You 
need to use progress bars in a with block.\")\n        self.render_progress()\n       
return self.generator()"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 135, "end_line": 141, "size": 7, 
"parent_context": "class_definition", "content": "def __next__(self) -> V:\n        # 
Iteration is defined in terms of a generator function,\n        # returned by 
iter(self); use that to define next(). This works\n        # because `self.iter` is an
iterable consumed by that generator,\n        # so it is re-entry safe. Calling 
`next(self.generator())`\n        # twice works and does \"what you want\".\n        
return next(iter(self))"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 143, "end_line": 147, "size": 5, 
"parent_context": "class_definition", "content": "def render_finish(self) -> None:\n  
if self.hidden or not self._is_atty:\n            return\n        
self.file.write(AFTER_BAR)\n        self.file.flush()"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 149, "end_line": 153, "size": 5, 
"parent_context": "class_definition", "content": "@property\n    def pct(self) -> 
float:\n        if self.finished:\n            return 1.0\n        return min(self.pos
/ (float(self.length or 1) or 1), 1.0)"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 150, "end_line": 153, "size": 4, 
"parent_context": "decorated_definition", "content": "def pct(self) -> float:\n       
if self.finished:\n            return 1.0\n        return min(self.pos / 
(float(self.length or 1) or 1), 1.0)"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 155, "end_line": 159, "size": 5, 
"parent_context": "class_definition", "content": "@property\n    def 
time_per_iteration(self) -> float:\n        if not self.avg:\n            return 0.0\n
return sum(self.avg) / float(len(self.avg))"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 156, "end_line": 159, "size": 4, 
"parent_context": "decorated_definition", "content": "def time_per_iteration(self) -> 
float:\n        if not self.avg:\n            return 0.0\n        return sum(self.avg)
/ float(len(self.avg))"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 161, "end_line": 165, "size": 5, 
"parent_context": "class_definition", "content": "@property\n    def eta(self) -> 
float:\n        if self.length is not None and not self.finished:\n            return 
self.time_per_iteration * (self.length - self.pos)\n        return 0.0"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 162, "end_line": 165, "size": 4, 
"parent_context": "decorated_definition", "content": "def eta(self) -> float:\n       
if self.length is not None and not self.finished:\n            return 
self.time_per_iteration * (self.length - self.pos)\n        return 0.0"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 167, "end_line": 180, "size": 14, 
"parent_context": "class_definition", "content": "def format_eta(self) -> str:\n      
if self.eta_known:\n            t = int(self.eta)\n            seconds = t % 60\n     
t //= 60\n            minutes = t % 60\n            t //= 60\n            hours = t % 
24\n            t //= 24\n            if t > 0:\n                return f\"{t}d 
{hours:02}:{minutes:02}:{seconds:02}\"\n            else:\n                return 
f\"{hours:02}:{minutes:02}:{seconds:02}\"\n        return \"\""}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 182, "end_line": 186, "size": 5, 
"parent_context": "class_definition", "content": "def format_pos(self) -> str:\n      
pos = str(self.pos)\n        if self.length is not None:\n            pos += 
f\"/{self.length}\"\n        return pos"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 188, "end_line": 189, "size": 2, 
"parent_context": "class_definition", "content": "def format_pct(self) -> str:\n      
return f\"{int(self.pct * 100): 4}%\"[1:]"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 191, "end_line": 208, "size": 18, 
"parent_context": "class_definition", "content": "def format_bar(self) -> str:\n      
if self.length is not None:\n            bar_length = int(self.pct * self.width)\n    
bar = self.fill_char * bar_length\n            bar += self.empty_char * (self.width - 
bar_length)\n        elif self.finished:\n            bar = self.fill_char * 
self.width\n        else:\n            chars = list(self.empty_char * (self.width or 
1))\n            if self.time_per_iteration != 0:\n                chars[\n           
int(\n                        (math.cos(self.pos * self.time_per_iteration) / 2.0 + 
0.5)\n                        * self.width\n                    )\n                ] =
self.fill_char\n            bar = \"\".join(chars)\n        return bar"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 210, "end_line": 235, "size": 26, 
"parent_context": "class_definition", "content": "def format_progress_line(self) -> 
str:\n        show_percent = self.show_percent\n\n        info_bits = []\n        if 
self.length is not None and show_percent is None:\n            show_percent = not 
self.show_pos\n\n        if self.show_pos:\n            
info_bits.append(self.format_pos())\n        if show_percent:\n            
info_bits.append(self.format_pct())\n        if self.show_eta and self.eta_known and 
not self.finished:\n            info_bits.append(self.format_eta())\n        if 
self.item_show_func is not None:\n            item_info = 
self.item_show_func(self.current_item)\n            if item_info is not None:\n       
info_bits.append(item_info)\n\n        return (\n            self.bar_template\n      
% {\n                \"label\": self.label,\n                \"bar\": 
self.format_bar(),\n                \"info\": self.info_sep.join(info_bits),\n        
}\n        ).rstrip()"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 237, "end_line": 281, "size": 45, 
"parent_context": "class_definition", "content": "def render_progress(self) -> None:\n
import shutil\n\n        if self.hidden:\n            return\n\n        if not 
self._is_atty:\n            # Only output the label once if the output is not a TTY.\n
if self._last_line != self.label:\n                self._last_line = self.label\n     
echo(self.label, file=self.file, color=self.color)\n            return\n\n        buf 
= []\n        # Update width in case the terminal has been resized\n        if 
self.autowidth:\n            old_width = self.width\n            self.width = 0\n     
clutter_length = term_len(self.format_progress_line())\n            new_width = max(0,
shutil.get_terminal_size().columns - clutter_length)\n            if new_width < 
old_width and self.max_width is not None:\n                buf.append(BEFORE_BAR)\n   
buf.append(\" \" * self.max_width)\n                self.max_width = new_width\n      
self.width = new_width\n\n        clear_width = self.width\n        if self.max_width 
is not None:\n            clear_width = self.max_width\n\n        
buf.append(BEFORE_BAR)\n        line = self.format_progress_line()\n        line_len =
term_len(line)\n        if self.max_width is None or self.max_width < line_len:\n     
self.max_width = line_len\n\n        buf.append(line)\n        buf.append(\" \" * 
(clear_width - line_len))\n        line = \"\".join(buf)\n        # Render the line 
only if it changed.\n\n        if line != self._last_line:\n            
self._last_line = line\n            echo(line, file=self.file, color=self.color, 
nl=False)\n            self.file.flush()"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 283, "end_line": 303, "size": 21, 
"parent_context": "class_definition", "content": "def make_step(self, n_steps: int) ->
None:\n        self.pos += n_steps\n        if self.length is not None and self.pos >=
self.length:\n            self.finished = True\n\n        if (time.time() - 
self.last_eta) < 1.0:\n            return\n\n        self.last_eta = time.time()\n\n  
# self.avg is a rolling list of length <= 7 of steps where steps are\n        # 
defined as time elapsed divided by the total progress through\n        # 
self.length.\n        if self.pos:\n            step = (time.time() - self.start) / 
self.pos\n        else:\n            step = time.time() - self.start\n\n        
self.avg = self.avg[-6:] + \n\n        self.eta_known = self.length is not None"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 305, "end_line": 329, "size": 25, 
"parent_context": "class_definition", "content": "def update(self, n_steps: int, 
current_item: V | None = None) -> None:\n        \"\"\"Update the progress bar by 
advancing a specified number of\n        steps, and optionally set the 
``current_item`` for this new\n        position.\n\n        :param n_steps: Number of 
steps to advance.\n        :param current_item: Optional item to set as 
``current_item``\n            for the updated position.\n\n        .. versionchanged::
8.0\n            Added the ``current_item`` optional parameter.\n\n        .. 
versionchanged:: 8.0\n            Only render when the number of steps meets the\n    
``update_min_steps`` threshold.\n        \"\"\"\n        if current_item is not 
None:\n            self.current_item = current_item\n\n        
self._completed_intervals += n_steps\n\n        if self._completed_intervals >= 
self.update_min_steps:\n            self.make_step(self._completed_intervals)\n       
self.render_progress()\n            self._completed_intervals = 0"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 331, "end_line": 334, "size": 4, 
"parent_context": "class_definition", "content": "def finish(self) -> None:\n        
self.eta_known = False\n        self.current_item = None\n        self.finished = 
True"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 336, "end_line": 367, "size": 32, 
"parent_context": "class_definition", "content": "def generator(self) -> 
cabc.Iterator[V]:\n        \"\"\"Return a generator which yields the items added to 
the bar\n        during construction, and updates the progress bar *after* the\n      
yielded block returns.\n        \"\"\"\n        # WARNING: the iterator interface for 
`ProgressBar` relies on\n        # this and only works because this is a simple 
generator which\n        # doesn't create or manage additional state. If this 
function\n        # changes, the impact should be evaluated both against\n        # 
`iter(bar)` and `next(bar)`. `next()` in particular may call\n        # 
`self.generator()` repeatedly, and this must remain safe in\n        # order for that 
interface to work.\n        if not self.entered:\n            raise RuntimeError(\"You
need to use progress bars in a with block.\")\n\n        if not self._is_atty:\n      
yield from self.iter\n        else:\n            for rv in self.iter:\n               
self.current_item = rv\n\n                # This allows show_item_func to be updated 
before the\n                # item is processed. Only trigger at the beginning of\n   
# the update interval.\n                if self._completed_intervals == 0:\n          
self.render_progress()\n\n                yield rv\n                self.update(1)\n\n
self.finish()\n            self.render_progress()"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 370, "end_line": 409, "size": 40, 
"parent_context": "", "content": "def pager(generator: cabc.Iterable, color: bool | 
None = None) -> None:\n    \"\"\"Decide what method to use for paging through 
text.\"\"\"\n    stdout = _default_text_stdout()\n\n    # There are no standard 
streams attached to write to. For example,\n    # pythonw on Windows.\n    if stdout 
is None:\n        stdout = StringIO()\n\n    if not isatty(sys.stdin) or not 
isatty(stdout):\n        return _nullpager(stdout, generator, color)\n\n    # Split 
and normalize the pager command into parts.\n    pager_cmd_parts = 
shlex.split(os.environ.get(\"PAGER\", \"\"), posix=False)\n    if pager_cmd_parts:\n  
if WIN:\n            if _tempfilepager(generator, pager_cmd_parts, color):\n          
return\n        elif _pipepager(generator, pager_cmd_parts, color):\n            
return\n\n    if os.environ.get(\"TERM\") in (\"dumb\", \"emacs\"):\n        return 
_nullpager(stdout, generator, color)\n    if (WIN or sys.platform.startswith(\"os2\"))
and _tempfilepager(\n        generator, [\"more\"], color\n    ):\n        return\n   
if _pipepager(generator, [\"less\"], color):\n        return\n\n    import 
tempfile\n\n    fd, filename = tempfile.mkstemp()\n    os.close(fd)\n    try:\n       
if _pipepager(generator, [\"more\"], color):\n            return\n        return 
_nullpager(stdout, generator, color)\n    finally:\n        os.unlink(filename)"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 412, "end_line": 499, "size": 88, 
"parent_context": "", "content": "def _pipepager(\n    generator: cabc.Iterable, 
cmd_parts: list, color: bool | None\n) -> bool:\n    \"\"\"Page through text by 
feeding it to another program. Invoking a\n    pager through this might support 
colors.\n\n    Returns `True` if the command was found, `False` otherwise and thus 
another\n    pager should be attempted.\n    \"\"\"\n    # Split the command into the 
invoked CLI and its parameters.\n    if not cmd_parts:\n        return False\n    cmd 
= cmd_parts[0]\n    cmd_params = cmd_parts[1:]\n\n    cmd_filepath = which(cmd)\n    
if not cmd_filepath:\n        return False\n    # Resolves symlinks and produces a 
normalized absolute path string.\n    cmd_path = Path(cmd_filepath).resolve()\n    
cmd_name = cmd_path.name\n\n    import subprocess\n\n    # Make a local copy of the 
environment to not affect the global one.\n    env = dict(os.environ)\n\n    # If 
we're piping to less and the user hasn't decided on colors, we enable\n    # them by 
default we find the -R flag in the command line arguments.\n    if color is None and 
cmd_name == \"less\":\n        less_flags = f\"{os.environ.get('LESS', '')}{' 
'.join(cmd_params)}\"\n        if not less_flags:\n            env[\"LESS\"] = 
\"-R\"\n            color = True\n        elif \"r\" in less_flags or \"R\" in 
less_flags:\n            color = True\n\n    c = subprocess.Popen(\n         + 
cmd_params,\n        shell=True,\n        stdin=subprocess.PIPE,\n        env=env,\n  
errors=\"replace\",\n        text=True,\n    )\n    assert c.stdin is not None\n    
try:\n        for text in generator:\n            if not color:\n                text 
= strip_ansi(text)\n\n            c.stdin.write(text)\n    except BrokenPipeError:\n  
# In case the pager exited unexpectedly, ignore the broken pipe error.\n        pass\n
except Exception as e:\n        # In case there is an exception we want to close the 
pager immediately\n        # and let the caller handle it.\n        # Otherwise the 
pager will keep running, and the user may not notice\n        # the error message, or 
worse yet it may leave the terminal in a broken state.\n        c.terminate()\n       
raise e\n    finally:\n        # We must close stdin and wait for the pager to exit 
before we continue\n        try:\n            c.stdin.close()\n        # Close implies
flush, so it might throw a BrokenPipeError if the pager\n        # process exited 
already.\n        except BrokenPipeError:\n            pass\n\n        # Less doesn't 
respect ^C, but catches it for its own UI purposes (aborting\n        # search or 
other commands inside less).\n        #\n        # That means when the user hits ^C, 
the parent process (click) terminates,\n        # but less is still alive, paging the 
output and messing up the terminal.\n        #\n        # If the user wants to make 
the pager exit on ^C, they should set\n        # `LESS='-K'`. It's not our decision to
make.\n        while True:\n            try:\n                c.wait()\n            
except KeyboardInterrupt:\n                pass\n            else:\n                
break\n\n    return True"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 502, "end_line": 541, "size": 40, 
"parent_context": "", "content": "def _tempfilepager(\n    generator: cabc.Iterable, 
cmd_parts: list, color: bool | None\n) -> bool:\n    \"\"\"Page through text by 
invoking a program on a temporary file.\n\n    Returns `True` if the command was 
found, `False` otherwise and thus another\n    pager should be attempted.\n    
\"\"\"\n    # Split the command into the invoked CLI and its parameters.\n    if not 
cmd_parts:\n        return False\n    cmd = cmd_parts[0]\n\n    cmd_filepath = 
which(cmd)\n    if not cmd_filepath:\n        return False\n    # Resolves symlinks 
and produces a normalized absolute path string.\n    cmd_path = 
Path(cmd_filepath).resolve()\n\n    import subprocess\n    import tempfile\n\n    fd, 
filename = tempfile.mkstemp()\n    # TODO: This never terminates if the passed 
generator never terminates.\n    text = \"\".join(generator)\n    if not color:\n     
text = strip_ansi(text)\n    encoding = get_best_encoding(sys.stdout)\n    with 
open_stream(filename, \"wb\")[0] as f:\n        f.write(text.encode(encoding))\n    
try:\n        subprocess.call()\n    except OSError:\n        # Command not found\n   
pass\n    finally:\n        os.close(fd)\n        os.unlink(filename)\n\n    return 
True"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 544, "end_line": 551, "size": 8, 
"parent_context": "", "content": "def _nullpager(\n    stream: t.TextIO, generator: 
cabc.Iterable, color: bool | None\n) -> None:\n    \"\"\"Simply print unformatted 
text.  This is the ultimate fallback.\"\"\"\n    for text in generator:\n        if 
not color:\n            text = strip_ansi(text)\n        stream.write(text)"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"class_definition", "start_line": 554, "end_line": 660, "size": 107, "parent_context":
"", "content": "class Editor:\n    def __init__(\n        self,\n        editor: str |
None = None,\n        env: cabc.Mapping | None = None,\n        require_save: bool = 
True,\n        extension: str = \".txt\",\n    ) -> None:\n        self.editor = 
editor\n        self.env = env\n        self.require_save = require_save\n        
self.extension = extension\n\n    def get_editor(self) -> str:\n        if self.editor
is not None:\n            return self.editor\n        for key in \"VISUAL\", 
\"EDITOR\":\n            rv = os.environ.get(key)\n            if rv:\n               
return rv\n        if WIN:\n            return \"notepad\"\n        for editor in 
\"sensible-editor\", \"vim\", \"nano\":\n            if which(editor) is not None:\n  
return editor\n        return \"vi\"\n\n    def edit_files(self, filenames: 
cabc.Iterable) -> None:\n        import subprocess\n\n        editor = 
self.get_editor()\n        environ: dict | None = None\n\n        if self.env:\n      
environ = os.environ.copy()\n            environ.update(self.env)\n\n        
exc_filename = \" \".join(f'\"{filename}\"' for filename in filenames)\n\n        
try:\n            c = subprocess.Popen(\n                args=f\"{editor} 
{exc_filename}\", env=environ, shell=True\n            )\n            exit_code = 
c.wait()\n            if exit_code != 0:\n                raise ClickException(\n     
_(\"{editor}: Editing failed\").format(editor=editor)\n                )\n        
except OSError as e:\n            raise ClickException(\n                _(\"{editor}:
Editing failed: {e}\").format(editor=editor, e=e)\n            ) from e\n\n    
@t.overload\n    def edit(self, text: bytes | bytearray) -> bytes | None: ...\n\n    #
We cannot know whether or not the type expected is str or bytes when None\n    # is 
passed, so str is returned as that was what was done before.\n    @t.overload\n    def
edit(self, text: str | None) -> str | None: ...\n\n    def edit(self, text: str | 
bytes | bytearray | None) -> str | bytes | None:\n        import tempfile\n\n        
if text is None:\n            data: bytes | bytearray = b\"\"\n        elif 
isinstance(text, (bytes, bytearray)):\n            data = text\n        else:\n       
if text and not text.endswith(\"\\n\"):\n                text += \"\\n\"\n\n          
if WIN:\n                data = text.replace(\"\\n\", 
\"\\r\\n\").encode(\"utf-8-sig\")\n            else:\n                data = 
text.encode(\"utf-8\")\n\n        fd, name = tempfile.mkstemp(prefix=\"editor-\", 
suffix=self.extension)\n        f: t.BinaryIO\n\n        try:\n            with 
os.fdopen(fd, \"wb\") as f:\n                f.write(data)\n\n            # If the 
filesystem resolution is 1 second, like Mac OS\n            # 10.12 Extended, or 2 
seconds, like FAT32, and the editor\n            # closes very fast, require_save can 
fail. Set the modified\n            # time to be 2 seconds in the past to work around 
this.\n            os.utime(name, (os.path.getatime(name), os.path.getmtime(name) - 
2))\n            # Depending on the resolution, the exact value might not be\n        
# recorded, so get the new recorded value.\n            timestamp = 
os.path.getmtime(name)\n\n            self.edit_files((name,))\n\n            if 
self.require_save and os.path.getmtime(name) == timestamp:\n                return 
None\n\n            with open(name, \"rb\") as f:\n                rv = f.read()\n\n  
if isinstance(text, (bytes, bytearray)):\n                return rv\n\n            
return rv.decode(\"utf-8-sig\").replace(\"\\r\\n\", \"\\n\")\n        finally:\n      
os.unlink(name)"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 555, "end_line": 565, "size": 11, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
editor: str | None = None,\n        env: cabc.Mapping | None = None,\n        
require_save: bool = True,\n        extension: str = \".txt\",\n    ) -> None:\n      
self.editor = editor\n        self.env = env\n        self.require_save = 
require_save\n        self.extension = extension"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 567, "end_line": 579, "size": 13, 
"parent_context": "class_definition", "content": "def get_editor(self) -> str:\n      
if self.editor is not None:\n            return self.editor\n        for key in 
\"VISUAL\", \"EDITOR\":\n            rv = os.environ.get(key)\n            if rv:\n   
return rv\n        if WIN:\n            return \"notepad\"\n        for editor in 
\"sensible-editor\", \"vim\", \"nano\":\n            if which(editor) is not None:\n  
return editor\n        return \"vi\""}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 581, "end_line": 605, "size": 25, 
"parent_context": "class_definition", "content": "def edit_files(self, filenames: 
cabc.Iterable) -> None:\n        import subprocess\n\n        editor = 
self.get_editor()\n        environ: dict | None = None\n\n        if self.env:\n      
environ = os.environ.copy()\n            environ.update(self.env)\n\n        
exc_filename = \" \".join(f'\"{filename}\"' for filename in filenames)\n\n        
try:\n            c = subprocess.Popen(\n                args=f\"{editor} 
{exc_filename}\", env=environ, shell=True\n            )\n            exit_code = 
c.wait()\n            if exit_code != 0:\n                raise ClickException(\n     
_(\"{editor}: Editing failed\").format(editor=editor)\n                )\n        
except OSError as e:\n            raise ClickException(\n                _(\"{editor}:
Editing failed: {e}\").format(editor=editor, e=e)\n            ) from e"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 607, "end_line": 608, "size": 2, 
"parent_context": "class_definition", "content": "@t.overload\n    def edit(self, 
text: bytes | bytearray) -> bytes | None: ..."}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 608, "end_line": 608, "size": 1, 
"parent_context": "decorated_definition", "content": "def edit(self, text: bytes | 
bytearray) -> bytes | None: ..."}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 612, "end_line": 613, "size": 2, 
"parent_context": "class_definition", "content": "@t.overload\n    def edit(self, 
text: str | None) -> str | None: ..."}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 613, "end_line": 613, "size": 1, 
"parent_context": "decorated_definition", "content": "def edit(self, text: str | None)
-> str | None: ..."}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 615, "end_line": 660, "size": 46, 
"parent_context": "class_definition", "content": "def edit(self, text: str | bytes | 
bytearray | None) -> str | bytes | None:\n        import tempfile\n\n        if text 
is None:\n            data: bytes | bytearray = b\"\"\n        elif isinstance(text, 
(bytes, bytearray)):\n            data = text\n        else:\n            if text and 
not text.endswith(\"\\n\"):\n                text += \"\\n\"\n\n            if WIN:\n 
data = text.replace(\"\\n\", \"\\r\\n\").encode(\"utf-8-sig\")\n            else:\n   
data = text.encode(\"utf-8\")\n\n        fd, name = 
tempfile.mkstemp(prefix=\"editor-\", suffix=self.extension)\n        f: t.BinaryIO\n\n
try:\n            with os.fdopen(fd, \"wb\") as f:\n                f.write(data)\n\n 
# If the filesystem resolution is 1 second, like Mac OS\n            # 10.12 Extended,
or 2 seconds, like FAT32, and the editor\n            # closes very fast, require_save
can fail. Set the modified\n            # time to be 2 seconds in the past to work 
around this.\n            os.utime(name, (os.path.getatime(name), 
os.path.getmtime(name) - 2))\n            # Depending on the resolution, the exact 
value might not be\n            # recorded, so get the new recorded value.\n          
timestamp = os.path.getmtime(name)\n\n            self.edit_files((name,))\n\n        
if self.require_save and os.path.getmtime(name) == timestamp:\n                return 
None\n\n            with open(name, \"rb\") as f:\n                rv = f.read()\n\n  
if isinstance(text, (bytes, bytearray)):\n                return rv\n\n            
return rv.decode(\"utf-8-sig\").replace(\"\\r\\n\", \"\\n\")\n        finally:\n      
os.unlink(name)"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 663, "end_line": 731, "size": 69, 
"parent_context": "", "content": "def open_url(url: str, wait: bool = False, locate: 
bool = False) -> int:\n    import subprocess\n\n    def _unquote_file(url: str) -> 
str:\n        from urllib.parse import unquote\n\n        if 
url.startswith(\"file://\"):\n            url = unquote(url[7:])\n\n        return 
url\n\n    if sys.platform == \"darwin\":\n        args = [\"open\"]\n        if 
wait:\n            args.append(\"-W\")\n        if locate:\n            
args.append(\"-R\")\n        args.append(_unquote_file(url))\n        null = 
open(\"/dev/null\", \"w\")\n        try:\n            return subprocess.Popen(args, 
stderr=null).wait()\n        finally:\n            null.close()\n    elif WIN:\n      
if locate:\n            url = _unquote_file(url)\n            args = [\"explorer\", 
f\"/select,{url}\"]\n        else:\n            args = [\"start\"]\n            if 
wait:\n                args.append(\"/WAIT\")\n            args.append(\"\")\n        
args.append(url)\n        try:\n            return subprocess.call(args)\n        
except OSError:\n            # Command not found\n            return 127\n    elif 
CYGWIN:\n        if locate:\n            url = _unquote_file(url)\n            args = 
[\"cygstart\", os.path.dirname(url)]\n        else:\n            args = 
[\"cygstart\"]\n            if wait:\n                args.append(\"-w\")\n           
args.append(url)\n        try:\n            return subprocess.call(args)\n        
except OSError:\n            # Command not found\n            return 127\n\n    try:\n
if locate:\n            url = os.path.dirname(_unquote_file(url)) or \".\"\n        
else:\n            url = _unquote_file(url)\n        c = 
subprocess.Popen([\"xdg-open\", url])\n        if wait:\n            return c.wait()\n
return 0\n    except OSError:\n        if url.startswith((\"http://\", \"https://\")) 
and not locate and not wait:\n            import webbrowser\n\n            
webbrowser.open(url)\n            return 0\n        return 1"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 666, "end_line": 672, "size": 7, 
"parent_context": "function_definition", "content": "def _unquote_file(url: str) -> 
str:\n        from urllib.parse import unquote\n\n        if 
url.startswith(\"file://\"):\n            url = unquote(url[7:])\n\n        return 
url"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 734, "end_line": 744, "size": 11, 
"parent_context": "", "content": "def _translate_ch_to_exc(ch: str) -> None:\n    if 
ch == \"\\x03\":\n        raise KeyboardInterrupt()\n\n    if ch == \"\\x04\" and not 
WIN:  # Unix-like, Ctrl+D\n        raise EOFError()\n\n    if ch == \"\\x1a\" and WIN:
# Windows, Ctrl+Z\n        raise EOFError()\n\n    return None"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 750, "end_line": 752, "size": 3, 
"parent_context": "", "content": "@contextlib.contextmanager\n    def raw_terminal() 
-> cabc.Iterator:\n        yield -1"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 751, "end_line": 752, "size": 2, 
"parent_context": "decorated_definition", "content": "def raw_terminal() -> 
cabc.Iterator:\n        yield -1"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 754, "end_line": 798, "size": 45, 
"parent_context": "", "content": "def getchar(echo: bool) -> str:\n        # The 
function `getch` will return a bytes object corresponding to\n        # the pressed 
character. Since Windows 10 build 1803, it will also\n        # return \\x00 when 
called a second time after pressing a regular key.\n        #\n        # `getwch` does
not share this probably-bugged behavior. Moreover, it\n        # returns a Unicode 
object by default, which is what we want.\n        #\n        # Either of these 
functions will return \\x00 or \\xe0 to indicate\n        # a special key, and you 
need to call the same function again to get\n        # the \"rest\" of the code. The 
fun part is that \\u00e0 is\n        # \"latin small letter a with grave\", so if you 
type that on a French\n        # keyboard, you _also_ get a \\xe0.\n        # E.g., 
consider the Up arrow. This returns \\xe0 and then \\x48. The\n        # resulting 
Unicode string reads as \"a with grave\" + \"capital H\".\n        # This is 
indistinguishable from when the user actually types\n        # \"a with grave\" and 
then \"capital H\".\n        #\n        # When \\xe0 is returned, we assume it's part 
of a special-key sequence\n        # and call `getwch` again, but that means that when
the user types\n        # the \\u00e0 character, `getchar` doesn't return until a 
second\n        # character is typed.\n        # The alternative is returning 
immediately, but that would mess up\n        # cross-platform handling of arrow keys 
and others that start with\n        # \\xe0. Another option is using `getch`, but then
we can't reliably\n        # read non-ASCII characters, because return values of 
`getch` are\n        # limited to the current 8-bit codepage.\n        #\n        # 
Anyway, Click doesn't claim to do this Right(tm), and using `getwch`\n        # is 
doing the right thing in more situations than with `getch`.\n\n        if echo:\n     
func = t.cast(t.Callable[[], str], msvcrt.getwche)\n        else:\n            func = 
t.cast(t.Callable[[], str], msvcrt.getwch)\n\n        rv = func()\n\n        if rv in 
(\"\\x00\", \"\\xe0\"):\n            # \\x00 and \\xe0 are control characters that 
indicate special key,\n            # see above.\n            rv += func()\n\n        
_translate_ch_to_exc(rv)\n        return rv"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 804, "end_line": 829, "size": 26, 
"parent_context": "", "content": "@contextlib.contextmanager\n    def raw_terminal() 
-> cabc.Iterator:\n        f: t.TextIO | None\n        fd: int\n\n        if not 
isatty(sys.stdin):\n            f = open(\"/dev/tty\")\n            fd = f.fileno()\n 
else:\n            fd = sys.stdin.fileno()\n            f = None\n\n        try:\n    
old_settings = termios.tcgetattr(fd)\n\n            try:\n                
tty.setraw(fd)\n                yield fd\n            finally:\n                
termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n                
sys.stdout.flush()\n\n                if f is not None:\n                    
f.close()\n        except termios.error:\n            pass"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 805, "end_line": 829, "size": 25, 
"parent_context": "decorated_definition", "content": "def raw_terminal() -> 
cabc.Iterator:\n        f: t.TextIO | None\n        fd: int\n\n        if not 
isatty(sys.stdin):\n            f = open(\"/dev/tty\")\n            fd = f.fileno()\n 
else:\n            fd = sys.stdin.fileno()\n            f = None\n\n        try:\n    
old_settings = termios.tcgetattr(fd)\n\n            try:\n                
tty.setraw(fd)\n                yield fd\n            finally:\n                
termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n                
sys.stdout.flush()\n\n                if f is not None:\n                    
f.close()\n        except termios.error:\n            pass"}
{"file": "click/src/click/_termui_impl.py", "language": "python", "node_type": 
"function_definition", "start_line": 831, "end_line": 839, "size": 9, 
"parent_context": "", "content": "def getchar(echo: bool) -> str:\n        with 
raw_terminal() as fd:\n            ch = os.read(fd, 
32).decode(get_best_encoding(sys.stdin), \"replace\")\n\n            if echo and 
isatty(sys.stdout):\n                sys.stdout.write(ch)\n\n            
_translate_ch_to_exc(ch)\n            return ch"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 30, "end_line": 160, "size": 131, "parent_context": 
"", "content": "class ParamType:\n    \"\"\"Represents the type of a parameter. 
Validates and converts values\n    from the command line or Python into the correct 
type.\n\n    To implement a custom type, subclass and implement at least the\n    
following:\n\n    -   The :attr:`name` class attribute must be set.\n    -   Calling 
an instance of the type with ``None`` must return\n        ``None``. This is already 
implemented by default.\n    -   :meth:`convert` must convert string values to the 
correct type.\n    -   :meth:`convert` must accept values that are already the 
correct\n        type.\n    -   It must be able to convert a value if the ``ctx`` and 
``param``\n        arguments are ``None``. This can occur when converting prompt\n    
input.\n    \"\"\"\n\n    is_composite: t.ClassVar = False\n    arity: t.ClassVar = 
1\n\n    #: the descriptive name of this type\n    name: str\n\n    #: if a list of 
this type is expected and the value is pulled from a\n    #: string environment 
variable, this is what splits it up.  `None`\n    #: means any whitespace.  For all 
parameters the general rule is that\n    #: whitespace splits them up.  The exception 
are paths and files which\n    #: are split by ``os.path.pathsep`` by default (\":\" 
on Unix and \";\" on\n    #: Windows).\n    envvar_list_splitter: t.ClassVar = 
None\n\n    def to_info_dict(self) -> dict:\n        \"\"\"Gather information that 
could be useful for a tool generating\n        user-facing documentation.\n\n        
Use :meth:`click.Context.to_info_dict` to traverse the entire\n        CLI 
structure.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        # The class name 
without the \"ParamType\" suffix.\n        param_type = 
type(self).__name__.partition(\"ParamType\")[0]\n        param_type = 
param_type.partition(\"ParameterType\")[0]\n\n        # Custom subclasses might not 
remember to set a name.\n        if hasattr(self, \"name\"):\n            name = 
self.name\n        else:\n            name = param_type\n\n        return 
{\"param_type\": param_type, \"name\": name}\n\n    def __call__(\n        self,\n    
value: t.Any,\n        param: Parameter | None = None,\n        ctx: Context | None = 
None,\n    ) -> t.Any:\n        if value is not None:\n            return 
self.convert(value, param, ctx)\n\n    def get_metavar(self, param: Parameter, ctx: 
Context) -> str | None:\n        \"\"\"Returns the metavar default for this param if 
it provides one.\"\"\"\n\n    def get_missing_message(self, param: Parameter, ctx: 
Context | None) -> str | None:\n        \"\"\"Optionally might return extra 
information about a missing\n        parameter.\n\n        .. versionadded:: 2.0\n    
\"\"\"\n\n    def convert(\n        self, value: t.Any, param: Parameter | None, ctx: 
Context | None\n    ) -> t.Any:\n        \"\"\"Convert the value to the correct type. 
This is not called if\n        the value is ``None`` (the missing value).\n\n        
This must accept string values from the command line, as well as\n        values that 
are already the correct type. It may also convert\n        other compatible types.\n\n
The ``param`` and ``ctx`` arguments may be ``None`` in certain\n        situations, 
such as when converting prompt input.\n\n        If the value cannot be converted, 
call :meth:`fail` with a\n        descriptive message.\n\n        :param value: The 
value to convert.\n        :param param: The parameter that is using this type to 
convert\n            its value. May be ``None``.\n        :param ctx: The current 
context that arrived at this value. May\n            be ``None``.\n        \"\"\"\n   
return value\n\n    def split_envvar_value(self, rv: str) -> cabc.Sequence:\n        
\"\"\"Given a value from an environment variable this splits it up\n        into small
chunks depending on the defined envvar list splitter.\n\n        If the splitter is 
set to `None`, which means that whitespace splits,\n        then leading and trailing 
whitespace is ignored.  Otherwise, leading\n        and trailing splitters usually 
lead to empty items being included.\n        \"\"\"\n        return (rv or 
\"\").split(self.envvar_list_splitter)\n\n    def fail(\n        self,\n        
message: str,\n        param: Parameter | None = None,\n        ctx: Context | None = 
None,\n    ) -> t.NoReturn:\n        \"\"\"Helper method to fail with an invalid value
message.\"\"\"\n        raise BadParameter(message, ctx=ctx, param=param)\n\n    def 
shell_complete(\n        self, ctx: Context, param: Parameter, incomplete: str\n    ) 
-> list[CompletionItem]:\n        \"\"\"Return a list of\n        
:class:`~click.shell_completion.CompletionItem` objects for the\n        incomplete 
value. Most types do not provide completions, but\n        some do, and this allows 
custom types to provide custom\n        completions as well.\n\n        :param ctx: 
Invocation context for this command.\n        :param param: The parameter that is 
requesting completion.\n        :param incomplete: Value being completed. May be 
empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        return []"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 62, "end_line": 81, "size": 20, "parent_context":
"class_definition", "content": "def to_info_dict(self) -> dict:\n        \"\"\"Gather 
information that could be useful for a tool generating\n        user-facing 
documentation.\n\n        Use :meth:`click.Context.to_info_dict` to traverse the 
entire\n        CLI structure.\n\n        .. versionadded:: 8.0\n        \"\"\"\n     
# The class name without the \"ParamType\" suffix.\n        param_type = 
type(self).__name__.partition(\"ParamType\")[0]\n        param_type = 
param_type.partition(\"ParameterType\")[0]\n\n        # Custom subclasses might not 
remember to set a name.\n        if hasattr(self, \"name\"):\n            name = 
self.name\n        else:\n            name = param_type\n\n        return 
{\"param_type\": param_type, \"name\": name}"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 83, "end_line": 90, "size": 8, "parent_context": 
"class_definition", "content": "def __call__(\n        self,\n        value: t.Any,\n 
param: Parameter | None = None,\n        ctx: Context | None = None,\n    ) -> 
t.Any:\n        if value is not None:\n            return self.convert(value, param, 
ctx)"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 92, "end_line": 93, "size": 2, "parent_context": 
"class_definition", "content": "def get_metavar(self, param: Parameter, ctx: Context) 
-> str | None:\n        \"\"\"Returns the metavar default for this param if it 
provides one.\"\"\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 95, "end_line": 100, "size": 6, "parent_context":
"class_definition", "content": "def get_missing_message(self, param: Parameter, ctx: 
Context | None) -> str | None:\n        \"\"\"Optionally might return extra 
information about a missing\n        parameter.\n\n        .. versionadded:: 2.0\n    
\"\"\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 102, "end_line": 124, "size": 23, 
"parent_context": "class_definition", "content": "def convert(\n        self, value: 
t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        
\"\"\"Convert the value to the correct type. This is not called if\n        the value 
is ``None`` (the missing value).\n\n        This must accept string values from the 
command line, as well as\n        values that are already the correct type. It may 
also convert\n        other compatible types.\n\n        The ``param`` and ``ctx`` 
arguments may be ``None`` in certain\n        situations, such as when converting 
prompt input.\n\n        If the value cannot be converted, call :meth:`fail` with a\n 
descriptive message.\n\n        :param value: The value to convert.\n        :param 
param: The parameter that is using this type to convert\n            its value. May be
``None``.\n        :param ctx: The current context that arrived at this value. May\n  
be ``None``.\n        \"\"\"\n        return value"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 126, "end_line": 134, "size": 9, 
"parent_context": "class_definition", "content": "def split_envvar_value(self, rv: 
str) -> cabc.Sequence:\n        \"\"\"Given a value from an environment variable this 
splits it up\n        into small chunks depending on the defined envvar list 
splitter.\n\n        If the splitter is set to `None`, which means that whitespace 
splits,\n        then leading and trailing whitespace is ignored.  Otherwise, 
leading\n        and trailing splitters usually lead to empty items being included.\n 
\"\"\"\n        return (rv or \"\").split(self.envvar_list_splitter)"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 136, "end_line": 143, "size": 8, 
"parent_context": "class_definition", "content": "def fail(\n        self,\n        
message: str,\n        param: Parameter | None = None,\n        ctx: Context | None = 
None,\n    ) -> t.NoReturn:\n        \"\"\"Helper method to fail with an invalid value
message.\"\"\"\n        raise BadParameter(message, ctx=ctx, param=param)"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 145, "end_line": 160, "size": 16, 
"parent_context": "class_definition", "content": "def shell_complete(\n        self, 
ctx: Context, param: Parameter, incomplete: str\n    ) -> list[CompletionItem]:\n     
\"\"\"Return a list of\n        :class:`~click.shell_completion.CompletionItem` 
objects for the\n        incomplete value. Most types do not provide completions, 
but\n        some do, and this allows custom types to provide custom\n        
completions as well.\n\n        :param ctx: Invocation context for this command.\n    
:param param: The parameter that is requesting completion.\n        :param incomplete:
Value being completed. May be empty.\n\n        .. versionadded:: 8.0\n        
\"\"\"\n        return []"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 163, "end_line": 168, "size": 6, "parent_context": 
"", "content": "class CompositeParamType(ParamType):\n    is_composite = True\n\n    
@property\n    def arity(self) -> int:  # type: ignore\n        raise 
NotImplementedError()"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 166, "end_line": 168, "size": 3, 
"parent_context": "class_definition", "content": "@property\n    def arity(self) -> 
int:  # type: ignore\n        raise NotImplementedError()"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 167, "end_line": 168, "size": 2, 
"parent_context": "decorated_definition", "content": "def arity(self) -> int:  # type:
ignore\n        raise NotImplementedError()"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 171, "end_line": 192, "size": 22, "parent_context": 
"", "content": "class FuncParamType(ParamType):\n    def __init__(self, func: 
t.Callable[, t.Any]) -> None:\n        self.name: str = func.__name__\n        
self.func = func\n\n    def to_info_dict(self) -> dict:\n        info_dict = 
super().to_info_dict()\n        info_dict[\"func\"] = self.func\n        return 
info_dict\n\n    def convert(\n        self, value: t.Any, param: Parameter | None, 
ctx: Context | None\n    ) -> t.Any:\n        try:\n            return 
self.func(value)\n        except ValueError:\n            try:\n                value 
= str(value)\n            except UnicodeError:\n                value = 
value.decode(\"utf-8\", \"replace\")\n\n            self.fail(value, param, ctx)"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 172, "end_line": 174, "size": 3, 
"parent_context": "class_definition", "content": "def __init__(self, func: 
t.Callable[, t.Any]) -> None:\n        self.name: str = func.__name__\n        
self.func = func"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 176, "end_line": 179, "size": 4, 
"parent_context": "class_definition", "content": "def to_info_dict(self) -> dict:\n   
info_dict = super().to_info_dict()\n        info_dict[\"func\"] = self.func\n        
return info_dict"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 181, "end_line": 192, "size": 12, 
"parent_context": "class_definition", "content": "def convert(\n        self, value: 
t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        try:\n  
return self.func(value)\n        except ValueError:\n            try:\n               
value = str(value)\n            except UnicodeError:\n                value = 
value.decode(\"utf-8\", \"replace\")\n\n            self.fail(value, param, ctx)"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 195, "end_line": 204, "size": 10, "parent_context": 
"", "content": "class UnprocessedParamType(ParamType):\n    name = \"text\"\n\n    def
convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n  
) -> t.Any:\n        return value\n\n    def __repr__(self) -> str:\n        return 
\"UNPROCESSED\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 198, "end_line": 201, "size": 4, 
"parent_context": "class_definition", "content": "def convert(\n        self, value: 
t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        return 
value"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 203, "end_line": 204, "size": 2, 
"parent_context": "class_definition", "content": "def __repr__(self) -> str:\n        
return \"UNPROCESSED\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 207, "end_line": 230, "size": 24, "parent_context": 
"", "content": "class StringParamType(ParamType):\n    name = \"text\"\n\n    def 
convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n  
) -> t.Any:\n        if isinstance(value, bytes):\n            enc = 
_get_argv_encoding()\n            try:\n                value = value.decode(enc)\n   
except UnicodeError:\n                fs_enc = sys.getfilesystemencoding()\n          
if fs_enc != enc:\n                    try:\n                        value = 
value.decode(fs_enc)\n                    except UnicodeError:\n                      
value = value.decode(\"utf-8\", \"replace\")\n                else:\n                 
value = value.decode(\"utf-8\", \"replace\")\n            return value\n        return
str(value)\n\n    def __repr__(self) -> str:\n        return \"STRING\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 210, "end_line": 227, "size": 18, 
"parent_context": "class_definition", "content": "def convert(\n        self, value: 
t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        if 
isinstance(value, bytes):\n            enc = _get_argv_encoding()\n            try:\n 
value = value.decode(enc)\n            except UnicodeError:\n                fs_enc = 
sys.getfilesystemencoding()\n                if fs_enc != enc:\n                    
try:\n                        value = value.decode(fs_enc)\n                    except
UnicodeError:\n                        value = value.decode(\"utf-8\", \"replace\")\n 
else:\n                    value = value.decode(\"utf-8\", \"replace\")\n            
return value\n        return str(value)"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 229, "end_line": 230, "size": 2, 
"parent_context": "class_definition", "content": "def __repr__(self) -> str:\n        
return \"STRING\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 233, "end_line": 398, "size": 166, "parent_context":
"", "content": "class Choice(ParamType, t.Generic[ParamTypeValue]):\n    \"\"\"The 
choice type allows a value to be checked against a fixed set\n    of supported 
values.\n\n    You may pass any iterable value which will be converted to a tuple\n   
and thus will only be iterated once.\n\n    The resulting value will always be one of 
the originally passed choices.\n    See :meth:`normalize_choice` for more info on the 
mapping of strings\n    to choices. See :ref:`choice-opts` for an example.\n\n    
:param case_sensitive: Set to false to make choices case\n        insensitive. 
Defaults to true.\n\n    .. versionchanged:: 8.2.0\n        Non-``str`` ``choices`` 
are now supported. It can additionally be any\n        iterable. Before you were not 
recommended to pass anything but a list or\n        tuple.\n\n    .. versionadded:: 
8.2.0\n        Choice normalization can be overridden via :meth:`normalize_choice`.\n 
\"\"\"\n\n    name = \"choice\"\n\n    def __init__(\n        self, choices: 
cabc.Iterable[ParamTypeValue], case_sensitive: bool = True\n    ) -> None:\n        
self.choices: cabc.Sequence[ParamTypeValue] = tuple(choices)\n        
self.case_sensitive = case_sensitive\n\n    def to_info_dict(self) -> dict:\n        
info_dict = super().to_info_dict()\n        info_dict[\"choices\"] = self.choices\n   
info_dict[\"case_sensitive\"] = self.case_sensitive\n        return info_dict\n\n    
def _normalized_mapping(\n        self, ctx: Context | None = None\n    ) -> 
cabc.Mapping[ParamTypeValue, str]:\n        \"\"\"\n        Returns mapping where keys
are the original choices and the values are\n        the normalized values that are 
accepted via the command line.\n\n        This is a simple wrapper around 
:meth:`normalize_choice`, use that\n        instead which is supported.\n        
\"\"\"\n        return {\n            choice: self.normalize_choice(\n                
choice=choice,\n                ctx=ctx,\n            )\n            for choice in 
self.choices\n        }\n\n    def normalize_choice(self, choice: ParamTypeValue, ctx:
Context | None) -> str:\n        \"\"\"\n        Normalize a choice value, used to map
a passed string to a choice.\n        Each choice must have a unique normalized 
value.\n\n        By default uses :meth:`Context.token_normalize_func` and if not 
case\n        sensitive, convert it to a casefolded value.\n\n        .. 
versionadded:: 8.2.0\n        \"\"\"\n        normed_value = choice.name if 
isinstance(choice, enum.Enum) else str(choice)\n\n        if ctx is not None and 
ctx.token_normalize_func is not None:\n            normed_value = 
ctx.token_normalize_func(normed_value)\n\n        if not self.case_sensitive:\n       
normed_value = normed_value.casefold()\n\n        return normed_value\n\n    def 
get_metavar(self, param: Parameter, ctx: Context) -> str | None:\n        if 
param.param_type_name == \"option\" and not param.show_choices:  # type: ignore\n     
choice_metavars = [\n                convert_type(type(choice)).name.upper() for 
choice in self.choices\n            ]\n            choices_str = 
\"|\".join([*dict.fromkeys(choice_metavars)])\n        else:\n            choices_str 
= \"|\".join(\n                \n            )\n\n        # Use curly braces to 
indicate a required argument.\n        if param.required and param.param_type_name == 
\"argument\":\n            return f\"{{{choices_str}}}\"\n\n        # Use square 
braces to indicate an option or optional argument.\n        return 
f\"[{choices_str}]\"\n\n    def get_missing_message(self, param: Parameter, ctx: 
Context | None) -> str:\n        \"\"\"\n        Message shown when no choice is 
passed.\n\n        .. versionchanged:: 8.2.0 Added ``ctx`` argument.\n        \"\"\"\n
return _(\"Choose from:\\n\\t{choices}\").format(\n            
choices=\",\\n\\t\".join(self._normalized_mapping(ctx=ctx).values())\n        )\n\n   
def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | 
None\n    ) -> ParamTypeValue:\n        \"\"\"\n        For a given value from the 
parser, normalize it and find its\n        matching normalized value in the list of 
choices. Then return the\n        matched \"original\" choice.\n        \"\"\"\n      
normed_value = self.normalize_choice(choice=value, ctx=ctx)\n        
normalized_mapping = self._normalized_mapping(ctx=ctx)\n\n        try:\n            
return next(\n                original\n                for original, normalized in 
normalized_mapping.items()\n                if normalized == normed_value\n           
)\n        except StopIteration:\n            self.fail(\n                
self.get_invalid_choice_message(value=value, ctx=ctx),\n                param=param,\n
ctx=ctx,\n            )\n\n    def get_invalid_choice_message(self, value: t.Any, ctx:
Context | None) -> str:\n        \"\"\"Get the error message when the given choice is 
invalid.\n\n        :param value: The invalid value.\n\n        .. versionadded:: 
8.2\n        \"\"\"\n        choices_str = \", \".join(map(repr, 
self._normalized_mapping(ctx=ctx).values()))\n        return ngettext(\n            
\"{value!r} is not {choice}.\",\n            \"{value!r} is not one of {choices}.\",\n
len(self.choices),\n        ).format(value=value, choice=choices_str, 
choices=choices_str)\n\n    def __repr__(self) -> str:\n        return 
f\"Choice({list(self.choices)})\"\n\n    def shell_complete(\n        self, ctx: 
Context, param: Parameter, incomplete: str\n    ) -> list[CompletionItem]:\n        
\"\"\"Complete choices that start with the incomplete value.\n\n        :param ctx: 
Invocation context for this command.\n        :param param: The parameter that is 
requesting completion.\n        :param incomplete: Value being completed. May be 
empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        from 
click.shell_completion import CompletionItem\n\n        str_choices = map(str, 
self.choices)\n\n        if self.case_sensitive:\n            matched = (c for c in 
str_choices if c.startswith(incomplete))\n        else:\n            incomplete = 
incomplete.lower()\n            matched = (c for c in str_choices if 
c.lower().startswith(incomplete))\n\n        return [CompletionItem(c) for c in 
matched]"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 258, "end_line": 262, "size": 5, 
"parent_context": "class_definition", "content": "def __init__(\n        self, 
choices: cabc.Iterable[ParamTypeValue], case_sensitive: bool = True\n    ) -> None:\n 
self.choices: cabc.Sequence[ParamTypeValue] = tuple(choices)\n        
self.case_sensitive = case_sensitive"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 264, "end_line": 268, "size": 5, 
"parent_context": "class_definition", "content": "def to_info_dict(self) -> dict:\n   
info_dict = super().to_info_dict()\n        info_dict[\"choices\"] = self.choices\n   
info_dict[\"case_sensitive\"] = self.case_sensitive\n        return info_dict"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 270, "end_line": 286, "size": 17, 
"parent_context": "class_definition", "content": "def _normalized_mapping(\n        
self, ctx: Context | None = None\n    ) -> cabc.Mapping[ParamTypeValue, str]:\n       
\"\"\"\n        Returns mapping where keys are the original choices and the values 
are\n        the normalized values that are accepted via the command line.\n\n        
This is a simple wrapper around :meth:`normalize_choice`, use that\n        instead 
which is supported.\n        \"\"\"\n        return {\n            choice: 
self.normalize_choice(\n                choice=choice,\n                ctx=ctx,\n    
)\n            for choice in self.choices\n        }"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 288, "end_line": 306, "size": 19, 
"parent_context": "class_definition", "content": "def normalize_choice(self, choice: 
ParamTypeValue, ctx: Context | None) -> str:\n        \"\"\"\n        Normalize a 
choice value, used to map a passed string to a choice.\n        Each choice must have 
a unique normalized value.\n\n        By default uses 
:meth:`Context.token_normalize_func` and if not case\n        sensitive, convert it to
a casefolded value.\n\n        .. versionadded:: 8.2.0\n        \"\"\"\n        
normed_value = choice.name if isinstance(choice, enum.Enum) else str(choice)\n\n      
if ctx is not None and ctx.token_normalize_func is not None:\n            normed_value
= ctx.token_normalize_func(normed_value)\n\n        if not self.case_sensitive:\n     
normed_value = normed_value.casefold()\n\n        return normed_value"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 308, "end_line": 324, "size": 17, 
"parent_context": "class_definition", "content": "def get_metavar(self, param: 
Parameter, ctx: Context) -> str | None:\n        if param.param_type_name == 
\"option\" and not param.show_choices:  # type: ignore\n            choice_metavars = 
[\n                convert_type(type(choice)).name.upper() for choice in 
self.choices\n            ]\n            choices_str = 
\"|\".join([*dict.fromkeys(choice_metavars)])\n        else:\n            choices_str 
= \"|\".join(\n                \n            )\n\n        # Use curly braces to 
indicate a required argument.\n        if param.required and param.param_type_name == 
\"argument\":\n            return f\"{{{choices_str}}}\"\n\n        # Use square 
braces to indicate an option or optional argument.\n        return 
f\"[{choices_str}]\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 326, "end_line": 334, "size": 9, 
"parent_context": "class_definition", "content": "def get_missing_message(self, param:
Parameter, ctx: Context | None) -> str:\n        \"\"\"\n        Message shown when no
choice is passed.\n\n        .. versionchanged:: 8.2.0 Added ``ctx`` argument.\n      
\"\"\"\n        return _(\"Choose from:\\n\\t{choices}\").format(\n            
choices=\",\\n\\t\".join(self._normalized_mapping(ctx=ctx).values())\n        )"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 336, "end_line": 358, "size": 23, 
"parent_context": "class_definition", "content": "def convert(\n        self, value: 
t.Any, param: Parameter | None, ctx: Context | None\n    ) -> ParamTypeValue:\n       
\"\"\"\n        For a given value from the parser, normalize it and find its\n        
matching normalized value in the list of choices. Then return the\n        matched 
\"original\" choice.\n        \"\"\"\n        normed_value = 
self.normalize_choice(choice=value, ctx=ctx)\n        normalized_mapping = 
self._normalized_mapping(ctx=ctx)\n\n        try:\n            return next(\n         
original\n                for original, normalized in normalized_mapping.items()\n    
if normalized == normed_value\n            )\n        except StopIteration:\n         
self.fail(\n                self.get_invalid_choice_message(value=value, ctx=ctx),\n  
param=param,\n                ctx=ctx,\n            )"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 360, "end_line": 372, "size": 13, 
"parent_context": "class_definition", "content": "def get_invalid_choice_message(self,
value: t.Any, ctx: Context | None) -> str:\n        \"\"\"Get the error message when 
the given choice is invalid.\n\n        :param value: The invalid value.\n\n        ..
versionadded:: 8.2\n        \"\"\"\n        choices_str = \", \".join(map(repr, 
self._normalized_mapping(ctx=ctx).values()))\n        return ngettext(\n            
\"{value!r} is not {choice}.\",\n            \"{value!r} is not one of {choices}.\",\n
len(self.choices),\n        ).format(value=value, choice=choices_str, 
choices=choices_str)"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 374, "end_line": 375, "size": 2, 
"parent_context": "class_definition", "content": "def __repr__(self) -> str:\n        
return f\"Choice({list(self.choices)})\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 377, "end_line": 398, "size": 22, 
"parent_context": "class_definition", "content": "def shell_complete(\n        self, 
ctx: Context, param: Parameter, incomplete: str\n    ) -> list[CompletionItem]:\n     
\"\"\"Complete choices that start with the incomplete value.\n\n        :param ctx: 
Invocation context for this command.\n        :param param: The parameter that is 
requesting completion.\n        :param incomplete: Value being completed. May be 
empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        from 
click.shell_completion import CompletionItem\n\n        str_choices = map(str, 
self.choices)\n\n        if self.case_sensitive:\n            matched = (c for c in 
str_choices if c.startswith(incomplete))\n        else:\n            incomplete = 
incomplete.lower()\n            matched = (c for c in str_choices if 
c.lower().startswith(incomplete))\n\n        return [CompletionItem(c) for c in 
matched]"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 401, "end_line": 469, "size": 69, "parent_context": 
"", "content": "class DateTime(ParamType):\n    \"\"\"The DateTime type converts date 
strings into `datetime` objects.\n\n    The format strings which are checked are 
configurable, but default to some\n    common (non-timezone aware) ISO 8601 
formats.\n\n    When specifying *DateTime* formats, you should only pass a list or a 
tuple.\n    Other iterables, like generators, may lead to surprising results.\n\n    
The format strings are processed using ``datetime.strptime``, and this\n    
consequently defines the format strings which are allowed.\n\n    Parsing is tried 
using each format, in order, and the first format which\n    parses successfully is 
used.\n\n    :param formats: A list or tuple of date format strings, in the order in\n
which they should be tried. Defaults to\n                    ``'%Y-%m-%d'``, 
``'%Y-%m-%dT%H:%M:%S'``,\n                    ``'%Y-%m-%d %H:%M:%S'``.\n    \"\"\"\n\n
name = \"datetime\"\n\n    def __init__(self, formats: cabc.Sequence | None = None):\n
self.formats: cabc.Sequence = formats or [\n            \"%Y-%m-%d\",\n            
\"%Y-%m-%dT%H:%M:%S\",\n            \"%Y-%m-%d %H:%M:%S\",\n        ]\n\n    def 
to_info_dict(self) -> dict:\n        info_dict = super().to_info_dict()\n        
info_dict[\"formats\"] = self.formats\n        return info_dict\n\n    def 
get_metavar(self, param: Parameter, ctx: Context) -> str | None:\n        return 
f\"[{'|'.join(self.formats)}]\"\n\n    def _try_to_convert_date(self, value: t.Any, 
format: str) -> datetime | None:\n        try:\n            return 
datetime.strptime(value, format)\n        except ValueError:\n            return 
None\n\n    def convert(\n        self, value: t.Any, param: Parameter | None, ctx: 
Context | None\n    ) -> t.Any:\n        if isinstance(value, datetime):\n            
return value\n\n        for format in self.formats:\n            converted = 
self._try_to_convert_date(value, format)\n\n            if converted is not None:\n   
return converted\n\n        formats_str = \", \".join(map(repr, self.formats))\n      
self.fail(\n            ngettext(\n                \"{value!r} does not match the 
format {format}.\",\n                \"{value!r} does not match the formats 
{formats}.\",\n                len(self.formats),\n            ).format(value=value, 
format=formats_str, formats=formats_str),\n            param,\n            ctx,\n     
)\n\n    def __repr__(self) -> str:\n        return \"DateTime\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 424, "end_line": 429, "size": 6, 
"parent_context": "class_definition", "content": "def __init__(self, formats: 
cabc.Sequence | None = None):\n        self.formats: cabc.Sequence = formats or [\n   
\"%Y-%m-%d\",\n            \"%Y-%m-%dT%H:%M:%S\",\n            \"%Y-%m-%d 
%H:%M:%S\",\n        ]"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 431, "end_line": 434, "size": 4, 
"parent_context": "class_definition", "content": "def to_info_dict(self) -> dict:\n   
info_dict = super().to_info_dict()\n        info_dict[\"formats\"] = self.formats\n   
return info_dict"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 436, "end_line": 437, "size": 2, 
"parent_context": "class_definition", "content": "def get_metavar(self, param: 
Parameter, ctx: Context) -> str | None:\n        return 
f\"[{'|'.join(self.formats)}]\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 439, "end_line": 443, "size": 5, 
"parent_context": "class_definition", "content": "def _try_to_convert_date(self, 
value: t.Any, format: str) -> datetime | None:\n        try:\n            return 
datetime.strptime(value, format)\n        except ValueError:\n            return 
None"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 445, "end_line": 466, "size": 22, 
"parent_context": "class_definition", "content": "def convert(\n        self, value: 
t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        if 
isinstance(value, datetime):\n            return value\n\n        for format in 
self.formats:\n            converted = self._try_to_convert_date(value, format)\n\n   
if converted is not None:\n                return converted\n\n        formats_str = 
\", \".join(map(repr, self.formats))\n        self.fail(\n            ngettext(\n     
\"{value!r} does not match the format {format}.\",\n                \"{value!r} does 
not match the formats {formats}.\",\n                len(self.formats),\n            
).format(value=value, format=formats_str, formats=formats_str),\n            param,\n 
ctx,\n        )"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 468, "end_line": 469, "size": 2, 
"parent_context": "class_definition", "content": "def __repr__(self) -> str:\n        
return \"DateTime\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 472, "end_line": 487, "size": 16, "parent_context": 
"", "content": "class _NumberParamTypeBase(ParamType):\n    _number_class: 
t.ClassVar[type]\n\n    def convert(\n        self, value: t.Any, param: Parameter | 
None, ctx: Context | None\n    ) -> t.Any:\n        try:\n            return 
self._number_class(value)\n        except ValueError:\n            self.fail(\n       
_(\"{value!r} is not a valid {number_type}.\").format(\n                    
value=value, number_type=self.name\n                ),\n                param,\n      
ctx,\n            )"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 475, "end_line": 487, "size": 13, 
"parent_context": "class_definition", "content": "def convert(\n        self, value: 
t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        try:\n  
return self._number_class(value)\n        except ValueError:\n            self.fail(\n
_(\"{value!r} is not a valid {number_type}.\").format(\n                    
value=value, number_type=self.name\n                ),\n                param,\n      
ctx,\n            )"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 490, "end_line": 573, "size": 84, "parent_context": 
"", "content": "class _NumberRangeBase(_NumberParamTypeBase):\n    def __init__(\n    
self,\n        min: float | None = None,\n        max: float | None = None,\n        
min_open: bool = False,\n        max_open: bool = False,\n        clamp: bool = 
False,\n    ) -> None:\n        self.min = min\n        self.max = max\n        
self.min_open = min_open\n        self.max_open = max_open\n        self.clamp = 
clamp\n\n    def to_info_dict(self) -> dict:\n        info_dict = 
super().to_info_dict()\n        info_dict.update(\n            min=self.min,\n        
max=self.max,\n            min_open=self.min_open,\n            
max_open=self.max_open,\n            clamp=self.clamp,\n        )\n        return 
info_dict\n\n    def convert(\n        self, value: t.Any, param: Parameter | None, 
ctx: Context | None\n    ) -> t.Any:\n        import operator\n\n        rv = 
super().convert(value, param, ctx)\n        lt_min: bool = self.min is not None and 
(\n            operator.le if self.min_open else operator.lt\n        )(rv, 
self.min)\n        gt_max: bool = self.max is not None and (\n            operator.ge 
if self.max_open else operator.gt\n        )(rv, self.max)\n\n        if self.clamp:\n
if lt_min:\n                return self._clamp(self.min, 1, self.min_open)  # type: 
ignore\n\n            if gt_max:\n                return self._clamp(self.max, -1, 
self.max_open)  # type: ignore\n\n        if lt_min or gt_max:\n            
self.fail(\n                _(\"{value} is not in the range {range}.\").format(\n     
value=rv, range=self._describe_range()\n                ),\n                param,\n  
ctx,\n            )\n\n        return rv\n\n    def _clamp(self, bound: float, dir: 
t.Literal[1, -1], open: bool) -> float:\n        \"\"\"Find the valid value to clamp 
to bound in the given\n        direction.\n\n        :param bound: The boundary 
value.\n        :param dir: 1 or -1 indicating the direction to move.\n        :param 
open: If true, the range does not include the bound.\n        \"\"\"\n        raise 
NotImplementedError\n\n    def _describe_range(self) -> str:\n        \"\"\"Describe 
the range for use in help text.\"\"\"\n        if self.min is None:\n            op = 
\"<\" if self.max_open else \"<=\"\n            return f\"x{op}{self.max}\"\n\n       
if self.max is None:\n            op = \">\" if self.min_open else \">=\"\n           
return f\"x{op}{self.min}\"\n\n        lop = \"<\" if self.min_open else \"<=\"\n     
rop = \"<\" if self.max_open else \"<=\"\n        return 
f\"{self.min}{lop}x{rop}{self.max}\"\n\n    def __repr__(self) -> str:\n        clamp 
= \" clamped\" if self.clamp else \"\"\n        return f\"<{type(self).__name__} 
{self._describe_range()}{clamp}>\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 491, "end_line": 503, "size": 13, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
min: float | None = None,\n        max: float | None = None,\n        min_open: bool =
False,\n        max_open: bool = False,\n        clamp: bool = False,\n    ) -> 
None:\n        self.min = min\n        self.max = max\n        self.min_open = 
min_open\n        self.max_open = max_open\n        self.clamp = clamp"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 505, "end_line": 514, "size": 10, 
"parent_context": "class_definition", "content": "def to_info_dict(self) -> dict:\n   
info_dict = super().to_info_dict()\n        info_dict.update(\n            
min=self.min,\n            max=self.max,\n            min_open=self.min_open,\n       
max_open=self.max_open,\n            clamp=self.clamp,\n        )\n        return 
info_dict"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 516, "end_line": 545, "size": 30, 
"parent_context": "class_definition", "content": "def convert(\n        self, value: 
t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        import 
operator\n\n        rv = super().convert(value, param, ctx)\n        lt_min: bool = 
self.min is not None and (\n            operator.le if self.min_open else 
operator.lt\n        )(rv, self.min)\n        gt_max: bool = self.max is not None and 
(\n            operator.ge if self.max_open else operator.gt\n        )(rv, 
self.max)\n\n        if self.clamp:\n            if lt_min:\n                return 
self._clamp(self.min, 1, self.min_open)  # type: ignore\n\n            if gt_max:\n   
return self._clamp(self.max, -1, self.max_open)  # type: ignore\n\n        if lt_min 
or gt_max:\n            self.fail(\n                _(\"{value} is not in the range 
{range}.\").format(\n                    value=rv, range=self._describe_range()\n     
),\n                param,\n                ctx,\n            )\n\n        return rv"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 547, "end_line": 555, "size": 9, 
"parent_context": "class_definition", "content": "def _clamp(self, bound: float, dir: 
t.Literal[1, -1], open: bool) -> float:\n        \"\"\"Find the valid value to clamp 
to bound in the given\n        direction.\n\n        :param bound: The boundary 
value.\n        :param dir: 1 or -1 indicating the direction to move.\n        :param 
open: If true, the range does not include the bound.\n        \"\"\"\n        raise 
NotImplementedError"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 557, "end_line": 569, "size": 13, 
"parent_context": "class_definition", "content": "def _describe_range(self) -> str:\n 
\"\"\"Describe the range for use in help text.\"\"\"\n        if self.min is None:\n  
op = \"<\" if self.max_open else \"<=\"\n            return f\"x{op}{self.max}\"\n\n  
if self.max is None:\n            op = \">\" if self.min_open else \">=\"\n           
return f\"x{op}{self.min}\"\n\n        lop = \"<\" if self.min_open else \"<=\"\n     
rop = \"<\" if self.max_open else \"<=\"\n        return 
f\"{self.min}{lop}x{rop}{self.max}\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 571, "end_line": 573, "size": 3, 
"parent_context": "class_definition", "content": "def __repr__(self) -> str:\n        
clamp = \" clamped\" if self.clamp else \"\"\n        return f\"<{type(self).__name__}
{self._describe_range()}{clamp}>\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 576, "end_line": 581, "size": 6, "parent_context": 
"", "content": "class IntParamType(_NumberParamTypeBase):\n    name = \"integer\"\n   
_number_class = int\n\n    def __repr__(self) -> str:\n        return \"INT\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 580, "end_line": 581, "size": 2, 
"parent_context": "class_definition", "content": "def __repr__(self) -> str:\n        
return \"INT\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 584, "end_line": 607, "size": 24, "parent_context": 
"", "content": "class IntRange(_NumberRangeBase, IntParamType):\n    \"\"\"Restrict an
:data:`click.INT` value to a range of accepted\n    values. See :ref:`ranges`.\n\n    
If ``min`` or ``max`` are not passed, any value is accepted in that\n    direction. If
``min_open`` or ``max_open`` are enabled, the\n    corresponding boundary is not 
included in the range.\n\n    If ``clamp`` is enabled, a value outside the range is 
clamped to the\n    boundary instead of failing.\n\n    .. versionchanged:: 8.0\n     
Added the ``min_open`` and ``max_open`` parameters.\n    \"\"\"\n\n    name = 
\"integer range\"\n\n    def _clamp(  # type: ignore\n        self, bound: int, dir: 
t.Literal[1, -1], open: bool\n    ) -> int:\n        if not open:\n            return 
bound\n\n        return bound + dir"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 601, "end_line": 607, "size": 7, 
"parent_context": "class_definition", "content": "def _clamp(  # type: ignore\n       
self, bound: int, dir: t.Literal[1, -1], open: bool\n    ) -> int:\n        if not 
open:\n            return bound\n\n        return bound + dir"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 610, "end_line": 615, "size": 6, "parent_context": 
"", "content": "class FloatParamType(_NumberParamTypeBase):\n    name = \"float\"\n   
_number_class = float\n\n    def __repr__(self) -> str:\n        return \"FLOAT\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 614, "end_line": 615, "size": 2, 
"parent_context": "class_definition", "content": "def __repr__(self) -> str:\n        
return \"FLOAT\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 618, "end_line": 658, "size": 41, "parent_context": 
"", "content": "class FloatRange(_NumberRangeBase, FloatParamType):\n    
\"\"\"Restrict a :data:`click.FLOAT` value to a range of accepted\n    values. See 
:ref:`ranges`.\n\n    If ``min`` or ``max`` are not passed, any value is accepted in 
that\n    direction. If ``min_open`` or ``max_open`` are enabled, the\n    
corresponding boundary is not included in the range.\n\n    If ``clamp`` is enabled, a
value outside the range is clamped to the\n    boundary instead of failing. This is 
not supported if either\n    boundary is marked ``open``.\n\n    .. versionchanged:: 
8.0\n        Added the ``min_open`` and ``max_open`` parameters.\n    \"\"\"\n\n    
name = \"float range\"\n\n    def __init__(\n        self,\n        min: float | None 
= None,\n        max: float | None = None,\n        min_open: bool = False,\n        
max_open: bool = False,\n        clamp: bool = False,\n    ) -> None:\n        
super().__init__(\n            min=min, max=max, min_open=min_open, max_open=max_open,
clamp=clamp\n        )\n\n        if (min_open or max_open) and clamp:\n            
raise TypeError(\"Clamping is not supported for open bounds.\")\n\n    def 
_clamp(self, bound: float, dir: t.Literal[1, -1], open: bool) -> float:\n        if 
not open:\n            return bound\n\n        # Could use math.nextafter here, but 
clamping an\n        # open float range doesn't seem to be particularly useful. It's\n
# left up to the user to write a callback to do it if needed.\n        raise 
RuntimeError(\"Clamping is not supported for open bounds.\")"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 636, "end_line": 649, "size": 14, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
min: float | None = None,\n        max: float | None = None,\n        min_open: bool =
False,\n        max_open: bool = False,\n        clamp: bool = False,\n    ) -> 
None:\n        super().__init__(\n            min=min, max=max, min_open=min_open, 
max_open=max_open, clamp=clamp\n        )\n\n        if (min_open or max_open) and 
clamp:\n            raise TypeError(\"Clamping is not supported for open bounds.\")"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 651, "end_line": 658, "size": 8, 
"parent_context": "class_definition", "content": "def _clamp(self, bound: float, dir: 
t.Literal[1, -1], open: bool) -> float:\n        if not open:\n            return 
bound\n\n        # Could use math.nextafter here, but clamping an\n        # open 
float range doesn't seem to be particularly useful. It's\n        # left up to the 
user to write a callback to do it if needed.\n        raise RuntimeError(\"Clamping is
not supported for open bounds.\")"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 661, "end_line": 727, "size": 67, "parent_context": 
"", "content": "class BoolParamType(ParamType):\n    name = \"boolean\"\n\n    
bool_states: dict = {\n        \"1\": True,\n        \"0\": False,\n        \"yes\": 
True,\n        \"no\": False,\n        \"true\": True,\n        \"false\": False,\n   
\"on\": True,\n        \"off\": False,\n        \"t\": True,\n        \"f\": False,\n 
\"y\": True,\n        \"n\": False,\n        # Absence of value is considered False.\n
\"\": False,\n    }\n    \"\"\"A mapping of string values to boolean states.\n\n    
Mapping is inspired by :py:attr:`configparser.ConfigParser.BOOLEAN_STATES`\n    and 
extends it.\n\n    .. caution::\n        String values are lower-cased, as the 
``str_to_bool`` comparison function\n        below is case-insensitive.\n\n    .. 
warning::\n        The mapping is not exhaustive, and does not cover all possible 
boolean strings\n        representations. It will remains as it is to avoid endless 
bikeshedding.\n\n        Future work my be considered to make this mapping 
user-configurable from public\n        API.\n    \"\"\"\n\n    @staticmethod\n    def 
str_to_bool(value: str | bool) -> bool | None:\n        \"\"\"Convert a string to a 
boolean value.\n\n        If the value is already a boolean, it is returned as-is. If 
the value is a\n        string, it is stripped of whitespaces and lower-cased, then 
checked against\n        the known boolean states pre-defined in the 
`BoolParamType.bool_states` mapping\n        above.\n\n        Returns `None` if the 
value does not match any known boolean state.\n        \"\"\"\n        if 
isinstance(value, bool):\n            return value\n        return 
BoolParamType.bool_states.get(value.strip().lower())\n\n    def convert(\n        
self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> bool:\n    
normalized = self.str_to_bool(value)\n        if normalized is None:\n            
self.fail(\n                _(\n                    \"{value!r} is not a valid 
boolean. Recognized values: {states}\"\n                ).format(value=value, 
states=\", \".join(sorted(self.bool_states))),\n                param,\n              
ctx,\n            )\n        return normalized\n\n    def __repr__(self) -> str:\n    
return \"BOOL\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 697, "end_line": 710, "size": 14, 
"parent_context": "class_definition", "content": "@staticmethod\n    def 
str_to_bool(value: str | bool) -> bool | None:\n        \"\"\"Convert a string to a 
boolean value.\n\n        If the value is already a boolean, it is returned as-is. If 
the value is a\n        string, it is stripped of whitespaces and lower-cased, then 
checked against\n        the known boolean states pre-defined in the 
`BoolParamType.bool_states` mapping\n        above.\n\n        Returns `None` if the 
value does not match any known boolean state.\n        \"\"\"\n        if 
isinstance(value, bool):\n            return value\n        return 
BoolParamType.bool_states.get(value.strip().lower())"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 698, "end_line": 710, "size": 13, 
"parent_context": "decorated_definition", "content": "def str_to_bool(value: str | 
bool) -> bool | None:\n        \"\"\"Convert a string to a boolean value.\n\n        
If the value is already a boolean, it is returned as-is. If the value is a\n        
string, it is stripped of whitespaces and lower-cased, then checked against\n        
the known boolean states pre-defined in the `BoolParamType.bool_states` mapping\n     
above.\n\n        Returns `None` if the value does not match any known boolean 
state.\n        \"\"\"\n        if isinstance(value, bool):\n            return 
value\n        return BoolParamType.bool_states.get(value.strip().lower())"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 712, "end_line": 724, "size": 13, 
"parent_context": "class_definition", "content": "def convert(\n        self, value: 
t.Any, param: Parameter | None, ctx: Context | None\n    ) -> bool:\n        
normalized = self.str_to_bool(value)\n        if normalized is None:\n            
self.fail(\n                _(\n                    \"{value!r} is not a valid 
boolean. Recognized values: {states}\"\n                ).format(value=value, 
states=\", \".join(sorted(self.bool_states))),\n                param,\n              
ctx,\n            )\n        return normalized"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 726, "end_line": 727, "size": 2, 
"parent_context": "class_definition", "content": "def __repr__(self) -> str:\n        
return \"BOOL\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 730, "end_line": 751, "size": 22, "parent_context": 
"", "content": "class UUIDParameterType(ParamType):\n    name = \"uuid\"\n\n    def 
convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n  
) -> t.Any:\n        import uuid\n\n        if isinstance(value, uuid.UUID):\n        
return value\n\n        value = value.strip()\n\n        try:\n            return 
uuid.UUID(value)\n        except ValueError:\n            self.fail(\n                
_(\"{value!r} is not a valid UUID.\").format(value=value), param, ctx\n            
)\n\n    def __repr__(self) -> str:\n        return \"UUID\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 733, "end_line": 748, "size": 16, 
"parent_context": "class_definition", "content": "def convert(\n        self, value: 
t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        import 
uuid\n\n        if isinstance(value, uuid.UUID):\n            return value\n\n        
value = value.strip()\n\n        try:\n            return uuid.UUID(value)\n        
except ValueError:\n            self.fail(\n                _(\"{value!r} is not a 
valid UUID.\").format(value=value), param, ctx\n            )"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 750, "end_line": 751, "size": 2, 
"parent_context": "class_definition", "content": "def __repr__(self) -> str:\n        
return \"UUID\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 754, "end_line": 872, "size": 119, "parent_context":
"", "content": "class File(ParamType):\n    \"\"\"Declares a parameter to be a file 
for reading or writing.  The file\n    is automatically closed once the context tears 
down (after the command\n    finished working).\n\n    Files can be opened for reading
or writing.  The special value ``-``\n    indicates stdin or stdout depending on the 
mode.\n\n    By default, the file is opened for reading text data, but it can also 
be\n    opened in binary mode or for writing.  The encoding parameter can be used\n   
to force a specific encoding.\n\n    The `lazy` flag controls if the file should be 
opened immediately or upon\n    first IO. The default is to be non-lazy for standard 
input and output\n    streams as well as files opened for reading, `lazy` otherwise. 
When opening a\n    file lazily for reading, it is still opened temporarily for 
validation, but\n    will not be held open until first IO. lazy is mainly useful when 
opening\n    for writing to avoid creating the file until it is needed.\n\n    Files 
can also be opened atomically in which case all writes go into a\n    separate file in
the same folder and upon completion the file will\n    be moved over to the original 
location.  This is useful if a file\n    regularly read by other users is 
modified.\n\n    See :ref:`file-args` for more information.\n\n    .. versionchanged::
2.0\n        Added the ``atomic`` parameter.\n    \"\"\"\n\n    name = \"filename\"\n 
envvar_list_splitter: t.ClassVar = os.path.pathsep\n\n    def __init__(\n        
self,\n        mode: str = \"r\",\n        encoding: str | None = None,\n        
errors: str | None = \"strict\",\n        lazy: bool | None = None,\n        atomic: 
bool = False,\n    ) -> None:\n        self.mode = mode\n        self.encoding = 
encoding\n        self.errors = errors\n        self.lazy = lazy\n        self.atomic 
= atomic\n\n    def to_info_dict(self) -> dict:\n        info_dict = 
super().to_info_dict()\n        info_dict.update(mode=self.mode, 
encoding=self.encoding)\n        return info_dict\n\n    def resolve_lazy_flag(self, 
value: str | os.PathLike) -> bool:\n        if self.lazy is not None:\n            
return self.lazy\n        if os.fspath(value) == \"-\":\n            return False\n   
elif \"w\" in self.mode:\n            return True\n        return False\n\n    def 
convert(\n        self,\n        value: str | os.PathLike | t.IO,\n        param: 
Parameter | None,\n        ctx: Context | None,\n    ) -> t.IO:\n        if 
_is_file_like(value):\n            return value\n\n        value = t.cast(\"str | 
os.PathLike\", value)\n\n        try:\n            lazy = 
self.resolve_lazy_flag(value)\n\n            if lazy:\n                lf = 
LazyFile(\n                    value, self.mode, self.encoding, self.errors, 
atomic=self.atomic\n                )\n\n                if ctx is not None:\n        
ctx.call_on_close(lf.close_intelligently)\n\n                return t.cast(\"t.IO\", 
lf)\n\n            f, should_close = open_stream(\n                value, self.mode, 
self.encoding, self.errors, atomic=self.atomic\n            )\n\n            # If a 
context is provided, we automatically close the file\n            # at the end of the 
context execution (or flush out).  If a\n            # context does not exist, it's 
the caller's responsibility to\n            # properly close the file.  This for 
instance happens when the\n            # type is used with prompts.\n            if 
ctx is not None:\n                if should_close:\n                    
ctx.call_on_close(safecall(f.close))\n                else:\n                    
ctx.call_on_close(safecall(f.flush))\n\n            return f\n        except OSError 
as e:\n            self.fail(f\"'{format_filename(value)}': {e.strerror}\", param, 
ctx)\n\n    def shell_complete(\n        self, ctx: Context, param: Parameter, 
incomplete: str\n    ) -> list[CompletionItem]:\n        \"\"\"Return a special 
completion marker that tells the completion\n        system to use the shell to 
provide file path completions.\n\n        :param ctx: Invocation context for this 
command.\n        :param param: The parameter that is requesting completion.\n        
:param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 
8.0\n        \"\"\"\n        from click.shell_completion import CompletionItem\n\n    
return [CompletionItem(incomplete, type=\"file\")]"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 787, "end_line": 799, "size": 13, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
mode: str = \"r\",\n        encoding: str | None = None,\n        errors: str | None =
\"strict\",\n        lazy: bool | None = None,\n        atomic: bool = False,\n    ) 
-> None:\n        self.mode = mode\n        self.encoding = encoding\n        
self.errors = errors\n        self.lazy = lazy\n        self.atomic = atomic"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 801, "end_line": 804, "size": 4, 
"parent_context": "class_definition", "content": "def to_info_dict(self) -> dict:\n   
info_dict = super().to_info_dict()\n        info_dict.update(mode=self.mode, 
encoding=self.encoding)\n        return info_dict"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 806, "end_line": 813, "size": 8, 
"parent_context": "class_definition", "content": "def resolve_lazy_flag(self, value: 
str | os.PathLike) -> bool:\n        if self.lazy is not None:\n            return 
self.lazy\n        if os.fspath(value) == \"-\":\n            return False\n        
elif \"w\" in self.mode:\n            return True\n        return False"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 815, "end_line": 856, "size": 42, 
"parent_context": "class_definition", "content": "def convert(\n        self,\n       
value: str | os.PathLike | t.IO,\n        param: Parameter | None,\n        ctx: 
Context | None,\n    ) -> t.IO:\n        if _is_file_like(value):\n            return 
value\n\n        value = t.cast(\"str | os.PathLike\", value)\n\n        try:\n       
lazy = self.resolve_lazy_flag(value)\n\n            if lazy:\n                lf = 
LazyFile(\n                    value, self.mode, self.encoding, self.errors, 
atomic=self.atomic\n                )\n\n                if ctx is not None:\n        
ctx.call_on_close(lf.close_intelligently)\n\n                return t.cast(\"t.IO\", 
lf)\n\n            f, should_close = open_stream(\n                value, self.mode, 
self.encoding, self.errors, atomic=self.atomic\n            )\n\n            # If a 
context is provided, we automatically close the file\n            # at the end of the 
context execution (or flush out).  If a\n            # context does not exist, it's 
the caller's responsibility to\n            # properly close the file.  This for 
instance happens when the\n            # type is used with prompts.\n            if 
ctx is not None:\n                if should_close:\n                    
ctx.call_on_close(safecall(f.close))\n                else:\n                    
ctx.call_on_close(safecall(f.flush))\n\n            return f\n        except OSError 
as e:\n            self.fail(f\"'{format_filename(value)}': {e.strerror}\", param, 
ctx)"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 858, "end_line": 872, "size": 15, 
"parent_context": "class_definition", "content": "def shell_complete(\n        self, 
ctx: Context, param: Parameter, incomplete: str\n    ) -> list[CompletionItem]:\n     
\"\"\"Return a special completion marker that tells the completion\n        system to 
use the shell to provide file path completions.\n\n        :param ctx: Invocation 
context for this command.\n        :param param: The parameter that is requesting 
completion.\n        :param incomplete: Value being completed. May be empty.\n\n      
.. versionadded:: 8.0\n        \"\"\"\n        from click.shell_completion import 
CompletionItem\n\n        return [CompletionItem(incomplete, type=\"file\")]"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 875, "end_line": 876, "size": 2, 
"parent_context": "", "content": "def _is_file_like(value: t.Any) -> 
te.TypeGuard[t.IO]:\n    return hasattr(value, \"read\") or hasattr(value, 
\"write\")"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 879, "end_line": 1057, "size": 179, 
"parent_context": "", "content": "class Path(ParamType):\n    \"\"\"The ``Path`` type 
is similar to the :class:`File` type, but\n    returns the filename instead of an open
file. Various checks can be\n    enabled to validate the type of file and 
permissions.\n\n    :param exists: The file or directory needs to exist for the value 
to\n        be valid. If this is not set to ``True``, and the file does not\n        
exist, then all further checks are silently skipped.\n    :param file_okay: Allow a 
file as a value.\n    :param dir_okay: Allow a directory as a value.\n    :param 
readable: if true, a readable check is performed.\n    :param writable: if true, a 
writable check is performed.\n    :param executable: if true, an executable check is 
performed.\n    :param resolve_path: Make the value absolute and resolve any\n        
symlinks. A ``~`` is not expanded, as this is supposed to be\n        done by the 
shell only.\n    :param allow_dash: Allow a single dash as a value, which indicates\n 
a standard stream (but does not open it). Use\n        :func:`~click.open_file` to 
handle opening this value.\n    :param path_type: Convert the incoming path value to 
this type. If\n        ``None``, keep Python's default, which is ``str``. Useful to\n 
convert to :class:`pathlib.Path`.\n\n    .. versionchanged:: 8.1\n        Added the 
``executable`` parameter.\n\n    .. versionchanged:: 8.0\n        Allow passing 
``path_type=pathlib.Path``.\n\n    .. versionchanged:: 6.0\n        Added the 
``allow_dash`` parameter.\n    \"\"\"\n\n    envvar_list_splitter: t.ClassVar = 
os.path.pathsep\n\n    def __init__(\n        self,\n        exists: bool = False,\n  
file_okay: bool = True,\n        dir_okay: bool = True,\n        writable: bool = 
False,\n        readable: bool = True,\n        resolve_path: bool = False,\n        
allow_dash: bool = False,\n        path_type: type | None = None,\n        executable:
bool = False,\n    ):\n        self.exists = exists\n        self.file_okay = 
file_okay\n        self.dir_okay = dir_okay\n        self.readable = readable\n       
self.writable = writable\n        self.executable = executable\n        
self.resolve_path = resolve_path\n        self.allow_dash = allow_dash\n        
self.type = path_type\n\n        if self.file_okay and not self.dir_okay:\n           
self.name: str = _(\"file\")\n        elif self.dir_okay and not self.file_okay:\n    
self.name = _(\"directory\")\n        else:\n            self.name = _(\"path\")\n\n  
def to_info_dict(self) -> dict:\n        info_dict = super().to_info_dict()\n        
info_dict.update(\n            exists=self.exists,\n            
file_okay=self.file_okay,\n            dir_okay=self.dir_okay,\n            
writable=self.writable,\n            readable=self.readable,\n            
allow_dash=self.allow_dash,\n        )\n        return info_dict\n\n    def 
coerce_path_result(\n        self, value: str | os.PathLike\n    ) -> str | bytes | 
os.PathLike:\n        if self.type is not None and not isinstance(value, self.type):\n
if self.type is str:\n                return os.fsdecode(value)\n            elif 
self.type is bytes:\n                return os.fsencode(value)\n            else:\n   
return t.cast(\"os.PathLike\", self.type(value))\n\n        return value\n\n    def 
convert(\n        self,\n        value: str | os.PathLike,\n        param: Parameter |
None,\n        ctx: Context | None,\n    ) -> str | bytes | os.PathLike:\n        rv =
value\n\n        is_dash = self.file_okay and self.allow_dash and rv in (b\"-\", 
\"-\")\n\n        if not is_dash:\n            if self.resolve_path:\n                
rv = os.path.realpath(rv)\n\n            try:\n                st = os.stat(rv)\n     
except OSError:\n                if not self.exists:\n                    return 
self.coerce_path_result(rv)\n                self.fail(\n                    
_(\"{name} {filename!r} does not exist.\").format(\n                        
name=self.name.title(), filename=format_filename(value)\n                    ),\n     
param,\n                    ctx,\n                )\n\n            if not 
self.file_okay and stat.S_ISREG(st.st_mode):\n                self.fail(\n            
_(\"{name} {filename!r} is a file.\").format(\n                        
name=self.name.title(), filename=format_filename(value)\n                    ),\n     
param,\n                    ctx,\n                )\n            if not self.dir_okay 
and stat.S_ISDIR(st.st_mode):\n                self.fail(\n                    
_(\"{name} {filename!r} is a directory.\").format(\n                        
name=self.name.title(), filename=format_filename(value)\n                    ),\n     
param,\n                    ctx,\n                )\n\n            if self.readable 
and not os.access(rv, os.R_OK):\n                self.fail(\n                    
_(\"{name} {filename!r} is not readable.\").format(\n                        
name=self.name.title(), filename=format_filename(value)\n                    ),\n     
param,\n                    ctx,\n                )\n\n            if self.writable 
and not os.access(rv, os.W_OK):\n                self.fail(\n                    
_(\"{name} {filename!r} is not writable.\").format(\n                        
name=self.name.title(), filename=format_filename(value)\n                    ),\n     
param,\n                    ctx,\n                )\n\n            if self.executable 
and not os.access(value, os.X_OK):\n                self.fail(\n                    
_(\"{name} {filename!r} is not executable.\").format(\n                        
name=self.name.title(), filename=format_filename(value)\n                    ),\n     
param,\n                    ctx,\n                )\n\n        return 
self.coerce_path_result(rv)\n\n    def shell_complete(\n        self, ctx: Context, 
param: Parameter, incomplete: str\n    ) -> list[CompletionItem]:\n        
\"\"\"Return a special completion marker that tells the completion\n        system to 
use the shell to provide path completions for only\n        directories or any 
paths.\n\n        :param ctx: Invocation context for this command.\n        :param 
param: The parameter that is requesting completion.\n        :param incomplete: Value 
being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n     
from click.shell_completion import CompletionItem\n\n        type = \"dir\" if 
self.dir_okay and not self.file_okay else \"file\"\n        return 
[CompletionItem(incomplete, type=type)]"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 914, "end_line": 941, "size": 28, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
exists: bool = False,\n        file_okay: bool = True,\n        dir_okay: bool = 
True,\n        writable: bool = False,\n        readable: bool = True,\n        
resolve_path: bool = False,\n        allow_dash: bool = False,\n        path_type: 
type | None = None,\n        executable: bool = False,\n    ):\n        self.exists = 
exists\n        self.file_okay = file_okay\n        self.dir_okay = dir_okay\n        
self.readable = readable\n        self.writable = writable\n        self.executable = 
executable\n        self.resolve_path = resolve_path\n        self.allow_dash = 
allow_dash\n        self.type = path_type\n\n        if self.file_okay and not 
self.dir_okay:\n            self.name: str = _(\"file\")\n        elif self.dir_okay 
and not self.file_okay:\n            self.name = _(\"directory\")\n        else:\n    
self.name = _(\"path\")"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 943, "end_line": 953, "size": 11, 
"parent_context": "class_definition", "content": "def to_info_dict(self) -> dict:\n   
info_dict = super().to_info_dict()\n        info_dict.update(\n            
exists=self.exists,\n            file_okay=self.file_okay,\n            
dir_okay=self.dir_okay,\n            writable=self.writable,\n            
readable=self.readable,\n            allow_dash=self.allow_dash,\n        )\n        
return info_dict"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 955, "end_line": 966, "size": 12, 
"parent_context": "class_definition", "content": "def coerce_path_result(\n        
self, value: str | os.PathLike\n    ) -> str | bytes | os.PathLike:\n        if 
self.type is not None and not isinstance(value, self.type):\n            if self.type 
is str:\n                return os.fsdecode(value)\n            elif self.type is 
bytes:\n                return os.fsencode(value)\n            else:\n                
return t.cast(\"os.PathLike\", self.type(value))\n\n        return value"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 968, "end_line": 1039, "size": 72, 
"parent_context": "class_definition", "content": "def convert(\n        self,\n       
value: str | os.PathLike,\n        param: Parameter | None,\n        ctx: Context | 
None,\n    ) -> str | bytes | os.PathLike:\n        rv = value\n\n        is_dash = 
self.file_okay and self.allow_dash and rv in (b\"-\", \"-\")\n\n        if not 
is_dash:\n            if self.resolve_path:\n                rv = 
os.path.realpath(rv)\n\n            try:\n                st = os.stat(rv)\n          
except OSError:\n                if not self.exists:\n                    return 
self.coerce_path_result(rv)\n                self.fail(\n                    
_(\"{name} {filename!r} does not exist.\").format(\n                        
name=self.name.title(), filename=format_filename(value)\n                    ),\n     
param,\n                    ctx,\n                )\n\n            if not 
self.file_okay and stat.S_ISREG(st.st_mode):\n                self.fail(\n            
_(\"{name} {filename!r} is a file.\").format(\n                        
name=self.name.title(), filename=format_filename(value)\n                    ),\n     
param,\n                    ctx,\n                )\n            if not self.dir_okay 
and stat.S_ISDIR(st.st_mode):\n                self.fail(\n                    
_(\"{name} {filename!r} is a directory.\").format(\n                        
name=self.name.title(), filename=format_filename(value)\n                    ),\n     
param,\n                    ctx,\n                )\n\n            if self.readable 
and not os.access(rv, os.R_OK):\n                self.fail(\n                    
_(\"{name} {filename!r} is not readable.\").format(\n                        
name=self.name.title(), filename=format_filename(value)\n                    ),\n     
param,\n                    ctx,\n                )\n\n            if self.writable 
and not os.access(rv, os.W_OK):\n                self.fail(\n                    
_(\"{name} {filename!r} is not writable.\").format(\n                        
name=self.name.title(), filename=format_filename(value)\n                    ),\n     
param,\n                    ctx,\n                )\n\n            if self.executable 
and not os.access(value, os.X_OK):\n                self.fail(\n                    
_(\"{name} {filename!r} is not executable.\").format(\n                        
name=self.name.title(), filename=format_filename(value)\n                    ),\n     
param,\n                    ctx,\n                )\n\n        return 
self.coerce_path_result(rv)"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 1041, "end_line": 1057, "size": 17, 
"parent_context": "class_definition", "content": "def shell_complete(\n        self, 
ctx: Context, param: Parameter, incomplete: str\n    ) -> list[CompletionItem]:\n     
\"\"\"Return a special completion marker that tells the completion\n        system to 
use the shell to provide path completions for only\n        directories or any 
paths.\n\n        :param ctx: Invocation context for this command.\n        :param 
param: The parameter that is requesting completion.\n        :param incomplete: Value 
being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n     
from click.shell_completion import CompletionItem\n\n        type = \"dir\" if 
self.dir_okay and not self.file_okay else \"file\"\n        return 
[CompletionItem(incomplete, type=type)]"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 1060, "end_line": 1109, "size": 50, 
"parent_context": "", "content": "class Tuple(CompositeParamType):\n    \"\"\"The 
default behavior of Click is to apply a type on a value directly.\n    This works well
in most cases, except for when `nargs` is set to a fixed\n    count and different 
types should be used for different items.  In this\n    case the :class:`Tuple` type 
can be used.  This type can only be used\n    if `nargs` is set to a fixed number.\n\n
For more information see :ref:`tuple-type`.\n\n    This can be selected by using a 
Python tuple literal as a type.\n\n    :param types: a list of types that should be 
used for the tuple items.\n    \"\"\"\n\n    def __init__(self, types: 
cabc.Sequence[type | ParamType]) -> None:\n        self.types: 
cabc.Sequence[ParamType] = \n\n    def to_info_dict(self) -> dict:\n        info_dict 
= super().to_info_dict()\n        info_dict[\"types\"] = \n        return 
info_dict\n\n    @property\n    def name(self) -> str:  # type: ignore\n        return
f\"<{' '.join(ty.name for ty in self.types)}>\"\n\n    @property\n    def arity(self) 
-> int:  # type: ignore\n        return len(self.types)\n\n    def convert(\n        
self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n   
len_type = len(self.types)\n        len_value = len(value)\n\n        if len_value != 
len_type:\n            self.fail(\n                ngettext(\n                    
\"{len_type} values are required, but {len_value} was given.\",\n                    
\"{len_type} values are required, but {len_value} were given.\",\n                    
len_value,\n                ).format(len_type=len_type, len_value=len_value),\n       
param=param,\n                ctx=ctx,\n            )\n\n        return tuple(\n      
ty(x, param, ctx) for ty, x in zip(self.types, value, strict=False)\n        )"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 1074, "end_line": 1075, "size": 2, 
"parent_context": "class_definition", "content": "def __init__(self, types: 
cabc.Sequence[type | ParamType]) -> None:\n        self.types: 
cabc.Sequence[ParamType] = "}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 1077, "end_line": 1080, "size": 4, 
"parent_context": "class_definition", "content": "def to_info_dict(self) -> dict:\n   
info_dict = super().to_info_dict()\n        info_dict[\"types\"] = \n        return 
info_dict"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 1082, "end_line": 1084, "size": 3, 
"parent_context": "class_definition", "content": "@property\n    def name(self) -> 
str:  # type: ignore\n        return f\"<{' '.join(ty.name for ty in self.types)}>\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 1083, "end_line": 1084, "size": 2, 
"parent_context": "decorated_definition", "content": "def name(self) -> str:  # type: 
ignore\n        return f\"<{' '.join(ty.name for ty in self.types)}>\""}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 1086, "end_line": 1088, "size": 3, 
"parent_context": "class_definition", "content": "@property\n    def arity(self) -> 
int:  # type: ignore\n        return len(self.types)"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 1087, "end_line": 1088, "size": 2, 
"parent_context": "decorated_definition", "content": "def arity(self) -> int:  # type:
ignore\n        return len(self.types)"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 1090, "end_line": 1109, "size": 20, 
"parent_context": "class_definition", "content": "def convert(\n        self, value: 
t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        len_type
= len(self.types)\n        len_value = len(value)\n\n        if len_value != 
len_type:\n            self.fail(\n                ngettext(\n                    
\"{len_type} values are required, but {len_value} was given.\",\n                    
\"{len_type} values are required, but {len_value} were given.\",\n                    
len_value,\n                ).format(len_type=len_type, len_value=len_value),\n       
param=param,\n                ctx=ctx,\n            )\n\n        return tuple(\n      
ty(x, param, ctx) for ty, x in zip(self.types, value, strict=False)\n        )"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"function_definition", "start_line": 1112, "end_line": 1169, "size": 58, 
"parent_context": "", "content": "def convert_type(ty: t.Any | None, default: t.Any | 
None = None) -> ParamType:\n    \"\"\"Find the most appropriate :class:`ParamType` for
the given Python\n    type. If the type isn't provided, it can be inferred from a 
default\n    value.\n    \"\"\"\n    guessed_type = False\n\n    if ty is None and 
default is not None:\n        if isinstance(default, (tuple, list)):\n            # If
the default is empty, ty will remain None and will\n            # return STRING.\n    
if default:\n                item = default[0]\n\n                # A tuple of tuples 
needs to detect the inner types.\n                # Can't call convert recursively 
because that would\n                # incorrectly unwind the tuple to a single type.\n
if isinstance(item, (tuple, list)):\n                    ty = tuple(map(type, item))\n
else:\n                    ty = type(item)\n        else:\n            ty = 
type(default)\n\n        guessed_type = True\n\n    if isinstance(ty, tuple):\n       
return Tuple(ty)\n\n    if isinstance(ty, ParamType):\n        return ty\n\n    if ty 
is str or ty is None:\n        return STRING\n\n    if ty is int:\n        return 
INT\n\n    if ty is float:\n        return FLOAT\n\n    if ty is bool:\n        return
BOOL\n\n    if guessed_type:\n        return STRING\n\n    if __debug__:\n        
try:\n            if issubclass(ty, ParamType):\n                raise 
AssertionError(\n                    f\"Attempted to use an uninstantiated parameter 
type ({ty}).\"\n                )\n        except TypeError:\n            # ty is an 
instance (correct), so issubclass fails.\n            pass\n\n    return 
FuncParamType(ty)"}
{"file": "click/src/click/types.py", "language": "python", "node_type": 
"class_definition", "start_line": 1205, "end_line": 1209, "size": 5, "parent_context":
"", "content": "class OptionHelpExtra(t.TypedDict, total=False):\n    envvars: tuple\n
default: str\n    range: str\n    required: str"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 53, "end_line": 69, "size": 17, "parent_context":
"", "content": "def _complete_visible_commands(\n    ctx: Context, incomplete: str\n) 
-> cabc.Iterator[tuple]:\n    \"\"\"List all the subcommands of a group that start 
with the\n    incomplete value and aren't hidden.\n\n    :param ctx: Invocation 
context for the group.\n    :param incomplete: Value being completed. May be empty.\n 
\"\"\"\n    multi = t.cast(Group, ctx.command)\n\n    for name in 
multi.list_commands(ctx):\n        if name.startswith(incomplete):\n            
command = multi.get_command(ctx, name)\n\n            if command is not None and not 
command.hidden:\n                yield name, command"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 72, "end_line": 89, "size": 18, "parent_context":
"", "content": "def _check_nested_chain(\n    base_command: Group, cmd_name: str, cmd:
Command, register: bool = False\n) -> None:\n    if not base_command.chain or not 
isinstance(cmd, Group):\n        return\n\n    if register:\n        message = (\n    
f\"It is not possible to add the group {cmd_name!r} to another\"\n            f\" 
group {base_command.name!r} that is in chain mode.\"\n        )\n    else:\n        
message = (\n            f\"Found the group {cmd_name!r} as subcommand to another 
group \"\n            f\" {base_command.name!r} that is in chain mode. This is not 
supported.\"\n        )\n\n    raise RuntimeError(message)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 92, "end_line": 93, "size": 2, "parent_context": 
"", "content": "def batch(iterable: cabc.Iterable[V], batch_size: int) -> 
list[tuple[V, ...]]:\n    return list(zip(*repeat(iter(iterable), batch_size), 
strict=False))"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 96, "end_line": 112, "size": 17, 
"parent_context": "", "content": "@contextmanager\ndef augment_usage_errors(\n    ctx:
Context, param: Parameter | None = None\n) -> cabc.Iterator[None]:\n    \"\"\"Context 
manager that attaches extra information to exceptions.\"\"\"\n    try:\n        
yield\n    except BadParameter as e:\n        if e.ctx is None:\n            e.ctx = 
ctx\n        if param is not None and e.param is None:\n            e.param = param\n 
raise\n    except UsageError as e:\n        if e.ctx is None:\n            e.ctx = 
ctx\n        raise"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 97, "end_line": 112, "size": 16, 
"parent_context": "decorated_definition", "content": "def augment_usage_errors(\n    
ctx: Context, param: Parameter | None = None\n) -> cabc.Iterator[None]:\n    
\"\"\"Context manager that attaches extra information to exceptions.\"\"\"\n    try:\n
yield\n    except BadParameter as e:\n        if e.ctx is None:\n            e.ctx = 
ctx\n        if param is not None and e.param is None:\n            e.param = param\n 
raise\n    except UsageError as e:\n        if e.ctx is None:\n            e.ctx = 
ctx\n        raise"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 115, "end_line": 139, "size": 25, 
"parent_context": "", "content": "def iter_params_for_processing(\n    
invocation_order: cabc.Sequence[Parameter],\n    declaration_order: 
cabc.Sequence[Parameter],\n) -> list[Parameter]:\n    \"\"\"Returns all declared 
parameters in the order they should be processed.\n\n    The declared parameters are 
re-shuffled depending on the order in which\n    they were invoked, as well as the 
eagerness of each parameters.\n\n    The invocation order takes precedence over the 
declaration order. I.e. the\n    order in which the user provided them to the CLI is 
respected.\n\n    This behavior and its effect on callback evaluation is detailed 
at:\n    
https://click.palletsprojects.com/en/stable/advanced/#callback-evaluation-order\n    
\"\"\"\n\n    def sort_key(item: Parameter) -> tuple:\n        try:\n            idx: 
float = invocation_order.index(item)\n        except ValueError:\n            idx = 
float(\"inf\")\n\n        return not item.is_eager, idx\n\n    return 
sorted(declaration_order, key=sort_key)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 131, "end_line": 137, "size": 7, 
"parent_context": "function_definition", "content": "def sort_key(item: Parameter) -> 
tuple:\n        try:\n            idx: float = invocation_order.index(item)\n        
except ValueError:\n            idx = float(\"inf\")\n\n        return not 
item.is_eager, idx"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"class_definition", "start_line": 142, "end_line": 165, "size": 24, "parent_context": 
"", "content": "class ParameterSource(enum.Enum):\n    \"\"\"This is an 
:class:`~enum.Enum` that indicates the source of a\n    parameter's value.\n\n    Use 
:meth:`click.Context.get_parameter_source` to get the\n    source for a parameter by 
name.\n\n    .. versionchanged:: 8.0\n        Use :class:`~enum.Enum` and drop the 
``validate`` method.\n\n    .. versionchanged:: 8.0\n        Added the ``PROMPT`` 
value.\n    \"\"\"\n\n    COMMANDLINE = enum.auto()\n    \"\"\"The value was provided 
by the command line args.\"\"\"\n    ENVIRONMENT = enum.auto()\n    \"\"\"The value 
was provided with an environment variable.\"\"\"\n    DEFAULT = enum.auto()\n    
\"\"\"Used the default specified by the parameter.\"\"\"\n    DEFAULT_MAP = 
enum.auto()\n    \"\"\"Used a default provided by :attr:`Context.default_map`.\"\"\"\n
PROMPT = enum.auto()\n    \"\"\"Used a prompt to confirm a default or provide a 
value.\"\"\""}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"class_definition", "start_line": 168, "end_line": 840, "size": 673, "parent_context":
"", "content": "class Context:\n    \"\"\"The context is a special internal object 
that holds state relevant\n    for the script execution at every single level.  It's 
normally invisible\n    to commands unless they opt-in to getting access to it.\n\n   
The context is useful as it can pass internal objects around and can\n    control 
special execution features such as reading data from\n    environment variables.\n\n  
A context can be used as context manager in which case it will call\n    :meth:`close`
on teardown.\n\n    :param command: the command class for this context.\n    :param 
parent: the parent context.\n    :param info_name: the info name for this invocation. 
Generally this\n                      is the most descriptive name for the script or\n
command.  For the toplevel script it is usually\n                      the name of the
script, for commands below it it's\n                      the name of the script.\n   
:param obj: an arbitrary object of user data.\n    :param auto_envvar_prefix: the 
prefix to use for automatic environment\n                               variables.  If
this is `None` then reading\n                               from environment variables
is disabled.  This\n                               does not affect manually set 
environment\n                               variables which are always read.\n    
:param default_map: a dictionary (like object) with default values\n                  
for parameters.\n    :param terminal_width: the width of the terminal.  The default 
is\n                           inherit from parent context.  If no context\n          
defines the terminal width then auto\n                           detection will be 
applied.\n    :param max_content_width: the maximum width for content rendered by\n   
Click (this currently only affects help\n                              pages).  This 
defaults to 80 characters if\n                              not overridden.  In other 
words: even if the\n                              terminal is larger than that, Click 
will not\n                              format things wider than 80 characters by\n   
default.  In addition to that, formatters might\n                              add 
some safety mapping on the right.\n    :param resilient_parsing: if this flag is 
enabled then Click will\n                              parse without any interactivity
or callback\n                              invocation.  Default values will also be\n 
ignored.  This is useful for implementing\n                              things such 
as completion support.\n    :param allow_extra_args: if this is set to `True` then 
extra arguments\n                             at the end will not raise an error and 
will be\n                             kept on the context.  The default is to 
inherit\n                             from the command.\n    :param 
allow_interspersed_args: if this is set to `False` then options\n                     
and arguments cannot be mixed.  The\n                                    default is to
inherit from the command.\n    :param ignore_unknown_options: instructs click to 
ignore options it does\n                                   not know and keeps them for
later\n                                   processing.\n    :param help_option_names: 
optionally a list of strings that define how\n                              the 
default help parameter is named.  The\n                              default is 
``['--help']``.\n    :param token_normalize_func: an optional function that is used 
to\n                                 normalize tokens (options, choices,\n            
etc.).  This for instance can be used to\n                                 implement 
case insensitive behavior.\n    :param color: controls if the terminal supports ANSI 
colors or not.  The\n                  default is autodetection.  This is only needed 
if ANSI\n                  codes are used in texts that Click prints which is by\n    
default not the case.  This for instance would affect\n                  help 
output.\n    :param show_default: Show the default value for commands. If this\n      
value is not set, it defaults to the value from the parent\n        context. 
``Command.show_default`` overrides this default for the\n        specific command.\n\n
.. versionchanged:: 8.2\n        The ``protected_args`` attribute is deprecated and 
will be removed in\n        Click 9.0. ``args`` will contain remaining unparsed 
tokens.\n\n    .. versionchanged:: 8.1\n        The ``show_default`` parameter is 
overridden by\n        ``Command.show_default``, instead of the other way around.\n\n 
.. versionchanged:: 8.0\n        The ``show_default`` parameter defaults to the value 
from the\n        parent context.\n\n    .. versionchanged:: 7.1\n       Added the 
``show_default`` parameter.\n\n    .. versionchanged:: 4.0\n        Added the 
``color``, ``ignore_unknown_options``, and\n        ``max_content_width`` 
parameters.\n\n    .. versionchanged:: 3.0\n        Added the ``allow_extra_args`` and
``allow_interspersed_args``\n        parameters.\n\n    .. versionchanged:: 2.0\n     
Added the ``resilient_parsing``, ``help_option_names``, and\n        
``token_normalize_func`` parameters.\n    \"\"\"\n\n    #: The formatter class to 
create with :meth:`make_formatter`.\n    #:\n    #: .. versionadded:: 8.0\n    
formatter_class: type[HelpFormatter] = HelpFormatter\n\n    def __init__(\n        
self,\n        command: Command,\n        parent: Context | None = None,\n        
info_name: str | None = None,\n        obj: t.Any | None = None,\n        
auto_envvar_prefix: str | None = None,\n        default_map: cabc.MutableMapping | 
None = None,\n        terminal_width: int | None = None,\n        max_content_width: 
int | None = None,\n        resilient_parsing: bool = False,\n        
allow_extra_args: bool | None = None,\n        allow_interspersed_args: bool | None = 
None,\n        ignore_unknown_options: bool | None = None,\n        help_option_names:
list | None = None,\n        token_normalize_func: t.Callable[, str] | None = None,\n 
color: bool | None = None,\n        show_default: bool | None = None,\n    ) -> 
None:\n        #: the parent context or `None` if none exists.\n        self.parent = 
parent\n        #: the :class:`Command` for this context.\n        self.command = 
command\n        #: the descriptive information name\n        self.info_name = 
info_name\n        #: Map of parameter names to their parsed values. Parameters\n     
#: with ``expose_value=False`` are not stored.\n        self.params: dict = {}\n      
#: the leftover arguments.\n        self.args: list = []\n        #: protected 
arguments.  These are arguments that are prepended\n        #: to `args` when certain 
parsing scenarios are encountered but\n        #: must be never propagated to another 
arguments.  This is used\n        #: to implement nested parsing.\n        
self._protected_args: list = []\n        #: the collected prefixes of the command's 
options.\n        self._opt_prefixes: set = set(parent._opt_prefixes) if parent else 
set()\n\n        if obj is None and parent is not None:\n            obj = 
parent.obj\n\n        #: the user object stored.\n        self.obj: t.Any = obj\n     
self._meta: dict = getattr(parent, \"meta\", {})\n\n        #: A dictionary (-like 
object) with defaults for parameters.\n        if (\n            default_map is None\n
and info_name is not None\n            and parent is not None\n            and 
parent.default_map is not None\n        ):\n            default_map = 
parent.default_map.get(info_name)\n\n        self.default_map: cabc.MutableMapping | 
None = default_map\n\n        #: This flag indicates if a subcommand is going to be 
executed. A\n        #: group callback can use this information to figure out if 
it's\n        #: being executed directly or because the execution flow passes\n       
#: onwards to a subcommand. By default it's None, but it can be\n        #: the name 
of the subcommand to execute.\n        #:\n        #: If chaining is enabled this will
be set to ``'*'`` in case\n        #: any commands are executed.  It is however not 
possible to\n        #: figure out which ones.  If you require this knowledge you\n   
#: should use a :func:`result_callback`.\n        self.invoked_subcommand: str | None 
= None\n\n        if terminal_width is None and parent is not None:\n            
terminal_width = parent.terminal_width\n\n        #: The width of the terminal (None 
is autodetection).\n        self.terminal_width: int | None = terminal_width\n\n      
if max_content_width is None and parent is not None:\n            max_content_width = 
parent.max_content_width\n\n        #: The maximum width of formatted content (None 
implies a sensible\n        #: default which is 80 for most things).\n        
self.max_content_width: int | None = max_content_width\n\n        if allow_extra_args 
is None:\n            allow_extra_args = command.allow_extra_args\n\n        #: 
Indicates if the context allows extra args or if it should\n        #: fail on 
parsing.\n        #:\n        #: .. versionadded:: 3.0\n        self.allow_extra_args 
= allow_extra_args\n\n        if allow_interspersed_args is None:\n            
allow_interspersed_args = command.allow_interspersed_args\n\n        #: Indicates if 
the context allows mixing of arguments and\n        #: options or not.\n        #:\n  
#: .. versionadded:: 3.0\n        self.allow_interspersed_args: bool = 
allow_interspersed_args\n\n        if ignore_unknown_options is None:\n            
ignore_unknown_options = command.ignore_unknown_options\n\n        #: Instructs click 
to ignore options that a command does not\n        #: understand and will store it on 
the context for later\n        #: processing.  This is primarily useful for situations
where you\n        #: want to call into external programs.  Generally this pattern 
is\n        #: strongly discouraged because it's not possibly to losslessly\n        
#: forward all arguments.\n        #:\n        #: .. versionadded:: 4.0\n        
self.ignore_unknown_options: bool = ignore_unknown_options\n\n        if 
help_option_names is None:\n            if parent is not None:\n                
help_option_names = parent.help_option_names\n            else:\n                
help_option_names = [\"--help\"]\n\n        #: The names for the help options.\n      
self.help_option_names: list = help_option_names\n\n        if token_normalize_func is
None and parent is not None:\n            token_normalize_func = 
parent.token_normalize_func\n\n        #: An optional normalization function for 
tokens.  This is\n        #: options, choices, commands etc.\n        
self.token_normalize_func: t.Callable[, str] | None = token_normalize_func\n\n        
#: Indicates if resilient parsing is enabled.  In that case Click\n        #: will do 
its best to not cause any failures and default values\n        #: will be ignored. 
Useful for completion.\n        self.resilient_parsing: bool = resilient_parsing\n\n  
# If there is no envvar prefix yet, but the parent has one and\n        # the command 
on this level has a name, we can expand the envvar\n        # prefix automatically.\n 
if auto_envvar_prefix is None:\n            if (\n                parent is not None\n
and parent.auto_envvar_prefix is not None\n                and self.info_name is not 
None\n            ):\n                auto_envvar_prefix = (\n                    
f\"{parent.auto_envvar_prefix}_{self.info_name.upper()}\"\n                )\n        
else:\n            auto_envvar_prefix = auto_envvar_prefix.upper()\n\n        if 
auto_envvar_prefix is not None:\n            auto_envvar_prefix = 
auto_envvar_prefix.replace(\"-\", \"_\")\n\n        self.auto_envvar_prefix: str | 
None = auto_envvar_prefix\n\n        if color is None and parent is not None:\n       
color = parent.color\n\n        #: Controls if styling output is wanted or not.\n     
self.color: bool | None = color\n\n        if show_default is None and parent is not 
None:\n            show_default = parent.show_default\n\n        #: Show option 
default values when formatting help text.\n        self.show_default: bool | None = 
show_default\n\n        self._close_callbacks: list[t.Callable[[], t.Any]] = []\n     
self._depth = 0\n        self._parameter_source: dict = {}\n        self._exit_stack =
ExitStack()\n\n    @property\n    def protected_args(self) -> list:\n        import 
warnings\n\n        warnings.warn(\n            \"'protected_args' is deprecated and 
will be removed in Click 9.0.\"\n            \" 'args' will contain remaining unparsed
tokens.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n   
return self._protected_args\n\n    def to_info_dict(self) -> dict:\n        
\"\"\"Gather information that could be useful for a tool generating\n        
user-facing documentation. This traverses the entire CLI\n        structure.\n\n      
.. code-block:: python\n\n            with Context(cli) as ctx:\n                info 
= ctx.to_info_dict()\n\n        .. versionadded:: 8.0\n        \"\"\"\n        return 
{\n            \"command\": self.command.to_info_dict(self),\n            
\"info_name\": self.info_name,\n            \"allow_extra_args\": 
self.allow_extra_args,\n            \"allow_interspersed_args\": 
self.allow_interspersed_args,\n            \"ignore_unknown_options\": 
self.ignore_unknown_options,\n            \"auto_envvar_prefix\": 
self.auto_envvar_prefix,\n        }\n\n    def __enter__(self) -> Context:\n        
self._depth += 1\n        push_context(self)\n        return self\n\n    def 
__exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        
exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n 
self._depth -= 1\n        if self._depth == 0:\n            self.close()\n        
pop_context()\n\n    @contextmanager\n    def scope(self, cleanup: bool = True) -> 
cabc.Iterator[Context]:\n        \"\"\"This helper method can be used with the context
object to promote\n        it to the current thread local (see 
:func:`get_current_context`).\n        The default behavior of this is to invoke the 
cleanup functions which\n        can be disabled by setting `cleanup` to `False`.  The
cleanup\n        functions are typically used for things such as closing file 
handles.\n\n        If the cleanup is intended the context object can also be 
directly\n        used as a context manager.\n\n        Example usage::\n\n           
with ctx.scope():\n                assert get_current_context() is ctx\n\n        This
is equivalent::\n\n            with ctx:\n                assert get_current_context()
is ctx\n\n        .. versionadded:: 5.0\n\n        :param cleanup: controls if the 
cleanup functions should be run or\n                        not.  The default is to 
run these functions.  In\n                        some situations the context only 
wants to be\n                        temporarily pushed in which case this can be 
disabled.\n                        Nested pushes automatically defer the cleanup.\n   
\"\"\"\n        if not cleanup:\n            self._depth += 1\n        try:\n         
with self as rv:\n                yield rv\n        finally:\n            if not 
cleanup:\n                self._depth -= 1\n\n    @property\n    def meta(self) -> 
dict:\n        \"\"\"This is a dictionary which is shared with all the contexts\n     
that are nested.  It exists so that click utilities can store some\n        state here
if they need to.  It is however the responsibility of\n        that code to manage 
this dictionary well.\n\n        The keys are supposed to be unique dotted strings.  
For instance\n        module paths are a good choice for it.  What is stored in there 
is\n        irrelevant for the operation of click.  However what is important is\n    
that code that places data here adheres to the general semantics of\n        the 
system.\n\n        Example usage::\n\n            LANG_KEY = f'{__name__}.lang'\n\n   
def set_language(value):\n                ctx = get_current_context()\n               
ctx.meta[LANG_KEY] = value\n\n            def get_language():\n                return 
get_current_context().meta.get(LANG_KEY, 'en_US')\n\n        .. versionadded:: 5.0\n  
\"\"\"\n        return self._meta\n\n    def make_formatter(self) -> HelpFormatter:\n 
\"\"\"Creates the :class:`~click.HelpFormatter` for the help and\n        usage 
output.\n\n        To quickly customize the formatter class used without overriding\n 
this method, set the :attr:`formatter_class` attribute.\n\n        .. versionchanged::
8.0\n            Added the :attr:`formatter_class` attribute.\n        \"\"\"\n       
return self.formatter_class(\n            width=self.terminal_width, 
max_width=self.max_content_width\n        )\n\n    def with_resource(self, 
context_manager: AbstractContextManager[V]) -> V:\n        \"\"\"Register a resource 
as if it were used in a ``with``\n        statement. The resource will be cleaned up 
when the context is\n        popped.\n\n        Uses 
:meth:`contextlib.ExitStack.enter_context`. It calls the\n        resource's 
``__enter__()`` method and returns the result. When\n        the context is popped, it
closes the stack, which calls the\n        resource's ``__exit__()`` method.\n\n      
To register a cleanup function for something that isn't a\n        context manager, 
use :meth:`call_on_close`. Or use something\n        from :mod:`contextlib` to turn it
into a context manager first.\n\n        .. code-block:: python\n\n            
@click.group()\n            @click.option(\"--name\")\n            
@click.pass_context\n            def cli(ctx):\n                ctx.obj = 
ctx.with_resource(connect_db(name))\n\n        :param context_manager: The context 
manager to enter.\n        :return: Whatever ``context_manager.__enter__()`` 
returns.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        return 
self._exit_stack.enter_context(context_manager)\n\n    def call_on_close(self, f: 
t.Callable[..., t.Any]) -> t.Callable[..., t.Any]:\n        \"\"\"Register a function 
to be called when the context tears down.\n\n        This can be used to close 
resources opened during the script\n        execution. Resources that support Python's
context manager\n        protocol which would be used in a ``with`` statement should 
be\n        registered with :meth:`with_resource` instead.\n\n        :param f: The 
function to execute on teardown.\n        \"\"\"\n        return 
self._exit_stack.callback(f)\n\n    def close(self) -> None:\n        \"\"\"Invoke all
close callbacks registered with\n        :meth:`call_on_close`, and exit all context 
managers entered\n        with :meth:`with_resource`.\n        \"\"\"\n        
self._exit_stack.close()\n        # In case the context is reused, create a new exit 
stack.\n        self._exit_stack = ExitStack()\n\n    @property\n    def 
command_path(self) -> str:\n        \"\"\"The computed command path.  This is used for
the ``usage``\n        information on the help page.  It's automatically created by\n 
combining the info names of the chain of contexts to the root.\n        \"\"\"\n      
rv = \"\"\n        if self.info_name is not None:\n            rv = self.info_name\n  
if self.parent is not None:\n            parent_command_path = \n\n            if 
isinstance(self.parent.command, Command):\n                for param in 
self.parent.command.get_params(self):\n                    
parent_command_path.extend(param.get_usage_pieces(self))\n\n            rv = f\"{' 
'.join(parent_command_path)} {rv}\"\n        return rv.lstrip()\n\n    def 
find_root(self) -> Context:\n        \"\"\"Finds the outermost context.\"\"\"\n       
node = self\n        while node.parent is not None:\n            node = node.parent\n 
return node\n\n    def find_object(self, object_type: type[V]) -> V | None:\n        
\"\"\"Finds the closest object of a given type.\"\"\"\n        node: Context | None = 
self\n\n        while node is not None:\n            if isinstance(node.obj, 
object_type):\n                return node.obj\n\n            node = node.parent\n\n  
return None\n\n    def ensure_object(self, object_type: type[V]) -> V:\n        
\"\"\"Like :meth:`find_object` but sets the innermost object to a\n        new 
instance of `object_type` if it does not exist.\n        \"\"\"\n        rv = 
self.find_object(object_type)\n        if rv is None:\n            self.obj = rv = 
object_type()\n        return rv\n\n    @t.overload\n    def lookup_default(\n        
self, name: str, call: t.Literal[True] = True\n    ) -> t.Any | None: ...\n\n    
@t.overload\n    def lookup_default(\n        self, name: str, call: t.Literal[False] 
= ...\n    ) -> t.Any | t.Callable[[], t.Any] | None: ...\n\n    def 
lookup_default(self, name: str, call: bool = True) -> t.Any | None:\n        \"\"\"Get
the default for a parameter from :attr:`default_map`.\n\n        :param name: Name of 
the parameter.\n        :param call: If the default is a callable, call it. Disable 
to\n            return the callable instead.\n\n        .. versionchanged:: 8.0\n     
Added the ``call`` parameter.\n        \"\"\"\n        if self.default_map is not 
None:\n            value = self.default_map.get(name)\n\n            if call and 
callable(value):\n                return value()\n\n            return value\n\n      
return None\n\n    def fail(self, message: str) -> t.NoReturn:\n        \"\"\"Aborts 
the execution of the program with a specific error\n        message.\n\n        :param
message: the error message to fail with.\n        \"\"\"\n        raise 
UsageError(message, self)\n\n    def abort(self) -> t.NoReturn:\n        \"\"\"Aborts 
the script.\"\"\"\n        raise Abort()\n\n    def exit(self, code: int = 0) -> 
t.NoReturn:\n        \"\"\"Exits the application with a given exit code.\n\n        ..
versionchanged:: 8.2\n            Callbacks and context managers registered with 
:meth:`call_on_close`\n            and :meth:`with_resource` are closed before 
exiting.\n        \"\"\"\n        self.close()\n        raise Exit(code)\n\n    def 
get_usage(self) -> str:\n        \"\"\"Helper method to get formatted usage string for
the current\n        context and command.\n        \"\"\"\n        return 
self.command.get_usage(self)\n\n    def get_help(self) -> str:\n        \"\"\"Helper 
method to get formatted help page for the current\n        context and command.\n     
\"\"\"\n        return self.command.get_help(self)\n\n    def _make_sub_context(self, 
command: Command) -> Context:\n        \"\"\"Create a new context of the same type as 
this context, but\n        for a new command.\n\n        :meta private:\n        
\"\"\"\n        return type(self)(command, info_name=command.name, parent=self)\n\n   
@t.overload\n    def invoke(\n        self, callback: t.Callable[..., V], /, *args: 
t.Any, **kwargs: t.Any\n    ) -> V: ...\n\n    @t.overload\n    def invoke(self, 
callback: Command, /, *args: t.Any, **kwargs: t.Any) -> t.Any: ...\n\n    def 
invoke(\n        self, callback: Command | t.Callable[..., V], /, *args: t.Any, 
**kwargs: t.Any\n    ) -> t.Any | V:\n        \"\"\"Invokes a command callback in 
exactly the way it expects.  There\n        are two ways to invoke this method:\n\n   
1.  the first argument can be a callback and all other arguments and\n            
keyword arguments are forwarded directly to the function.\n        2.  the first 
argument is a click command object.  In that case all\n            arguments are 
forwarded as well but proper click parameters\n            (options and click 
arguments) must be keyword arguments and Click\n            will fill in defaults.\n\n
.. versionchanged:: 8.0\n            All ``kwargs`` are tracked in :attr:`params` so 
they will be\n            passed if :meth:`forward` is called at multiple levels.\n\n 
.. versionchanged:: 3.2\n            A new context is created, and missing arguments 
use default values.\n        \"\"\"\n        if isinstance(callback, Command):\n      
other_cmd = callback\n\n            if other_cmd.callback is None:\n                
raise TypeError(\n                    \"The given command does not have a callback 
that can be invoked.\"\n                )\n            else:\n                callback
= t.cast(\"t.Callable[..., V]\", other_cmd.callback)\n\n            ctx = 
self._make_sub_context(other_cmd)\n\n            for param in other_cmd.params:\n     
if param.name not in kwargs and param.expose_value:\n                    kwargs = 
param.type_cast_value(  # type: ignore\n                        ctx, 
param.get_default(ctx)\n                    )\n\n            # Track all kwargs as 
params, so that forward() will pass\n            # them on in subsequent calls.\n     
ctx.params.update(kwargs)\n        else:\n            ctx = self\n\n        with 
augment_usage_errors(self):\n            with ctx:\n                return 
callback(*args, **kwargs)\n\n    def forward(self, cmd: Command, /, *args: t.Any, 
**kwargs: t.Any) -> t.Any:\n        \"\"\"Similar to :meth:`invoke` but fills in 
default keyword\n        arguments from the current context if the other command 
expects\n        it.  This cannot invoke callbacks directly, only other commands.\n\n 
.. versionchanged:: 8.0\n            All ``kwargs`` are tracked in :attr:`params` so 
they will be\n            passed if ``forward`` is called at multiple levels.\n       
\"\"\"\n        # Can only forward to other commands, not direct callbacks.\n        
if not isinstance(cmd, Command):\n            raise TypeError(\"Callback is not a 
command.\")\n\n        for param in self.params:\n            if param not in 
kwargs:\n                kwargs = self.params\n\n        return self.invoke(cmd, 
*args, **kwargs)\n\n    def set_parameter_source(self, name: str, source: 
ParameterSource) -> None:\n        \"\"\"Set the source of a parameter. This indicates
the location\n        from which the value of the parameter was obtained.\n\n        
:param name: The name of the parameter.\n        :param source: A member of 
:class:`~click.core.ParameterSource`.\n        \"\"\"\n        self._parameter_source 
= source\n\n    def get_parameter_source(self, name: str) -> ParameterSource | None:\n
\"\"\"Get the source of a parameter. This indicates the location\n        from which 
the value of the parameter was obtained.\n\n        This can be useful for determining
when a user specified a value\n        on the command line that is the same as the 
default value. It\n        will be :attr:`~click.core.ParameterSource.DEFAULT` only if
the\n        value was actually taken from the default.\n\n        :param name: The 
name of the parameter.\n        :rtype: ParameterSource\n\n        .. versionchanged::
8.0\n            Returns ``None`` if the parameter was not provided from any\n        
source.\n        \"\"\"\n        return self._parameter_source.get(name)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 272, "end_line": 440, "size": 169, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
command: Command,\n        parent: Context | None = None,\n        info_name: str | 
None = None,\n        obj: t.Any | None = None,\n        auto_envvar_prefix: str | 
None = None,\n        default_map: cabc.MutableMapping | None = None,\n        
terminal_width: int | None = None,\n        max_content_width: int | None = None,\n   
resilient_parsing: bool = False,\n        allow_extra_args: bool | None = None,\n     
allow_interspersed_args: bool | None = None,\n        ignore_unknown_options: bool | 
None = None,\n        help_option_names: list | None = None,\n        
token_normalize_func: t.Callable[, str] | None = None,\n        color: bool | None = 
None,\n        show_default: bool | None = None,\n    ) -> None:\n        #: the 
parent context or `None` if none exists.\n        self.parent = parent\n        #: the
:class:`Command` for this context.\n        self.command = command\n        #: the 
descriptive information name\n        self.info_name = info_name\n        #: Map of 
parameter names to their parsed values. Parameters\n        #: with 
``expose_value=False`` are not stored.\n        self.params: dict = {}\n        #: the
leftover arguments.\n        self.args: list = []\n        #: protected arguments.  
These are arguments that are prepended\n        #: to `args` when certain parsing 
scenarios are encountered but\n        #: must be never propagated to another 
arguments.  This is used\n        #: to implement nested parsing.\n        
self._protected_args: list = []\n        #: the collected prefixes of the command's 
options.\n        self._opt_prefixes: set = set(parent._opt_prefixes) if parent else 
set()\n\n        if obj is None and parent is not None:\n            obj = 
parent.obj\n\n        #: the user object stored.\n        self.obj: t.Any = obj\n     
self._meta: dict = getattr(parent, \"meta\", {})\n\n        #: A dictionary (-like 
object) with defaults for parameters.\n        if (\n            default_map is None\n
and info_name is not None\n            and parent is not None\n            and 
parent.default_map is not None\n        ):\n            default_map = 
parent.default_map.get(info_name)\n\n        self.default_map: cabc.MutableMapping | 
None = default_map\n\n        #: This flag indicates if a subcommand is going to be 
executed. A\n        #: group callback can use this information to figure out if 
it's\n        #: being executed directly or because the execution flow passes\n       
#: onwards to a subcommand. By default it's None, but it can be\n        #: the name 
of the subcommand to execute.\n        #:\n        #: If chaining is enabled this will
be set to ``'*'`` in case\n        #: any commands are executed.  It is however not 
possible to\n        #: figure out which ones.  If you require this knowledge you\n   
#: should use a :func:`result_callback`.\n        self.invoked_subcommand: str | None 
= None\n\n        if terminal_width is None and parent is not None:\n            
terminal_width = parent.terminal_width\n\n        #: The width of the terminal (None 
is autodetection).\n        self.terminal_width: int | None = terminal_width\n\n      
if max_content_width is None and parent is not None:\n            max_content_width = 
parent.max_content_width\n\n        #: The maximum width of formatted content (None 
implies a sensible\n        #: default which is 80 for most things).\n        
self.max_content_width: int | None = max_content_width\n\n        if allow_extra_args 
is None:\n            allow_extra_args = command.allow_extra_args\n\n        #: 
Indicates if the context allows extra args or if it should\n        #: fail on 
parsing.\n        #:\n        #: .. versionadded:: 3.0\n        self.allow_extra_args 
= allow_extra_args\n\n        if allow_interspersed_args is None:\n            
allow_interspersed_args = command.allow_interspersed_args\n\n        #: Indicates if 
the context allows mixing of arguments and\n        #: options or not.\n        #:\n  
#: .. versionadded:: 3.0\n        self.allow_interspersed_args: bool = 
allow_interspersed_args\n\n        if ignore_unknown_options is None:\n            
ignore_unknown_options = command.ignore_unknown_options\n\n        #: Instructs click 
to ignore options that a command does not\n        #: understand and will store it on 
the context for later\n        #: processing.  This is primarily useful for situations
where you\n        #: want to call into external programs.  Generally this pattern 
is\n        #: strongly discouraged because it's not possibly to losslessly\n        
#: forward all arguments.\n        #:\n        #: .. versionadded:: 4.0\n        
self.ignore_unknown_options: bool = ignore_unknown_options\n\n        if 
help_option_names is None:\n            if parent is not None:\n                
help_option_names = parent.help_option_names\n            else:\n                
help_option_names = [\"--help\"]\n\n        #: The names for the help options.\n      
self.help_option_names: list = help_option_names\n\n        if token_normalize_func is
None and parent is not None:\n            token_normalize_func = 
parent.token_normalize_func\n\n        #: An optional normalization function for 
tokens.  This is\n        #: options, choices, commands etc.\n        
self.token_normalize_func: t.Callable[, str] | None = token_normalize_func\n\n        
#: Indicates if resilient parsing is enabled.  In that case Click\n        #: will do 
its best to not cause any failures and default values\n        #: will be ignored. 
Useful for completion.\n        self.resilient_parsing: bool = resilient_parsing\n\n  
# If there is no envvar prefix yet, but the parent has one and\n        # the command 
on this level has a name, we can expand the envvar\n        # prefix automatically.\n 
if auto_envvar_prefix is None:\n            if (\n                parent is not None\n
and parent.auto_envvar_prefix is not None\n                and self.info_name is not 
None\n            ):\n                auto_envvar_prefix = (\n                    
f\"{parent.auto_envvar_prefix}_{self.info_name.upper()}\"\n                )\n        
else:\n            auto_envvar_prefix = auto_envvar_prefix.upper()\n\n        if 
auto_envvar_prefix is not None:\n            auto_envvar_prefix = 
auto_envvar_prefix.replace(\"-\", \"_\")\n\n        self.auto_envvar_prefix: str | 
None = auto_envvar_prefix\n\n        if color is None and parent is not None:\n       
color = parent.color\n\n        #: Controls if styling output is wanted or not.\n     
self.color: bool | None = color\n\n        if show_default is None and parent is not 
None:\n            show_default = parent.show_default\n\n        #: Show option 
default values when formatting help text.\n        self.show_default: bool | None = 
show_default\n\n        self._close_callbacks: list[t.Callable[[], t.Any]] = []\n     
self._depth = 0\n        self._parameter_source: dict = {}\n        self._exit_stack =
ExitStack()"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 442, "end_line": 452, "size": 11, 
"parent_context": "class_definition", "content": "@property\n    def 
protected_args(self) -> list:\n        import warnings\n\n        warnings.warn(\n    
\"'protected_args' is deprecated and will be removed in Click 9.0.\"\n            \" 
'args' will contain remaining unparsed tokens.\",\n            DeprecationWarning,\n  
stacklevel=2,\n        )\n        return self._protected_args"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 443, "end_line": 452, "size": 10, 
"parent_context": "decorated_definition", "content": "def protected_args(self) -> 
list:\n        import warnings\n\n        warnings.warn(\n            
\"'protected_args' is deprecated and will be removed in Click 9.0.\"\n            \" 
'args' will contain remaining unparsed tokens.\",\n            DeprecationWarning,\n  
stacklevel=2,\n        )\n        return self._protected_args"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 454, "end_line": 473, "size": 20, 
"parent_context": "class_definition", "content": "def to_info_dict(self) -> dict:\n   
\"\"\"Gather information that could be useful for a tool generating\n        
user-facing documentation. This traverses the entire CLI\n        structure.\n\n      
.. code-block:: python\n\n            with Context(cli) as ctx:\n                info 
= ctx.to_info_dict()\n\n        .. versionadded:: 8.0\n        \"\"\"\n        return 
{\n            \"command\": self.command.to_info_dict(self),\n            
\"info_name\": self.info_name,\n            \"allow_extra_args\": 
self.allow_extra_args,\n            \"allow_interspersed_args\": 
self.allow_interspersed_args,\n            \"ignore_unknown_options\": 
self.ignore_unknown_options,\n            \"auto_envvar_prefix\": 
self.auto_envvar_prefix,\n        }"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 475, "end_line": 478, "size": 4, 
"parent_context": "class_definition", "content": "def __enter__(self) -> Context:\n   
self._depth += 1\n        push_context(self)\n        return self"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 480, "end_line": 489, "size": 10, 
"parent_context": "class_definition", "content": "def __exit__(\n        self,\n      
exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n     
tb: TracebackType | None,\n    ) -> None:\n        self._depth -= 1\n        if 
self._depth == 0:\n            self.close()\n        pop_context()"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 491, "end_line": 527, "size": 37, 
"parent_context": "class_definition", "content": "@contextmanager\n    def scope(self,
cleanup: bool = True) -> cabc.Iterator[Context]:\n        \"\"\"This helper method can
be used with the context object to promote\n        it to the current thread local 
(see :func:`get_current_context`).\n        The default behavior of this is to invoke 
the cleanup functions which\n        can be disabled by setting `cleanup` to `False`. 
The cleanup\n        functions are typically used for things such as closing file 
handles.\n\n        If the cleanup is intended the context object can also be 
directly\n        used as a context manager.\n\n        Example usage::\n\n           
with ctx.scope():\n                assert get_current_context() is ctx\n\n        This
is equivalent::\n\n            with ctx:\n                assert get_current_context()
is ctx\n\n        .. versionadded:: 5.0\n\n        :param cleanup: controls if the 
cleanup functions should be run or\n                        not.  The default is to 
run these functions.  In\n                        some situations the context only 
wants to be\n                        temporarily pushed in which case this can be 
disabled.\n                        Nested pushes automatically defer the cleanup.\n   
\"\"\"\n        if not cleanup:\n            self._depth += 1\n        try:\n         
with self as rv:\n                yield rv\n        finally:\n            if not 
cleanup:\n                self._depth -= 1"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 492, "end_line": 527, "size": 36, 
"parent_context": "decorated_definition", "content": "def scope(self, cleanup: bool = 
True) -> cabc.Iterator[Context]:\n        \"\"\"This helper method can be used with 
the context object to promote\n        it to the current thread local (see 
:func:`get_current_context`).\n        The default behavior of this is to invoke the 
cleanup functions which\n        can be disabled by setting `cleanup` to `False`.  The
cleanup\n        functions are typically used for things such as closing file 
handles.\n\n        If the cleanup is intended the context object can also be 
directly\n        used as a context manager.\n\n        Example usage::\n\n           
with ctx.scope():\n                assert get_current_context() is ctx\n\n        This
is equivalent::\n\n            with ctx:\n                assert get_current_context()
is ctx\n\n        .. versionadded:: 5.0\n\n        :param cleanup: controls if the 
cleanup functions should be run or\n                        not.  The default is to 
run these functions.  In\n                        some situations the context only 
wants to be\n                        temporarily pushed in which case this can be 
disabled.\n                        Nested pushes automatically defer the cleanup.\n   
\"\"\"\n        if not cleanup:\n            self._depth += 1\n        try:\n         
with self as rv:\n                yield rv\n        finally:\n            if not 
cleanup:\n                self._depth -= 1"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 529, "end_line": 555, "size": 27, 
"parent_context": "class_definition", "content": "@property\n    def meta(self) -> 
dict:\n        \"\"\"This is a dictionary which is shared with all the contexts\n     
that are nested.  It exists so that click utilities can store some\n        state here
if they need to.  It is however the responsibility of\n        that code to manage 
this dictionary well.\n\n        The keys are supposed to be unique dotted strings.  
For instance\n        module paths are a good choice for it.  What is stored in there 
is\n        irrelevant for the operation of click.  However what is important is\n    
that code that places data here adheres to the general semantics of\n        the 
system.\n\n        Example usage::\n\n            LANG_KEY = f'{__name__}.lang'\n\n   
def set_language(value):\n                ctx = get_current_context()\n               
ctx.meta[LANG_KEY] = value\n\n            def get_language():\n                return 
get_current_context().meta.get(LANG_KEY, 'en_US')\n\n        .. versionadded:: 5.0\n  
\"\"\"\n        return self._meta"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 530, "end_line": 555, "size": 26, 
"parent_context": "decorated_definition", "content": "def meta(self) -> dict:\n       
\"\"\"This is a dictionary which is shared with all the contexts\n        that are 
nested.  It exists so that click utilities can store some\n        state here if they 
need to.  It is however the responsibility of\n        that code to manage this 
dictionary well.\n\n        The keys are supposed to be unique dotted strings.  For 
instance\n        module paths are a good choice for it.  What is stored in there is\n
irrelevant for the operation of click.  However what is important is\n        that 
code that places data here adheres to the general semantics of\n        the 
system.\n\n        Example usage::\n\n            LANG_KEY = f'{__name__}.lang'\n\n   
def set_language(value):\n                ctx = get_current_context()\n               
ctx.meta[LANG_KEY] = value\n\n            def get_language():\n                return 
get_current_context().meta.get(LANG_KEY, 'en_US')\n\n        .. versionadded:: 5.0\n  
\"\"\"\n        return self._meta"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 557, "end_line": 569, "size": 13, 
"parent_context": "class_definition", "content": "def make_formatter(self) -> 
HelpFormatter:\n        \"\"\"Creates the :class:`~click.HelpFormatter` for the help 
and\n        usage output.\n\n        To quickly customize the formatter class used 
without overriding\n        this method, set the :attr:`formatter_class` 
attribute.\n\n        .. versionchanged:: 8.0\n            Added the 
:attr:`formatter_class` attribute.\n        \"\"\"\n        return 
self.formatter_class(\n            width=self.terminal_width, 
max_width=self.max_content_width\n        )"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 571, "end_line": 598, "size": 28, 
"parent_context": "class_definition", "content": "def with_resource(self, 
context_manager: AbstractContextManager[V]) -> V:\n        \"\"\"Register a resource 
as if it were used in a ``with``\n        statement. The resource will be cleaned up 
when the context is\n        popped.\n\n        Uses 
:meth:`contextlib.ExitStack.enter_context`. It calls the\n        resource's 
``__enter__()`` method and returns the result. When\n        the context is popped, it
closes the stack, which calls the\n        resource's ``__exit__()`` method.\n\n      
To register a cleanup function for something that isn't a\n        context manager, 
use :meth:`call_on_close`. Or use something\n        from :mod:`contextlib` to turn it
into a context manager first.\n\n        .. code-block:: python\n\n            
@click.group()\n            @click.option(\"--name\")\n            
@click.pass_context\n            def cli(ctx):\n                ctx.obj = 
ctx.with_resource(connect_db(name))\n\n        :param context_manager: The context 
manager to enter.\n        :return: Whatever ``context_manager.__enter__()`` 
returns.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        return 
self._exit_stack.enter_context(context_manager)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 600, "end_line": 610, "size": 11, 
"parent_context": "class_definition", "content": "def call_on_close(self, f: 
t.Callable[..., t.Any]) -> t.Callable[..., t.Any]:\n        \"\"\"Register a function 
to be called when the context tears down.\n\n        This can be used to close 
resources opened during the script\n        execution. Resources that support Python's
context manager\n        protocol which would be used in a ``with`` statement should 
be\n        registered with :meth:`with_resource` instead.\n\n        :param f: The 
function to execute on teardown.\n        \"\"\"\n        return 
self._exit_stack.callback(f)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 612, "end_line": 619, "size": 8, 
"parent_context": "class_definition", "content": "def close(self) -> None:\n        
\"\"\"Invoke all close callbacks registered with\n        :meth:`call_on_close`, and 
exit all context managers entered\n        with :meth:`with_resource`.\n        
\"\"\"\n        self._exit_stack.close()\n        # In case the context is reused, 
create a new exit stack.\n        self._exit_stack = ExitStack()"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 621, "end_line": 638, "size": 18, 
"parent_context": "class_definition", "content": "@property\n    def 
command_path(self) -> str:\n        \"\"\"The computed command path.  This is used for
the ``usage``\n        information on the help page.  It's automatically created by\n 
combining the info names of the chain of contexts to the root.\n        \"\"\"\n      
rv = \"\"\n        if self.info_name is not None:\n            rv = self.info_name\n  
if self.parent is not None:\n            parent_command_path = \n\n            if 
isinstance(self.parent.command, Command):\n                for param in 
self.parent.command.get_params(self):\n                    
parent_command_path.extend(param.get_usage_pieces(self))\n\n            rv = f\"{' 
'.join(parent_command_path)} {rv}\"\n        return rv.lstrip()"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 622, "end_line": 638, "size": 17, 
"parent_context": "decorated_definition", "content": "def command_path(self) -> str:\n
\"\"\"The computed command path.  This is used for the ``usage``\n        information 
on the help page.  It's automatically created by\n        combining the info names of 
the chain of contexts to the root.\n        \"\"\"\n        rv = \"\"\n        if 
self.info_name is not None:\n            rv = self.info_name\n        if self.parent 
is not None:\n            parent_command_path = \n\n            if 
isinstance(self.parent.command, Command):\n                for param in 
self.parent.command.get_params(self):\n                    
parent_command_path.extend(param.get_usage_pieces(self))\n\n            rv = f\"{' 
'.join(parent_command_path)} {rv}\"\n        return rv.lstrip()"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 640, "end_line": 645, "size": 6, 
"parent_context": "class_definition", "content": "def find_root(self) -> Context:\n   
\"\"\"Finds the outermost context.\"\"\"\n        node = self\n        while 
node.parent is not None:\n            node = node.parent\n        return node"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 647, "end_line": 657, "size": 11, 
"parent_context": "class_definition", "content": "def find_object(self, object_type: 
type[V]) -> V | None:\n        \"\"\"Finds the closest object of a given type.\"\"\"\n
node: Context | None = self\n\n        while node is not None:\n            if 
isinstance(node.obj, object_type):\n                return node.obj\n\n            
node = node.parent\n\n        return None"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 659, "end_line": 666, "size": 8, 
"parent_context": "class_definition", "content": "def ensure_object(self, object_type:
type[V]) -> V:\n        \"\"\"Like :meth:`find_object` but sets the innermost object 
to a\n        new instance of `object_type` if it does not exist.\n        \"\"\"\n   
rv = self.find_object(object_type)\n        if rv is None:\n            self.obj = rv 
= object_type()\n        return rv"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 668, "end_line": 671, "size": 4, 
"parent_context": "class_definition", "content": "@t.overload\n    def 
lookup_default(\n        self, name: str, call: t.Literal[True] = True\n    ) -> t.Any
| None: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 669, "end_line": 671, "size": 3, 
"parent_context": "decorated_definition", "content": "def lookup_default(\n        
self, name: str, call: t.Literal[True] = True\n    ) -> t.Any | None: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 673, "end_line": 676, "size": 4, 
"parent_context": "class_definition", "content": "@t.overload\n    def 
lookup_default(\n        self, name: str, call: t.Literal[False] = ...\n    ) -> t.Any
| t.Callable[[], t.Any] | None: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 674, "end_line": 676, "size": 3, 
"parent_context": "decorated_definition", "content": "def lookup_default(\n        
self, name: str, call: t.Literal[False] = ...\n    ) -> t.Any | t.Callable[[], t.Any] 
| None: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 678, "end_line": 696, "size": 19, 
"parent_context": "class_definition", "content": "def lookup_default(self, name: str, 
call: bool = True) -> t.Any | None:\n        \"\"\"Get the default for a parameter 
from :attr:`default_map`.\n\n        :param name: Name of the parameter.\n        
:param call: If the default is a callable, call it. Disable to\n            return the
callable instead.\n\n        .. versionchanged:: 8.0\n            Added the ``call`` 
parameter.\n        \"\"\"\n        if self.default_map is not None:\n            
value = self.default_map.get(name)\n\n            if call and callable(value):\n      
return value()\n\n            return value\n\n        return None"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 698, "end_line": 704, "size": 7, 
"parent_context": "class_definition", "content": "def fail(self, message: str) -> 
t.NoReturn:\n        \"\"\"Aborts the execution of the program with a specific error\n
message.\n\n        :param message: the error message to fail with.\n        \"\"\"\n 
raise UsageError(message, self)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 706, "end_line": 708, "size": 3, 
"parent_context": "class_definition", "content": "def abort(self) -> t.NoReturn:\n    
\"\"\"Aborts the script.\"\"\"\n        raise Abort()"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 710, "end_line": 718, "size": 9, 
"parent_context": "class_definition", "content": "def exit(self, code: int = 0) -> 
t.NoReturn:\n        \"\"\"Exits the application with a given exit code.\n\n        ..
versionchanged:: 8.2\n            Callbacks and context managers registered with 
:meth:`call_on_close`\n            and :meth:`with_resource` are closed before 
exiting.\n        \"\"\"\n        self.close()\n        raise Exit(code)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 720, "end_line": 724, "size": 5, 
"parent_context": "class_definition", "content": "def get_usage(self) -> str:\n       
\"\"\"Helper method to get formatted usage string for the current\n        context and
command.\n        \"\"\"\n        return self.command.get_usage(self)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 726, "end_line": 730, "size": 5, 
"parent_context": "class_definition", "content": "def get_help(self) -> str:\n        
\"\"\"Helper method to get formatted help page for the current\n        context and 
command.\n        \"\"\"\n        return self.command.get_help(self)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 732, "end_line": 738, "size": 7, 
"parent_context": "class_definition", "content": "def _make_sub_context(self, command:
Command) -> Context:\n        \"\"\"Create a new context of the same type as this 
context, but\n        for a new command.\n\n        :meta private:\n        \"\"\"\n  
return type(self)(command, info_name=command.name, parent=self)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 740, "end_line": 743, "size": 4, 
"parent_context": "class_definition", "content": "@t.overload\n    def invoke(\n      
self, callback: t.Callable[..., V], /, *args: t.Any, **kwargs: t.Any\n    ) -> V: 
..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 741, "end_line": 743, "size": 3, 
"parent_context": "decorated_definition", "content": "def invoke(\n        self, 
callback: t.Callable[..., V], /, *args: t.Any, **kwargs: t.Any\n    ) -> V: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 745, "end_line": 746, "size": 2, 
"parent_context": "class_definition", "content": "@t.overload\n    def invoke(self, 
callback: Command, /, *args: t.Any, **kwargs: t.Any) -> t.Any: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 746, "end_line": 746, "size": 1, 
"parent_context": "decorated_definition", "content": "def invoke(self, callback: 
Command, /, *args: t.Any, **kwargs: t.Any) -> t.Any: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 748, "end_line": 794, "size": 47, 
"parent_context": "class_definition", "content": "def invoke(\n        self, callback:
Command | t.Callable[..., V], /, *args: t.Any, **kwargs: t.Any\n    ) -> t.Any | V:\n 
\"\"\"Invokes a command callback in exactly the way it expects.  There\n        are 
two ways to invoke this method:\n\n        1.  the first argument can be a callback 
and all other arguments and\n            keyword arguments are forwarded directly to 
the function.\n        2.  the first argument is a click command object.  In that case
all\n            arguments are forwarded as well but proper click parameters\n        
(options and click arguments) must be keyword arguments and Click\n            will 
fill in defaults.\n\n        .. versionchanged:: 8.0\n            All ``kwargs`` are 
tracked in :attr:`params` so they will be\n            passed if :meth:`forward` is 
called at multiple levels.\n\n        .. versionchanged:: 3.2\n            A new 
context is created, and missing arguments use default values.\n        \"\"\"\n       
if isinstance(callback, Command):\n            other_cmd = callback\n\n            if 
other_cmd.callback is None:\n                raise TypeError(\n                    
\"The given command does not have a callback that can be invoked.\"\n                
)\n            else:\n                callback = t.cast(\"t.Callable[..., V]\", 
other_cmd.callback)\n\n            ctx = self._make_sub_context(other_cmd)\n\n        
for param in other_cmd.params:\n                if param.name not in kwargs and 
param.expose_value:\n                    kwargs = param.type_cast_value(  # type: 
ignore\n                        ctx, param.get_default(ctx)\n                    )\n\n
# Track all kwargs as params, so that forward() will pass\n            # them on in 
subsequent calls.\n            ctx.params.update(kwargs)\n        else:\n            
ctx = self\n\n        with augment_usage_errors(self):\n            with ctx:\n       
return callback(*args, **kwargs)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 796, "end_line": 813, "size": 18, 
"parent_context": "class_definition", "content": "def forward(self, cmd: Command, /, 
*args: t.Any, **kwargs: t.Any) -> t.Any:\n        \"\"\"Similar to :meth:`invoke` but 
fills in default keyword\n        arguments from the current context if the other 
command expects\n        it.  This cannot invoke callbacks directly, only other 
commands.\n\n        .. versionchanged:: 8.0\n            All ``kwargs`` are tracked 
in :attr:`params` so they will be\n            passed if ``forward`` is called at 
multiple levels.\n        \"\"\"\n        # Can only forward to other commands, not 
direct callbacks.\n        if not isinstance(cmd, Command):\n            raise 
TypeError(\"Callback is not a command.\")\n\n        for param in self.params:\n      
if param not in kwargs:\n                kwargs = self.params\n\n        return 
self.invoke(cmd, *args, **kwargs)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 815, "end_line": 822, "size": 8, 
"parent_context": "class_definition", "content": "def set_parameter_source(self, name:
str, source: ParameterSource) -> None:\n        \"\"\"Set the source of a parameter. 
This indicates the location\n        from which the value of the parameter was 
obtained.\n\n        :param name: The name of the parameter.\n        :param source: A
member of :class:`~click.core.ParameterSource`.\n        \"\"\"\n        
self._parameter_source = source"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 824, "end_line": 840, "size": 17, 
"parent_context": "class_definition", "content": "def get_parameter_source(self, name:
str) -> ParameterSource | None:\n        \"\"\"Get the source of a parameter. This 
indicates the location\n        from which the value of the parameter was 
obtained.\n\n        This can be useful for determining when a user specified a 
value\n        on the command line that is the same as the default value. It\n        
will be :attr:`~click.core.ParameterSource.DEFAULT` only if the\n        value was 
actually taken from the default.\n\n        :param name: The name of the parameter.\n 
:rtype: ParameterSource\n\n        .. versionchanged:: 8.0\n            Returns 
``None`` if the parameter was not provided from any\n            source.\n        
\"\"\"\n        return self._parameter_source.get(name)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"class_definition", "start_line": 843, "end_line": 1442, "size": 600, 
"parent_context": "", "content": "class Command:\n    \"\"\"Commands are the basic 
building block of command line interfaces in\n    Click.  A basic command handles 
command line parsing and might dispatch\n    more parsing to commands nested below 
it.\n\n    :param name: the name of the command to use unless a group overrides it.\n 
:param context_settings: an optional dictionary with defaults that are\n              
passed to the context object.\n    :param callback: the callback to invoke.  This is 
optional.\n    :param params: the parameters to register with this command.  This 
can\n                   be either :class:`Option` or :class:`Argument` objects.\n    
:param help: the help string to use for this command.\n    :param epilog: like the 
help string but it's printed at the end of the\n                   help page after 
everything else.\n    :param short_help: the short help to use for this command.  This
is\n                       shown on the command listing of the parent command.\n    
:param add_help_option: by default each command registers a ``--help``\n              
option.  This can be disabled by this parameter.\n    :param no_args_is_help: this 
controls what happens if no arguments are\n                            provided.  This
option is disabled by default.\n                            If enabled this will add 
``--help`` as argument\n                            if no arguments are passed\n    
:param hidden: hide this command from help outputs.\n    :param deprecated: If 
``True`` or non-empty string, issues a message\n                        indicating 
that the command is deprecated and highlights\n                        its deprecation
in --help. The message can be customized\n                        by using a string as
the value.\n\n    .. versionchanged:: 8.2\n        This is the base class for all 
commands, not ``BaseCommand``.\n        ``deprecated`` can be set to a string as well 
to customize the\n        deprecation message.\n\n    .. versionchanged:: 8.1\n       
``help``, ``epilog``, and ``short_help`` are stored unprocessed,\n        all 
formatting is done when outputting help text, not at init,\n        and is done even 
if not using the ``@command`` decorator.\n\n    .. versionchanged:: 8.0\n        Added
a ``repr`` showing the command name.\n\n    .. versionchanged:: 7.1\n        Added the
``no_args_is_help`` parameter.\n\n    .. versionchanged:: 2.0\n        Added the 
``context_settings`` parameter.\n    \"\"\"\n\n    #: The context class to create with
:meth:`make_context`.\n    #:\n    #: .. versionadded:: 8.0\n    context_class: 
type[Context] = Context\n\n    #: the default for the :attr:`Context.allow_extra_args`
flag.\n    allow_extra_args = False\n\n    #: the default for the 
:attr:`Context.allow_interspersed_args` flag.\n    allow_interspersed_args = True\n\n 
#: the default for the :attr:`Context.ignore_unknown_options` flag.\n    
ignore_unknown_options = False\n\n    def __init__(\n        self,\n        name: str 
| None,\n        context_settings: cabc.MutableMapping | None = None,\n        
callback: t.Callable[..., t.Any] | None = None,\n        params: list[Parameter] | 
None = None,\n        help: str | None = None,\n        epilog: str | None = None,\n  
short_help: str | None = None,\n        options_metavar: str | None = \"[OPTIONS]\",\n
add_help_option: bool = True,\n        no_args_is_help: bool = False,\n        hidden:
bool = False,\n        deprecated: bool | str = False,\n    ) -> None:\n        #: the
name the command thinks it has.  Upon registering a command\n        #: on a 
:class:`Group` the group will default the command name\n        #: with this 
information.  You should instead use the\n        #: :class:`Context`\\'s 
:attr:`~Context.info_name` attribute.\n        self.name = name\n\n        if 
context_settings is None:\n            context_settings = {}\n\n        #: an optional
dictionary with defaults passed to the context.\n        self.context_settings: 
cabc.MutableMapping = context_settings\n\n        #: the callback to execute when the 
command fires.  This might be\n        #: `None` in which case nothing happens.\n     
self.callback = callback\n        #: the list of parameters for this command in the 
order they\n        #: should show up in the help page and execute.  Eager 
parameters\n        #: will automatically be handled before non eager ones.\n        
self.params: list[Parameter] = params or []\n        self.help = help\n        
self.epilog = epilog\n        self.options_metavar = options_metavar\n        
self.short_help = short_help\n        self.add_help_option = add_help_option\n        
self._help_option = None\n        self.no_args_is_help = no_args_is_help\n        
self.hidden = hidden\n        self.deprecated = deprecated\n\n    def 
to_info_dict(self, ctx: Context) -> dict:\n        return {\n            \"name\": 
self.name,\n            \"params\": ,\n            \"help\": self.help,\n            
\"epilog\": self.epilog,\n            \"short_help\": self.short_help,\n            
\"hidden\": self.hidden,\n            \"deprecated\": self.deprecated,\n        }\n\n 
def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__} 
{self.name}>\"\n\n    def get_usage(self, ctx: Context) -> str:\n        \"\"\"Formats
the usage line into a string and returns it.\n\n        Calls :meth:`format_usage` 
internally.\n        \"\"\"\n        formatter = ctx.make_formatter()\n        
self.format_usage(ctx, formatter)\n        return 
formatter.getvalue().rstrip(\"\\n\")\n\n    def get_params(self, ctx: Context) -> 
list[Parameter]:\n        params = self.params\n        help_option = 
self.get_help_option(ctx)\n\n        if help_option is not None:\n            params =
[*params, help_option]\n\n        if __debug__:\n            import warnings\n\n      
opts = \n            opts_counter = Counter(opts)\n            duplicate_opts = (opt 
for opt, count in opts_counter.items() if count > 1)\n\n            for duplicate_opt 
in duplicate_opts:\n                warnings.warn(\n                    (\n           
f\"The parameter {duplicate_opt} is used more than once. \"\n                        
\"Remove its duplicate as parameters should be unique.\"\n                    ),\n    
stacklevel=3,\n                )\n\n        return params\n\n    def 
format_usage(self, ctx: Context, formatter: HelpFormatter) -> None:\n        
\"\"\"Writes the usage line into the formatter.\n\n        This is a low-level method 
called by :meth:`get_usage`.\n        \"\"\"\n        pieces = 
self.collect_usage_pieces(ctx)\n        formatter.write_usage(ctx.command_path, \" 
\".join(pieces))\n\n    def collect_usage_pieces(self, ctx: Context) -> list:\n       
\"\"\"Returns all the pieces that go into the usage line and returns\n        it as a 
list of strings.\n        \"\"\"\n        rv =  if self.options_metavar else []\n\n   
for param in self.get_params(ctx):\n            
rv.extend(param.get_usage_pieces(ctx))\n\n        return rv\n\n    def 
get_help_option_names(self, ctx: Context) -> list:\n        \"\"\"Returns the names 
for the help option.\"\"\"\n        all_names = set(ctx.help_option_names)\n        
for param in self.params:\n            all_names.difference_update(param.opts)\n      
all_names.difference_update(param.secondary_opts)\n        return list(all_names)\n\n 
def get_help_option(self, ctx: Context) -> Option | None:\n        \"\"\"Returns the 
help option object.\n\n        Skipped if :attr:`add_help_option` is ``False``.\n\n   
.. versionchanged:: 8.1.8\n            The help option is now cached to avoid creating
it multiple times.\n        \"\"\"\n        help_option_names = 
self.get_help_option_names(ctx)\n\n        if not help_option_names or not 
self.add_help_option:\n            return None\n\n        # Cache the help option 
object in private _help_option attribute to\n        # avoid creating it multiple 
times. Not doing this will break the\n        # callback odering by 
iter_params_for_processing(), which relies on\n        # object comparison.\n        
if self._help_option is None:\n            # Avoid circular import.\n            from 
.decorators import help_option\n\n            # Apply help_option decorator and pop 
resulting option\n            help_option(*help_option_names)(self)\n            
self._help_option = self.params.pop()  # type: ignore\n\n        return 
self._help_option\n\n    def make_parser(self, ctx: Context) -> _OptionParser:\n      
\"\"\"Creates the underlying option parser for this command.\"\"\"\n        parser = 
_OptionParser(ctx)\n        for param in self.get_params(ctx):\n            
param.add_to_parser(parser, ctx)\n        return parser\n\n    def get_help(self, ctx:
Context) -> str:\n        \"\"\"Formats the help into a string and returns it.\n\n    
Calls :meth:`format_help` internally.\n        \"\"\"\n        formatter = 
ctx.make_formatter()\n        self.format_help(ctx, formatter)\n        return 
formatter.getvalue().rstrip(\"\\n\")\n\n    def get_short_help_str(self, limit: int = 
45) -> str:\n        \"\"\"Gets short help for the command or makes it by shortening 
the\n        long help string.\n        \"\"\"\n        if self.short_help:\n         
text = inspect.cleandoc(self.short_help)\n        elif self.help:\n            text = 
make_default_short_help(self.help, limit)\n        else:\n            text = \"\"\n\n 
if self.deprecated:\n            deprecated_message = (\n                
f\"(DEPRECATED: {self.deprecated})\"\n                if isinstance(self.deprecated, 
str)\n                else \"(DEPRECATED)\"\n            )\n            text = 
_(\"{text} {deprecated_message}\").format(\n                text=text, 
deprecated_message=deprecated_message\n            )\n\n        return 
text.strip()\n\n    def format_help(self, ctx: Context, formatter: HelpFormatter) -> 
None:\n        \"\"\"Writes the help into the formatter if it exists.\n\n        This 
is a low-level method called by :meth:`get_help`.\n\n        This calls the following 
methods:\n\n        -   :meth:`format_usage`\n        -   :meth:`format_help_text`\n  
-   :meth:`format_options`\n        -   :meth:`format_epilog`\n        \"\"\"\n       
self.format_usage(ctx, formatter)\n        self.format_help_text(ctx, formatter)\n    
self.format_options(ctx, formatter)\n        self.format_epilog(ctx, formatter)\n\n   
def format_help_text(self, ctx: Context, formatter: HelpFormatter) -> None:\n        
\"\"\"Writes the help text to the formatter if it exists.\"\"\"\n        if self.help 
is not None:\n            # truncate the help text to the first form feed\n           
text = inspect.cleandoc(self.help).partition(\"\\f\")[0]\n        else:\n            
text = \"\"\n\n        if self.deprecated:\n            deprecated_message = (\n      
f\"(DEPRECATED: {self.deprecated})\"\n                if isinstance(self.deprecated, 
str)\n                else \"(DEPRECATED)\"\n            )\n            text = 
_(\"{text} {deprecated_message}\").format(\n                text=text, 
deprecated_message=deprecated_message\n            )\n\n        if text:\n            
formatter.write_paragraph()\n\n            with formatter.indentation():\n            
formatter.write_text(text)\n\n    def format_options(self, ctx: Context, formatter: 
HelpFormatter) -> None:\n        \"\"\"Writes all the options into the formatter if 
they exist.\"\"\"\n        opts = []\n        for param in self.get_params(ctx):\n    
rv = param.get_help_record(ctx)\n            if rv is not None:\n                
opts.append(rv)\n\n        if opts:\n            with 
formatter.section(_(\"Options\")):\n                formatter.write_dl(opts)\n\n    
def format_epilog(self, ctx: Context, formatter: HelpFormatter) -> None:\n        
\"\"\"Writes the epilog into the formatter if it exists.\"\"\"\n        if 
self.epilog:\n            epilog = inspect.cleandoc(self.epilog)\n            
formatter.write_paragraph()\n\n            with formatter.indentation():\n            
formatter.write_text(epilog)\n\n    def make_context(\n        self,\n        
info_name: str | None,\n        args: list,\n        parent: Context | None = None,\n 
**extra: t.Any,\n    ) -> Context:\n        \"\"\"This function when given an info 
name and arguments will kick\n        off the parsing and create a new 
:class:`Context`.  It does not\n        invoke the actual command callback though.\n\n
To quickly customize the context class used without overriding\n        this method, 
set the :attr:`context_class` attribute.\n\n        :param info_name: the info name 
for this invocation.  Generally this\n                          is the most 
descriptive name for the script or\n                          command.  For the 
toplevel script it's usually\n                          the name of the script, for 
commands below it's\n                          the name of the command.\n        
:param args: the arguments to parse as list of strings.\n        :param parent: the 
parent context if available.\n        :param extra: extra keyword arguments forwarded 
to the context\n                      constructor.\n\n        .. versionchanged:: 
8.0\n            Added the :attr:`context_class` attribute.\n        \"\"\"\n        
for key, value in self.context_settings.items():\n            if key not in extra:\n  
extra = value\n\n        ctx = self.context_class(self, info_name=info_name, 
parent=parent, **extra)\n\n        with ctx.scope(cleanup=False):\n            
self.parse_args(ctx, args)\n        return ctx\n\n    def parse_args(self, ctx: 
Context, args: list) -> list:\n        if not args and self.no_args_is_help and not 
ctx.resilient_parsing:\n            raise NoArgsIsHelpError(ctx)\n\n        parser = 
self.make_parser(ctx)\n        opts, args, param_order = 
parser.parse_args(args=args)\n\n        for param in 
iter_params_for_processing(param_order, self.get_params(ctx)):\n            value, 
args = param.handle_parse_result(ctx, opts, args)\n\n        if args and not 
ctx.allow_extra_args and not ctx.resilient_parsing:\n            ctx.fail(\n          
ngettext(\n                    \"Got unexpected extra argument ({args})\",\n          
\"Got unexpected extra arguments ({args})\",\n                    len(args),\n        
).format(args=\" \".join(map(str, args)))\n            )\n\n        ctx.args = args\n 
ctx._opt_prefixes.update(parser._opt_prefixes)\n        return args\n\n    def 
invoke(self, ctx: Context) -> t.Any:\n        \"\"\"Given a context, this invokes the 
attached callback (if it exists)\n        in the right way.\n        \"\"\"\n        
if self.deprecated:\n            extra_message = (\n                f\" 
{self.deprecated}\" if isinstance(self.deprecated, str) else \"\"\n            )\n    
message = _(\n                \"DeprecationWarning: The command {name!r} is 
deprecated.{extra_message}\"\n            ).format(name=self.name, 
extra_message=extra_message)\n            echo(style(message, fg=\"red\"), 
err=True)\n\n        if self.callback is not None:\n            return 
ctx.invoke(self.callback, **ctx.params)\n\n    def shell_complete(self, ctx: Context, 
incomplete: str) -> list[CompletionItem]:\n        \"\"\"Return a list of completions 
for the incomplete value. Looks\n        at the names of options and chained 
multi-commands.\n\n        Any command could be part of a chained multi-command, so 
sibling\n        commands are valid at any point during command completion.\n\n       
:param ctx: Invocation context for this command.\n        :param incomplete: Value 
being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n     
from click.shell_completion import CompletionItem\n\n        results: 
list[CompletionItem] = []\n\n        if incomplete and not incomplete[0].isalnum():\n 
for param in self.get_params(ctx):\n                if (\n                    not 
isinstance(param, Option)\n                    or param.hidden\n                    or
(\n                        not param.multiple\n                        and 
ctx.get_parameter_source(param.name)  # type: ignore\n                        is 
ParameterSource.COMMANDLINE\n                    )\n                ):\n              
continue\n\n                results.extend(\n                    CompletionItem(name, 
help=param.help)\n                    for name in [*param.opts, 
*param.secondary_opts]\n                    if name.startswith(incomplete)\n          
)\n\n        while ctx.parent is not None:\n            ctx = ctx.parent\n\n          
if isinstance(ctx.command, Group) and ctx.command.chain:\n                
results.extend(\n                    CompletionItem(name, 
help=command.get_short_help_str())\n                    for name, command in 
_complete_visible_commands(ctx, incomplete)\n                    if name not in 
ctx._protected_args\n                )\n\n        return results\n\n    @t.overload\n 
def main(\n        self,\n        args: cabc.Sequence | None = None,\n        
prog_name: str | None = None,\n        complete_var: str | None = None,\n        
standalone_mode: t.Literal[True] = True,\n        **extra: t.Any,\n    ) -> 
t.NoReturn: ...\n\n    @t.overload\n    def main(\n        self,\n        args: 
cabc.Sequence | None = None,\n        prog_name: str | None = None,\n        
complete_var: str | None = None,\n        standalone_mode: bool = ...,\n        
**extra: t.Any,\n    ) -> t.Any: ...\n\n    def main(\n        self,\n        args: 
cabc.Sequence | None = None,\n        prog_name: str | None = None,\n        
complete_var: str | None = None,\n        standalone_mode: bool = True,\n        
windows_expand_args: bool = True,\n        **extra: t.Any,\n    ) -> t.Any:\n        
\"\"\"This is the way to invoke a script with all the bells and\n        whistles as a
command line application.  This will always terminate\n        the application after a
call.  If this is not wanted, ``SystemExit``\n        needs to be caught.\n\n        
This method is also available by directly calling the instance of\n        a 
:class:`Command`.\n\n        :param args: the arguments that should be used for 
parsing.  If not\n                     provided, ``sys.argv[1:]`` is used.\n        
:param prog_name: the program name that should be used.  By default\n                 
the program name is constructed by taking the file\n                          name 
from ``sys.argv[0]``.\n        :param complete_var: the environment variable that 
controls the\n                             bash completion support.  The default is\n 
``\"_<prog_name>_COMPLETE\"`` with prog_name in\n                             
uppercase.\n        :param standalone_mode: the default behavior is to invoke the 
script\n                                in standalone mode.  Click will then\n        
handle exceptions and convert them into\n                                error 
messages and the function will never\n                                return but shut 
down the interpreter.  If\n                                this is set to `False` they
will be\n                                propagated to the caller and the return\n    
value of this function is the return value\n                                of 
:meth:`invoke`.\n        :param windows_expand_args: Expand glob patterns, user dir, 
and\n            env vars in command line args on Windows.\n        :param extra: 
extra keyword arguments are forwarded to the context\n                      
constructor.  See :class:`Context` for more information.\n\n        .. 
versionchanged:: 8.0.1\n            Added the ``windows_expand_args`` parameter to 
allow\n            disabling command line arg expansion on Windows.\n\n        .. 
versionchanged:: 8.0\n            When taking arguments from ``sys.argv`` on Windows, 
glob\n            patterns, user dir, and env vars are expanded.\n\n        .. 
versionchanged:: 3.0\n           Added the ``standalone_mode`` parameter.\n        
\"\"\"\n        if args is None:\n            args = sys.argv[1:]\n\n            if 
os.name == \"nt\" and windows_expand_args:\n                args = 
_expand_args(args)\n        else:\n            args = list(args)\n\n        if 
prog_name is None:\n            prog_name = _detect_program_name()\n\n        # 
Process shell completion requests and exit early.\n        
self._main_shell_completion(extra, prog_name, complete_var)\n\n        try:\n         
try:\n                with self.make_context(prog_name, args, **extra) as ctx:\n      
rv = self.invoke(ctx)\n                    if not standalone_mode:\n                  
return rv\n                    # it's not safe to `ctx.exit(rv)` here!\n              
# note that `rv` may actually contain data like \"1\" which\n                    # has
obvious effects\n                    # more subtle case: `rv=[None, None]` can come 
out of\n                    # chained commands which all returned `None` -- so it's 
not\n                    # even always obvious that `rv` indicates success/failure\n  
# by its truthiness/falsiness\n                    ctx.exit()\n            except 
(EOFError, KeyboardInterrupt) as e:\n                echo(file=sys.stderr)\n          
raise Abort() from e\n            except ClickException as e:\n                if not 
standalone_mode:\n                    raise\n                e.show()\n               
sys.exit(e.exit_code)\n            except OSError as e:\n                if e.errno ==
errno.EPIPE:\n                    sys.stdout = t.cast(t.TextIO, 
PacifyFlushWrapper(sys.stdout))\n                    sys.stderr = t.cast(t.TextIO, 
PacifyFlushWrapper(sys.stderr))\n                    sys.exit(1)\n                
else:\n                    raise\n        except Exit as e:\n            if 
standalone_mode:\n                sys.exit(e.exit_code)\n            else:\n          
# in non-standalone mode, return the exit code\n                # note that this is 
only reached if `self.invoke` above raises\n                # an Exit explicitly -- 
thus bypassing the check there which\n                # would return its result\n     
# the results of non-standalone execution may therefore be\n                # somewhat
ambiguous: if there are codepaths which lead to\n                # `ctx.exit(1)` and 
to `return 1`, the caller won't be able to\n                # tell the difference 
between the two\n                return e.exit_code\n        except Abort:\n          
if not standalone_mode:\n                raise\n            echo(_(\"Aborted!\"), 
file=sys.stderr)\n            sys.exit(1)\n\n    def _main_shell_completion(\n        
self,\n        ctx_args: cabc.MutableMapping,\n        prog_name: str,\n        
complete_var: str | None = None,\n    ) -> None:\n        \"\"\"Check if the shell is 
asking for tab completion, process\n        that, then exit early. Called from 
:meth:`main` before the\n        program is invoked.\n\n        :param prog_name: Name
of the executable in the shell.\n        :param complete_var: Name of the environment 
variable that holds\n            the completion instruction. Defaults to\n            
``_{PROG_NAME}_COMPLETE``.\n\n        .. versionchanged:: 8.2.0\n            Dots 
(``.``) in ``prog_name`` are replaced with underscores (``_``).\n        \"\"\"\n     
if complete_var is None:\n            complete_name = prog_name.replace(\"-\", 
\"_\").replace(\".\", \"_\")\n            complete_var = 
f\"_{complete_name}_COMPLETE\".upper()\n\n        instruction = 
os.environ.get(complete_var)\n\n        if not instruction:\n            return\n\n   
from .shell_completion import shell_complete\n\n        rv = shell_complete(self, 
ctx_args, prog_name, complete_var, instruction)\n        sys.exit(rv)\n\n    def 
__call__(self, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        \"\"\"Alias for 
:meth:`main`.\"\"\"\n        return self.main(*args, **kwargs)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 905, "end_line": 947, "size": 43, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
name: str | None,\n        context_settings: cabc.MutableMapping | None = None,\n     
callback: t.Callable[..., t.Any] | None = None,\n        params: list[Parameter] | 
None = None,\n        help: str | None = None,\n        epilog: str | None = None,\n  
short_help: str | None = None,\n        options_metavar: str | None = \"[OPTIONS]\",\n
add_help_option: bool = True,\n        no_args_is_help: bool = False,\n        hidden:
bool = False,\n        deprecated: bool | str = False,\n    ) -> None:\n        #: the
name the command thinks it has.  Upon registering a command\n        #: on a 
:class:`Group` the group will default the command name\n        #: with this 
information.  You should instead use the\n        #: :class:`Context`\\'s 
:attr:`~Context.info_name` attribute.\n        self.name = name\n\n        if 
context_settings is None:\n            context_settings = {}\n\n        #: an optional
dictionary with defaults passed to the context.\n        self.context_settings: 
cabc.MutableMapping = context_settings\n\n        #: the callback to execute when the 
command fires.  This might be\n        #: `None` in which case nothing happens.\n     
self.callback = callback\n        #: the list of parameters for this command in the 
order they\n        #: should show up in the help page and execute.  Eager 
parameters\n        #: will automatically be handled before non eager ones.\n        
self.params: list[Parameter] = params or []\n        self.help = help\n        
self.epilog = epilog\n        self.options_metavar = options_metavar\n        
self.short_help = short_help\n        self.add_help_option = add_help_option\n        
self._help_option = None\n        self.no_args_is_help = no_args_is_help\n        
self.hidden = hidden\n        self.deprecated = deprecated"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 949, "end_line": 958, "size": 10, 
"parent_context": "class_definition", "content": "def to_info_dict(self, ctx: Context)
-> dict:\n        return {\n            \"name\": self.name,\n            \"params\": 
,\n            \"help\": self.help,\n            \"epilog\": self.epilog,\n           
\"short_help\": self.short_help,\n            \"hidden\": self.hidden,\n            
\"deprecated\": self.deprecated,\n        }"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 960, "end_line": 961, "size": 2, 
"parent_context": "class_definition", "content": "def __repr__(self) -> str:\n        
return f\"<{self.__class__.__name__} {self.name}>\""}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 963, "end_line": 970, "size": 8, 
"parent_context": "class_definition", "content": "def get_usage(self, ctx: Context) ->
str:\n        \"\"\"Formats the usage line into a string and returns it.\n\n        
Calls :meth:`format_usage` internally.\n        \"\"\"\n        formatter = 
ctx.make_formatter()\n        self.format_usage(ctx, formatter)\n        return 
formatter.getvalue().rstrip(\"\\n\")"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 972, "end_line": 995, "size": 24, 
"parent_context": "class_definition", "content": "def get_params(self, ctx: Context) 
-> list[Parameter]:\n        params = self.params\n        help_option = 
self.get_help_option(ctx)\n\n        if help_option is not None:\n            params =
[*params, help_option]\n\n        if __debug__:\n            import warnings\n\n      
opts = \n            opts_counter = Counter(opts)\n            duplicate_opts = (opt 
for opt, count in opts_counter.items() if count > 1)\n\n            for duplicate_opt 
in duplicate_opts:\n                warnings.warn(\n                    (\n           
f\"The parameter {duplicate_opt} is used more than once. \"\n                        
\"Remove its duplicate as parameters should be unique.\"\n                    ),\n    
stacklevel=3,\n                )\n\n        return params"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 997, "end_line": 1003, "size": 7, 
"parent_context": "class_definition", "content": "def format_usage(self, ctx: Context,
formatter: HelpFormatter) -> None:\n        \"\"\"Writes the usage line into the 
formatter.\n\n        This is a low-level method called by :meth:`get_usage`.\n       
\"\"\"\n        pieces = self.collect_usage_pieces(ctx)\n        
formatter.write_usage(ctx.command_path, \" \".join(pieces))"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1005, "end_line": 1014, "size": 10, 
"parent_context": "class_definition", "content": "def collect_usage_pieces(self, ctx: 
Context) -> list:\n        \"\"\"Returns all the pieces that go into the usage line 
and returns\n        it as a list of strings.\n        \"\"\"\n        rv =  if 
self.options_metavar else []\n\n        for param in self.get_params(ctx):\n          
rv.extend(param.get_usage_pieces(ctx))\n\n        return rv"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1016, "end_line": 1022, "size": 7, 
"parent_context": "class_definition", "content": "def get_help_option_names(self, ctx:
Context) -> list:\n        \"\"\"Returns the names for the help option.\"\"\"\n       
all_names = set(ctx.help_option_names)\n        for param in self.params:\n           
all_names.difference_update(param.opts)\n            
all_names.difference_update(param.secondary_opts)\n        return list(all_names)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1024, "end_line": 1049, "size": 26, 
"parent_context": "class_definition", "content": "def get_help_option(self, ctx: 
Context) -> Option | None:\n        \"\"\"Returns the help option object.\n\n        
Skipped if :attr:`add_help_option` is ``False``.\n\n        .. versionchanged:: 
8.1.8\n            The help option is now cached to avoid creating it multiple 
times.\n        \"\"\"\n        help_option_names = 
self.get_help_option_names(ctx)\n\n        if not help_option_names or not 
self.add_help_option:\n            return None\n\n        # Cache the help option 
object in private _help_option attribute to\n        # avoid creating it multiple 
times. Not doing this will break the\n        # callback odering by 
iter_params_for_processing(), which relies on\n        # object comparison.\n        
if self._help_option is None:\n            # Avoid circular import.\n            from 
.decorators import help_option\n\n            # Apply help_option decorator and pop 
resulting option\n            help_option(*help_option_names)(self)\n            
self._help_option = self.params.pop()  # type: ignore\n\n        return 
self._help_option"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1051, "end_line": 1056, "size": 6, 
"parent_context": "class_definition", "content": "def make_parser(self, ctx: Context) 
-> _OptionParser:\n        \"\"\"Creates the underlying option parser for this 
command.\"\"\"\n        parser = _OptionParser(ctx)\n        for param in 
self.get_params(ctx):\n            param.add_to_parser(parser, ctx)\n        return 
parser"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1058, "end_line": 1065, "size": 8, 
"parent_context": "class_definition", "content": "def get_help(self, ctx: Context) -> 
str:\n        \"\"\"Formats the help into a string and returns it.\n\n        Calls 
:meth:`format_help` internally.\n        \"\"\"\n        formatter = 
ctx.make_formatter()\n        self.format_help(ctx, formatter)\n        return 
formatter.getvalue().rstrip(\"\\n\")"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1067, "end_line": 1088, "size": 22, 
"parent_context": "class_definition", "content": "def get_short_help_str(self, limit: 
int = 45) -> str:\n        \"\"\"Gets short help for the command or makes it by 
shortening the\n        long help string.\n        \"\"\"\n        if 
self.short_help:\n            text = inspect.cleandoc(self.short_help)\n        elif 
self.help:\n            text = make_default_short_help(self.help, limit)\n        
else:\n            text = \"\"\n\n        if self.deprecated:\n            
deprecated_message = (\n                f\"(DEPRECATED: {self.deprecated})\"\n        
if isinstance(self.deprecated, str)\n                else \"(DEPRECATED)\"\n          
)\n            text = _(\"{text} {deprecated_message}\").format(\n                
text=text, deprecated_message=deprecated_message\n            )\n\n        return 
text.strip()"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1090, "end_line": 1105, "size": 16, 
"parent_context": "class_definition", "content": "def format_help(self, ctx: Context, 
formatter: HelpFormatter) -> None:\n        \"\"\"Writes the help into the formatter 
if it exists.\n\n        This is a low-level method called by :meth:`get_help`.\n\n   
This calls the following methods:\n\n        -   :meth:`format_usage`\n        -   
:meth:`format_help_text`\n        -   :meth:`format_options`\n        -   
:meth:`format_epilog`\n        \"\"\"\n        self.format_usage(ctx, formatter)\n    
self.format_help_text(ctx, formatter)\n        self.format_options(ctx, formatter)\n  
self.format_epilog(ctx, formatter)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1107, "end_line": 1129, "size": 23, 
"parent_context": "class_definition", "content": "def format_help_text(self, ctx: 
Context, formatter: HelpFormatter) -> None:\n        \"\"\"Writes the help text to the
formatter if it exists.\"\"\"\n        if self.help is not None:\n            # 
truncate the help text to the first form feed\n            text = 
inspect.cleandoc(self.help).partition(\"\\f\")[0]\n        else:\n            text = 
\"\"\n\n        if self.deprecated:\n            deprecated_message = (\n             
f\"(DEPRECATED: {self.deprecated})\"\n                if isinstance(self.deprecated, 
str)\n                else \"(DEPRECATED)\"\n            )\n            text = 
_(\"{text} {deprecated_message}\").format(\n                text=text, 
deprecated_message=deprecated_message\n            )\n\n        if text:\n            
formatter.write_paragraph()\n\n            with formatter.indentation():\n            
formatter.write_text(text)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1131, "end_line": 1141, "size": 11, 
"parent_context": "class_definition", "content": "def format_options(self, ctx: 
Context, formatter: HelpFormatter) -> None:\n        \"\"\"Writes all the options into
the formatter if they exist.\"\"\"\n        opts = []\n        for param in 
self.get_params(ctx):\n            rv = param.get_help_record(ctx)\n            if rv 
is not None:\n                opts.append(rv)\n\n        if opts:\n            with 
formatter.section(_(\"Options\")):\n                formatter.write_dl(opts)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1143, "end_line": 1150, "size": 8, 
"parent_context": "class_definition", "content": "def format_epilog(self, ctx: 
Context, formatter: HelpFormatter) -> None:\n        \"\"\"Writes the epilog into the 
formatter if it exists.\"\"\"\n        if self.epilog:\n            epilog = 
inspect.cleandoc(self.epilog)\n            formatter.write_paragraph()\n\n            
with formatter.indentation():\n                formatter.write_text(epilog)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1152, "end_line": 1187, "size": 36, 
"parent_context": "class_definition", "content": "def make_context(\n        self,\n  
info_name: str | None,\n        args: list,\n        parent: Context | None = None,\n 
**extra: t.Any,\n    ) -> Context:\n        \"\"\"This function when given an info 
name and arguments will kick\n        off the parsing and create a new 
:class:`Context`.  It does not\n        invoke the actual command callback though.\n\n
To quickly customize the context class used without overriding\n        this method, 
set the :attr:`context_class` attribute.\n\n        :param info_name: the info name 
for this invocation.  Generally this\n                          is the most 
descriptive name for the script or\n                          command.  For the 
toplevel script it's usually\n                          the name of the script, for 
commands below it's\n                          the name of the command.\n        
:param args: the arguments to parse as list of strings.\n        :param parent: the 
parent context if available.\n        :param extra: extra keyword arguments forwarded 
to the context\n                      constructor.\n\n        .. versionchanged:: 
8.0\n            Added the :attr:`context_class` attribute.\n        \"\"\"\n        
for key, value in self.context_settings.items():\n            if key not in extra:\n  
extra = value\n\n        ctx = self.context_class(self, info_name=info_name, 
parent=parent, **extra)\n\n        with ctx.scope(cleanup=False):\n            
self.parse_args(ctx, args)\n        return ctx"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1189, "end_line": 1210, "size": 22, 
"parent_context": "class_definition", "content": "def parse_args(self, ctx: Context, 
args: list) -> list:\n        if not args and self.no_args_is_help and not 
ctx.resilient_parsing:\n            raise NoArgsIsHelpError(ctx)\n\n        parser = 
self.make_parser(ctx)\n        opts, args, param_order = 
parser.parse_args(args=args)\n\n        for param in 
iter_params_for_processing(param_order, self.get_params(ctx)):\n            value, 
args = param.handle_parse_result(ctx, opts, args)\n\n        if args and not 
ctx.allow_extra_args and not ctx.resilient_parsing:\n            ctx.fail(\n          
ngettext(\n                    \"Got unexpected extra argument ({args})\",\n          
\"Got unexpected extra arguments ({args})\",\n                    len(args),\n        
).format(args=\" \".join(map(str, args)))\n            )\n\n        ctx.args = args\n 
ctx._opt_prefixes.update(parser._opt_prefixes)\n        return args"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1212, "end_line": 1226, "size": 15, 
"parent_context": "class_definition", "content": "def invoke(self, ctx: Context) -> 
t.Any:\n        \"\"\"Given a context, this invokes the attached callback (if it 
exists)\n        in the right way.\n        \"\"\"\n        if self.deprecated:\n     
extra_message = (\n                f\" {self.deprecated}\" if 
isinstance(self.deprecated, str) else \"\"\n            )\n            message = _(\n 
\"DeprecationWarning: The command {name!r} is deprecated.{extra_message}\"\n          
).format(name=self.name, extra_message=extra_message)\n            echo(style(message,
fg=\"red\"), err=True)\n\n        if self.callback is not None:\n            return 
ctx.invoke(self.callback, **ctx.params)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1228, "end_line": 1273, "size": 46, 
"parent_context": "class_definition", "content": "def shell_complete(self, ctx: 
Context, incomplete: str) -> list[CompletionItem]:\n        \"\"\"Return a list of 
completions for the incomplete value. Looks\n        at the names of options and 
chained multi-commands.\n\n        Any command could be part of a chained 
multi-command, so sibling\n        commands are valid at any point during command 
completion.\n\n        :param ctx: Invocation context for this command.\n        
:param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 
8.0\n        \"\"\"\n        from click.shell_completion import CompletionItem\n\n    
results: list[CompletionItem] = []\n\n        if incomplete and not 
incomplete[0].isalnum():\n            for param in self.get_params(ctx):\n            
if (\n                    not isinstance(param, Option)\n                    or 
param.hidden\n                    or (\n                        not param.multiple\n  
and ctx.get_parameter_source(param.name)  # type: ignore\n                        is 
ParameterSource.COMMANDLINE\n                    )\n                ):\n              
continue\n\n                results.extend(\n                    CompletionItem(name, 
help=param.help)\n                    for name in [*param.opts, 
*param.secondary_opts]\n                    if name.startswith(incomplete)\n          
)\n\n        while ctx.parent is not None:\n            ctx = ctx.parent\n\n          
if isinstance(ctx.command, Group) and ctx.command.chain:\n                
results.extend(\n                    CompletionItem(name, 
help=command.get_short_help_str())\n                    for name, command in 
_complete_visible_commands(ctx, incomplete)\n                    if name not in 
ctx._protected_args\n                )\n\n        return results"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 1275, "end_line": 1283, "size": 9, 
"parent_context": "class_definition", "content": "@t.overload\n    def main(\n        
self,\n        args: cabc.Sequence | None = None,\n        prog_name: str | None = 
None,\n        complete_var: str | None = None,\n        standalone_mode: 
t.Literal[True] = True,\n        **extra: t.Any,\n    ) -> t.NoReturn: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1276, "end_line": 1283, "size": 8, 
"parent_context": "decorated_definition", "content": "def main(\n        self,\n      
args: cabc.Sequence | None = None,\n        prog_name: str | None = None,\n        
complete_var: str | None = None,\n        standalone_mode: t.Literal[True] = True,\n  
**extra: t.Any,\n    ) -> t.NoReturn: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 1285, "end_line": 1293, "size": 9, 
"parent_context": "class_definition", "content": "@t.overload\n    def main(\n        
self,\n        args: cabc.Sequence | None = None,\n        prog_name: str | None = 
None,\n        complete_var: str | None = None,\n        standalone_mode: bool = 
...,\n        **extra: t.Any,\n    ) -> t.Any: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1286, "end_line": 1293, "size": 8, 
"parent_context": "decorated_definition", "content": "def main(\n        self,\n      
args: cabc.Sequence | None = None,\n        prog_name: str | None = None,\n        
complete_var: str | None = None,\n        standalone_mode: bool = ...,\n        
**extra: t.Any,\n    ) -> t.Any: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1295, "end_line": 1406, "size": 112, 
"parent_context": "class_definition", "content": "def main(\n        self,\n        
args: cabc.Sequence | None = None,\n        prog_name: str | None = None,\n        
complete_var: str | None = None,\n        standalone_mode: bool = True,\n        
windows_expand_args: bool = True,\n        **extra: t.Any,\n    ) -> t.Any:\n        
\"\"\"This is the way to invoke a script with all the bells and\n        whistles as a
command line application.  This will always terminate\n        the application after a
call.  If this is not wanted, ``SystemExit``\n        needs to be caught.\n\n        
This method is also available by directly calling the instance of\n        a 
:class:`Command`.\n\n        :param args: the arguments that should be used for 
parsing.  If not\n                     provided, ``sys.argv[1:]`` is used.\n        
:param prog_name: the program name that should be used.  By default\n                 
the program name is constructed by taking the file\n                          name 
from ``sys.argv[0]``.\n        :param complete_var: the environment variable that 
controls the\n                             bash completion support.  The default is\n 
``\"_<prog_name>_COMPLETE\"`` with prog_name in\n                             
uppercase.\n        :param standalone_mode: the default behavior is to invoke the 
script\n                                in standalone mode.  Click will then\n        
handle exceptions and convert them into\n                                error 
messages and the function will never\n                                return but shut 
down the interpreter.  If\n                                this is set to `False` they
will be\n                                propagated to the caller and the return\n    
value of this function is the return value\n                                of 
:meth:`invoke`.\n        :param windows_expand_args: Expand glob patterns, user dir, 
and\n            env vars in command line args on Windows.\n        :param extra: 
extra keyword arguments are forwarded to the context\n                      
constructor.  See :class:`Context` for more information.\n\n        .. 
versionchanged:: 8.0.1\n            Added the ``windows_expand_args`` parameter to 
allow\n            disabling command line arg expansion on Windows.\n\n        .. 
versionchanged:: 8.0\n            When taking arguments from ``sys.argv`` on Windows, 
glob\n            patterns, user dir, and env vars are expanded.\n\n        .. 
versionchanged:: 3.0\n           Added the ``standalone_mode`` parameter.\n        
\"\"\"\n        if args is None:\n            args = sys.argv[1:]\n\n            if 
os.name == \"nt\" and windows_expand_args:\n                args = 
_expand_args(args)\n        else:\n            args = list(args)\n\n        if 
prog_name is None:\n            prog_name = _detect_program_name()\n\n        # 
Process shell completion requests and exit early.\n        
self._main_shell_completion(extra, prog_name, complete_var)\n\n        try:\n         
try:\n                with self.make_context(prog_name, args, **extra) as ctx:\n      
rv = self.invoke(ctx)\n                    if not standalone_mode:\n                  
return rv\n                    # it's not safe to `ctx.exit(rv)` here!\n              
# note that `rv` may actually contain data like \"1\" which\n                    # has
obvious effects\n                    # more subtle case: `rv=[None, None]` can come 
out of\n                    # chained commands which all returned `None` -- so it's 
not\n                    # even always obvious that `rv` indicates success/failure\n  
# by its truthiness/falsiness\n                    ctx.exit()\n            except 
(EOFError, KeyboardInterrupt) as e:\n                echo(file=sys.stderr)\n          
raise Abort() from e\n            except ClickException as e:\n                if not 
standalone_mode:\n                    raise\n                e.show()\n               
sys.exit(e.exit_code)\n            except OSError as e:\n                if e.errno ==
errno.EPIPE:\n                    sys.stdout = t.cast(t.TextIO, 
PacifyFlushWrapper(sys.stdout))\n                    sys.stderr = t.cast(t.TextIO, 
PacifyFlushWrapper(sys.stderr))\n                    sys.exit(1)\n                
else:\n                    raise\n        except Exit as e:\n            if 
standalone_mode:\n                sys.exit(e.exit_code)\n            else:\n          
# in non-standalone mode, return the exit code\n                # note that this is 
only reached if `self.invoke` above raises\n                # an Exit explicitly -- 
thus bypassing the check there which\n                # would return its result\n     
# the results of non-standalone execution may therefore be\n                # somewhat
ambiguous: if there are codepaths which lead to\n                # `ctx.exit(1)` and 
to `return 1`, the caller won't be able to\n                # tell the difference 
between the two\n                return e.exit_code\n        except Abort:\n          
if not standalone_mode:\n                raise\n            echo(_(\"Aborted!\"), 
file=sys.stderr)\n            sys.exit(1)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1408, "end_line": 1438, "size": 31, 
"parent_context": "class_definition", "content": "def _main_shell_completion(\n       
self,\n        ctx_args: cabc.MutableMapping,\n        prog_name: str,\n        
complete_var: str | None = None,\n    ) -> None:\n        \"\"\"Check if the shell is 
asking for tab completion, process\n        that, then exit early. Called from 
:meth:`main` before the\n        program is invoked.\n\n        :param prog_name: Name
of the executable in the shell.\n        :param complete_var: Name of the environment 
variable that holds\n            the completion instruction. Defaults to\n            
``_{PROG_NAME}_COMPLETE``.\n\n        .. versionchanged:: 8.2.0\n            Dots 
(``.``) in ``prog_name`` are replaced with underscores (``_``).\n        \"\"\"\n     
if complete_var is None:\n            complete_name = prog_name.replace(\"-\", 
\"_\").replace(\".\", \"_\")\n            complete_var = 
f\"_{complete_name}_COMPLETE\".upper()\n\n        instruction = 
os.environ.get(complete_var)\n\n        if not instruction:\n            return\n\n   
from .shell_completion import shell_complete\n\n        rv = shell_complete(self, 
ctx_args, prog_name, complete_var, instruction)\n        sys.exit(rv)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1440, "end_line": 1442, "size": 3, 
"parent_context": "class_definition", "content": "def __call__(self, *args: t.Any, 
**kwargs: t.Any) -> t.Any:\n        \"\"\"Alias for :meth:`main`.\"\"\"\n        
return self.main(*args, **kwargs)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"class_definition", "start_line": 1445, "end_line": 1450, "size": 6, "parent_context":
"", "content": "class _FakeSubclassCheck(type):\n    def __subclasscheck__(cls, 
subclass: type) -> bool:\n        return issubclass(subclass, cls.__bases__[0])\n\n   
def __instancecheck__(cls, instance: t.Any) -> bool:\n        return 
isinstance(instance, cls.__bases__[0])"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1446, "end_line": 1447, "size": 2, 
"parent_context": "class_definition", "content": "def __subclasscheck__(cls, subclass:
type) -> bool:\n        return issubclass(subclass, cls.__bases__[0])"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1449, "end_line": 1450, "size": 2, 
"parent_context": "class_definition", "content": "def __instancecheck__(cls, instance:
t.Any) -> bool:\n        return isinstance(instance, cls.__bases__[0])"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"class_definition", "start_line": 1453, "end_line": 1457, "size": 5, "parent_context":
"", "content": "class _BaseCommand(Command, metaclass=_FakeSubclassCheck):\n    
\"\"\"\n    .. deprecated:: 8.2\n        Will be removed in Click 9.0. Use ``Command``
instead.\n    \"\"\""}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"class_definition", "start_line": 1460, "end_line": 1908, "size": 449, 
"parent_context": "", "content": "class Group(Command):\n    \"\"\"A group is a 
command that nests other commands (or more groups).\n\n    :param name: The name of 
the group command.\n    :param commands: Map names to :class:`Command` objects. Can be
a list, which\n        will use :attr:`Command.name` as the keys.\n    :param 
invoke_without_command: Invoke the group's callback even if a\n        subcommand is 
not given.\n    :param no_args_is_help: If no arguments are given, show the group's 
help and\n        exit. Defaults to the opposite of ``invoke_without_command``.\n    
:param subcommand_metavar: How to represent the subcommand argument in help.\n        
The default will represent whether ``chain`` is set or not.\n    :param chain: Allow 
passing more than one subcommand argument. After parsing\n        a command's 
arguments, if any arguments remain another command will be\n        matched, and so 
on.\n    :param result_callback: A function to call after the group's and\n        
subcommand's callbacks. The value returned by the subcommand is passed.\n        If 
``chain`` is enabled, the value will be a list of values returned by\n        all the 
commands. If ``invoke_without_command`` is enabled, the value\n        will be the 
value returned by the group's callback, or an empty list if\n        ``chain`` is 
enabled.\n    :param kwargs: Other arguments passed to :class:`Command`.\n\n    .. 
versionchanged:: 8.0\n        The ``commands`` argument can be a list of command 
objects.\n\n    .. versionchanged:: 8.2\n        Merged with and replaces the 
``MultiCommand`` base class.\n    \"\"\"\n\n    allow_extra_args = True\n    
allow_interspersed_args = False\n\n    #: If set, this is used by the group's 
:meth:`command` decorator\n    #: as the default :class:`Command` class. This is 
useful to make all\n    #: subcommands use a custom command class.\n    #:\n    #: .. 
versionadded:: 8.0\n    command_class: type[Command] | None = None\n\n    #: If set, 
this is used by the group's :meth:`group` decorator\n    #: as the default 
:class:`Group` class. This is useful to make all\n    #: subgroups use a custom group 
class.\n    #:\n    #: If set to the special value :class:`type` (literally\n    #: 
``group_class = type``), this group's class will be used as the\n    #: default class.
This makes a custom group class continue to make\n    #: custom groups.\n    #:\n    
#: .. versionadded:: 8.0\n    group_class: type[Group] | type | None = None\n    # 
Literal isn't valid, so use Type\n\n    def __init__(\n        self,\n        name: 
str | None = None,\n        commands: cabc.MutableMapping\n        | 
cabc.Sequence[Command]\n        | None = None,\n        invoke_without_command: bool =
False,\n        no_args_is_help: bool | None = None,\n        subcommand_metavar: str 
| None = None,\n        chain: bool = False,\n        result_callback: t.Callable[...,
t.Any] | None = None,\n        **kwargs: t.Any,\n    ) -> None:\n        
super().__init__(name, **kwargs)\n\n        if commands is None:\n            commands
= {}\n        elif isinstance(commands, abc.Sequence):\n            commands = 
{c.name: c for c in commands if c.name is not None}\n\n        #: The registered 
subcommands by their exported names.\n        self.commands: cabc.MutableMapping = 
commands\n\n        if no_args_is_help is None:\n            no_args_is_help = not 
invoke_without_command\n\n        self.no_args_is_help = no_args_is_help\n        
self.invoke_without_command = invoke_without_command\n\n        if subcommand_metavar 
is None:\n            if chain:\n                subcommand_metavar = \"COMMAND1 
[ARGS]... [COMMAND2 [ARGS]...]...\"\n            else:\n                
subcommand_metavar = \"COMMAND [ARGS]...\"\n\n        self.subcommand_metavar = 
subcommand_metavar\n        self.chain = chain\n        # The result callback that is 
stored. This can be set or\n        # overridden with the :func:`result_callback` 
decorator.\n        self._result_callback = result_callback\n\n        if 
self.chain:\n            for param in self.params:\n                if 
isinstance(param, Argument) and not param.required:\n                    raise 
RuntimeError(\n                        \"A group in chain mode cannot have optional 
arguments.\"\n                    )\n\n    def to_info_dict(self, ctx: Context) -> 
dict:\n        info_dict = super().to_info_dict(ctx)\n        commands = {}\n\n       
for name in self.list_commands(ctx):\n            command = self.get_command(ctx, 
name)\n\n            if command is None:\n                continue\n\n            
sub_ctx = ctx._make_sub_context(command)\n\n            with 
sub_ctx.scope(cleanup=False):\n                commands = 
command.to_info_dict(sub_ctx)\n\n        info_dict.update(commands=commands, 
chain=self.chain)\n        return info_dict\n\n    def add_command(self, cmd: Command,
name: str | None = None) -> None:\n        \"\"\"Registers another :class:`Command` 
with this group.  If the name\n        is not provided, the name of the command is 
used.\n        \"\"\"\n        name = name or cmd.name\n        if name is None:\n    
raise TypeError(\"Command has no name.\")\n        _check_nested_chain(self, name, 
cmd, register=True)\n        self.commands = cmd\n\n    @t.overload\n    def 
command(self, __func: t.Callable[..., t.Any]) -> Command: ...\n\n    @t.overload\n    
def command(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> 
t.Callable[[t.Callable[..., t.Any]], Command]: ...\n\n    def command(\n        self, 
*args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], Command] 
| Command:\n        \"\"\"A shortcut decorator for declaring and attaching a command 
to\n        the group. This takes the same arguments as :func:`command` and\n        
immediately registers the created command with this group by\n        calling 
:meth:`add_command`.\n\n        To customize the command class used, set the\n        
:attr:`command_class` attribute.\n\n        .. versionchanged:: 8.1\n            This 
decorator can be applied without parentheses.\n\n        .. versionchanged:: 8.0\n    
Added the :attr:`command_class` attribute.\n        \"\"\"\n        from .decorators 
import command\n\n        func: t.Callable[..., t.Any] | None = None\n\n        if 
args and callable(args[0]):\n            assert len(args) == 1 and not kwargs, (\n    
\"Use 'command(**kwargs)(callable)' to provide arguments.\"\n            )\n          
(func,) = args\n            args = ()\n\n        if self.command_class and 
kwargs.get(\"cls\") is None:\n            kwargs[\"cls\"] = self.command_class\n\n    
def decorator(f: t.Callable[..., t.Any]) -> Command:\n            cmd: Command = 
command(*args, **kwargs)(f)\n            self.add_command(cmd)\n            return 
cmd\n\n        if func is not None:\n            return decorator(func)\n\n        
return decorator\n\n    @t.overload\n    def group(self, __func: t.Callable[..., 
t.Any]) -> Group: ...\n\n    @t.overload\n    def group(\n        self, *args: t.Any, 
**kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], Group]: ...\n\n    def 
group(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> 
t.Callable[[t.Callable[..., t.Any]], Group] | Group:\n        \"\"\"A shortcut 
decorator for declaring and attaching a group to\n        the group. This takes the 
same arguments as :func:`group` and\n        immediately registers the created group 
with this group by\n        calling :meth:`add_command`.\n\n        To customize the 
group class used, set the :attr:`group_class`\n        attribute.\n\n        .. 
versionchanged:: 8.1\n            This decorator can be applied without 
parentheses.\n\n        .. versionchanged:: 8.0\n            Added the 
:attr:`group_class` attribute.\n        \"\"\"\n        from .decorators import 
group\n\n        func: t.Callable[..., t.Any] | None = None\n\n        if args and 
callable(args[0]):\n            assert len(args) == 1 and not kwargs, (\n             
\"Use 'group(**kwargs)(callable)' to provide arguments.\"\n            )\n            
(func,) = args\n            args = ()\n\n        if self.group_class is not None and 
kwargs.get(\"cls\") is None:\n            if self.group_class is type:\n              
kwargs[\"cls\"] = type(self)\n            else:\n                kwargs[\"cls\"] = 
self.group_class\n\n        def decorator(f: t.Callable[..., t.Any]) -> Group:\n      
cmd: Group = group(*args, **kwargs)(f)\n            self.add_command(cmd)\n           
return cmd\n\n        if func is not None:\n            return decorator(func)\n\n    
return decorator\n\n    def result_callback(self, replace: bool = False) -> 
t.Callable[[F], F]:\n        \"\"\"Adds a result callback to the command.  By default 
if a\n        result callback is already registered this will chain them but\n        
this can be disabled with the `replace` parameter.  The result\n        callback is 
invoked with the return value of the subcommand\n        (or the list of return values
from all subcommands if chaining\n        is enabled) as well as the parameters as 
they would be passed\n        to the main callback.\n\n        Example::\n\n          
@click.group()\n            @click.option('-i', '--input', default=23)\n            
def cli(input):\n                return 42\n\n            @cli.result_callback()\n    
def process_result(result, input):\n                return result + input\n\n        
:param replace: if set to `True` an already existing result\n                        
callback will be removed.\n\n        .. versionchanged:: 8.0\n            Renamed from
``resultcallback``.\n\n        .. versionadded:: 3.0\n        \"\"\"\n\n        def 
decorator(f: F) -> F:\n            old_callback = self._result_callback\n\n           
if old_callback is None or replace:\n                self._result_callback = f\n      
return f\n\n            def function(value: t.Any, /, *args: t.Any, **kwargs: t.Any) 
-> t.Any:\n                inner = old_callback(value, *args, **kwargs)\n             
return f(inner, *args, **kwargs)\n\n            self._result_callback = rv = 
update_wrapper(t.cast(F, function), f)\n            return rv  # type: ignore\n\n     
return decorator\n\n    def get_command(self, ctx: Context, cmd_name: str) -> Command 
| None:\n        \"\"\"Given a context and a command name, this returns a 
:class:`Command`\n        object if it exists or returns ``None``.\n        \"\"\"\n  
return self.commands.get(cmd_name)\n\n    def list_commands(self, ctx: Context) -> 
list:\n        \"\"\"Returns a list of subcommand names in the order they should 
appear.\"\"\"\n        return sorted(self.commands)\n\n    def 
collect_usage_pieces(self, ctx: Context) -> list:\n        rv = 
super().collect_usage_pieces(ctx)\n        rv.append(self.subcommand_metavar)\n       
return rv\n\n    def format_options(self, ctx: Context, formatter: HelpFormatter) -> 
None:\n        super().format_options(ctx, formatter)\n        
self.format_commands(ctx, formatter)\n\n    def format_commands(self, ctx: Context, 
formatter: HelpFormatter) -> None:\n        \"\"\"Extra format methods for multi 
methods that adds all the commands\n        after the options.\n        \"\"\"\n      
commands = []\n        for subcommand in self.list_commands(ctx):\n            cmd = 
self.get_command(ctx, subcommand)\n            # What is this, the tool lied about a 
command.  Ignore it\n            if cmd is None:\n                continue\n          
if cmd.hidden:\n                continue\n\n            commands.append((subcommand, 
cmd))\n\n        # allow for 3 times the default spacing\n        if len(commands):\n 
limit = formatter.width - 6 - max(len(cmd[0]) for cmd in commands)\n\n            rows
= []\n            for subcommand, cmd in commands:\n                help = 
cmd.get_short_help_str(limit)\n                rows.append((subcommand, help))\n\n    
if rows:\n                with formatter.section(_(\"Commands\")):\n                  
formatter.write_dl(rows)\n\n    def parse_args(self, ctx: Context, args: list) -> 
list:\n        if not args and self.no_args_is_help and not ctx.resilient_parsing:\n  
raise NoArgsIsHelpError(ctx)\n\n        rest = super().parse_args(ctx, args)\n\n      
if self.chain:\n            ctx._protected_args = rest\n            ctx.args = []\n   
elif rest:\n            ctx._protected_args, ctx.args = rest[:1], rest[1:]\n\n        
return ctx.args\n\n    def invoke(self, ctx: Context) -> t.Any:\n        def 
_process_result(value: t.Any) -> t.Any:\n            if self._result_callback is not 
None:\n                value = ctx.invoke(self._result_callback, value, 
**ctx.params)\n            return value\n\n        if not ctx._protected_args:\n      
if self.invoke_without_command:\n                # No subcommand was invoked, so the 
result callback is\n                # invoked with the group return value for 
regular\n                # groups, or an empty list for chained groups.\n             
with ctx:\n                    rv = super().invoke(ctx)\n                    return 
_process_result([] if self.chain else rv)\n            ctx.fail(_(\"Missing 
command.\"))\n\n        # Fetch args back out\n        args = [*ctx._protected_args, 
*ctx.args]\n        ctx.args = []\n        ctx._protected_args = []\n\n        # If 
we're not in chain mode, we only allow the invocation of a\n        # single command 
but we also inform the current context about the\n        # name of the command to 
invoke.\n        if not self.chain:\n            # Make sure the context is entered so
we do not clean up\n            # resources until the result processor has worked.\n  
with ctx:\n                cmd_name, cmd, args = self.resolve_command(ctx, args)\n    
assert cmd is not None\n                ctx.invoked_subcommand = cmd_name\n           
super().invoke(ctx)\n                sub_ctx = cmd.make_context(cmd_name, args, 
parent=ctx)\n                with sub_ctx:\n                    return 
_process_result(sub_ctx.command.invoke(sub_ctx))\n\n        # In chain mode we create 
the contexts step by step, but after the\n        # base command has been invoked.  
Because at that point we do not\n        # know the subcommands yet, the invoked 
subcommand attribute is\n        # set to ``*`` to inform the command that subcommands
are executed\n        # but nothing else.\n        with ctx:\n            
ctx.invoked_subcommand = \"*\" if args else None\n            super().invoke(ctx)\n\n 
# Otherwise we make every single context and invoke them in a\n            # chain.  
In that case the return value to the result processor\n            # is the list of 
all invoked subcommand's results.\n            contexts = []\n            while 
args:\n                cmd_name, cmd, args = self.resolve_command(ctx, args)\n        
assert cmd is not None\n                sub_ctx = cmd.make_context(\n                 
cmd_name,\n                    args,\n                    parent=ctx,\n               
allow_extra_args=True,\n                    allow_interspersed_args=False,\n          
)\n                contexts.append(sub_ctx)\n                args, sub_ctx.args = 
sub_ctx.args, []\n\n            rv = []\n            for sub_ctx in contexts:\n       
with sub_ctx:\n                    rv.append(sub_ctx.command.invoke(sub_ctx))\n       
return _process_result(rv)\n\n    def resolve_command(\n        self, ctx: Context, 
args: list\n    ) -> tuple[str | None, Command | None, list]:\n        cmd_name = 
make_str(args[0])\n        original_cmd_name = cmd_name\n\n        # Get the command\n
cmd = self.get_command(ctx, cmd_name)\n\n        # If we can't find the command but 
there is a normalization\n        # function available, we try with that one.\n       
if cmd is None and ctx.token_normalize_func is not None:\n            cmd_name = 
ctx.token_normalize_func(cmd_name)\n            cmd = self.get_command(ctx, 
cmd_name)\n\n        # If we don't find the command we want to show an error message\n
# to the user that it was not provided.  However, there is\n        # something else 
we should do: if the first argument looks like\n        # an option we want to kick 
off parsing again for arguments to\n        # resolve things like --help which now 
should go to the main\n        # place.\n        if cmd is None and not 
ctx.resilient_parsing:\n            if _split_opt(cmd_name)[0]:\n                
self.parse_args(ctx, args)\n            ctx.fail(_(\"No such command 
{name!r}.\").format(name=original_cmd_name))\n        return cmd_name if cmd else 
None, cmd, args[1:]\n\n    def shell_complete(self, ctx: Context, incomplete: str) -> 
list[CompletionItem]:\n        \"\"\"Return a list of completions for the incomplete 
value. Looks\n        at the names of options, subcommands, and chained\n        
multi-commands.\n\n        :param ctx: Invocation context for this command.\n        
:param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 
8.0\n        \"\"\"\n        from click.shell_completion import CompletionItem\n\n    
results = [\n            CompletionItem(name, help=command.get_short_help_str())\n    
for name, command in _complete_visible_commands(ctx, incomplete)\n        ]\n        
results.extend(super().shell_complete(ctx, incomplete))\n        return results"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1513, "end_line": 1559, "size": 47, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
name: str | None = None,\n        commands: cabc.MutableMapping\n        | 
cabc.Sequence[Command]\n        | None = None,\n        invoke_without_command: bool =
False,\n        no_args_is_help: bool | None = None,\n        subcommand_metavar: str 
| None = None,\n        chain: bool = False,\n        result_callback: t.Callable[...,
t.Any] | None = None,\n        **kwargs: t.Any,\n    ) -> None:\n        
super().__init__(name, **kwargs)\n\n        if commands is None:\n            commands
= {}\n        elif isinstance(commands, abc.Sequence):\n            commands = 
{c.name: c for c in commands if c.name is not None}\n\n        #: The registered 
subcommands by their exported names.\n        self.commands: cabc.MutableMapping = 
commands\n\n        if no_args_is_help is None:\n            no_args_is_help = not 
invoke_without_command\n\n        self.no_args_is_help = no_args_is_help\n        
self.invoke_without_command = invoke_without_command\n\n        if subcommand_metavar 
is None:\n            if chain:\n                subcommand_metavar = \"COMMAND1 
[ARGS]... [COMMAND2 [ARGS]...]...\"\n            else:\n                
subcommand_metavar = \"COMMAND [ARGS]...\"\n\n        self.subcommand_metavar = 
subcommand_metavar\n        self.chain = chain\n        # The result callback that is 
stored. This can be set or\n        # overridden with the :func:`result_callback` 
decorator.\n        self._result_callback = result_callback\n\n        if 
self.chain:\n            for param in self.params:\n                if 
isinstance(param, Argument) and not param.required:\n                    raise 
RuntimeError(\n                        \"A group in chain mode cannot have optional 
arguments.\"\n                    )"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1561, "end_line": 1577, "size": 17, 
"parent_context": "class_definition", "content": "def to_info_dict(self, ctx: Context)
-> dict:\n        info_dict = super().to_info_dict(ctx)\n        commands = {}\n\n    
for name in self.list_commands(ctx):\n            command = self.get_command(ctx, 
name)\n\n            if command is None:\n                continue\n\n            
sub_ctx = ctx._make_sub_context(command)\n\n            with 
sub_ctx.scope(cleanup=False):\n                commands = 
command.to_info_dict(sub_ctx)\n\n        info_dict.update(commands=commands, 
chain=self.chain)\n        return info_dict"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1579, "end_line": 1587, "size": 9, 
"parent_context": "class_definition", "content": "def add_command(self, cmd: Command, 
name: str | None = None) -> None:\n        \"\"\"Registers another :class:`Command` 
with this group.  If the name\n        is not provided, the name of the command is 
used.\n        \"\"\"\n        name = name or cmd.name\n        if name is None:\n    
raise TypeError(\"Command has no name.\")\n        _check_nested_chain(self, name, 
cmd, register=True)\n        self.commands = cmd"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 1589, "end_line": 1590, "size": 2, 
"parent_context": "class_definition", "content": "@t.overload\n    def command(self, 
__func: t.Callable[..., t.Any]) -> Command: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1590, "end_line": 1590, "size": 1, 
"parent_context": "decorated_definition", "content": "def command(self, __func: 
t.Callable[..., t.Any]) -> Command: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 1592, "end_line": 1595, "size": 4, 
"parent_context": "class_definition", "content": "@t.overload\n    def command(\n     
self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], 
Command]: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1593, "end_line": 1595, "size": 3, 
"parent_context": "decorated_definition", "content": "def command(\n        self, 
*args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], Command]:
..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1597, "end_line": 1636, "size": 40, 
"parent_context": "class_definition", "content": "def command(\n        self, *args: 
t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], Command] | 
Command:\n        \"\"\"A shortcut decorator for declaring and attaching a command 
to\n        the group. This takes the same arguments as :func:`command` and\n        
immediately registers the created command with this group by\n        calling 
:meth:`add_command`.\n\n        To customize the command class used, set the\n        
:attr:`command_class` attribute.\n\n        .. versionchanged:: 8.1\n            This 
decorator can be applied without parentheses.\n\n        .. versionchanged:: 8.0\n    
Added the :attr:`command_class` attribute.\n        \"\"\"\n        from .decorators 
import command\n\n        func: t.Callable[..., t.Any] | None = None\n\n        if 
args and callable(args[0]):\n            assert len(args) == 1 and not kwargs, (\n    
\"Use 'command(**kwargs)(callable)' to provide arguments.\"\n            )\n          
(func,) = args\n            args = ()\n\n        if self.command_class and 
kwargs.get(\"cls\") is None:\n            kwargs[\"cls\"] = self.command_class\n\n    
def decorator(f: t.Callable[..., t.Any]) -> Command:\n            cmd: Command = 
command(*args, **kwargs)(f)\n            self.add_command(cmd)\n            return 
cmd\n\n        if func is not None:\n            return decorator(func)\n\n        
return decorator"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1628, "end_line": 1631, "size": 4, 
"parent_context": "function_definition", "content": "def decorator(f: t.Callable[..., 
t.Any]) -> Command:\n            cmd: Command = command(*args, **kwargs)(f)\n         
self.add_command(cmd)\n            return cmd"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 1638, "end_line": 1639, "size": 2, 
"parent_context": "class_definition", "content": "@t.overload\n    def group(self, 
__func: t.Callable[..., t.Any]) -> Group: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1639, "end_line": 1639, "size": 1, 
"parent_context": "decorated_definition", "content": "def group(self, __func: 
t.Callable[..., t.Any]) -> Group: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 1641, "end_line": 1644, "size": 4, 
"parent_context": "class_definition", "content": "@t.overload\n    def group(\n       
self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], 
Group]: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1642, "end_line": 1644, "size": 3, 
"parent_context": "decorated_definition", "content": "def group(\n        self, *args:
t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], Group]: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1646, "end_line": 1688, "size": 43, 
"parent_context": "class_definition", "content": "def group(\n        self, *args: 
t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], Group] | 
Group:\n        \"\"\"A shortcut decorator for declaring and attaching a group to\n   
the group. This takes the same arguments as :func:`group` and\n        immediately 
registers the created group with this group by\n        calling 
:meth:`add_command`.\n\n        To customize the group class used, set the 
:attr:`group_class`\n        attribute.\n\n        .. versionchanged:: 8.1\n          
This decorator can be applied without parentheses.\n\n        .. versionchanged:: 
8.0\n            Added the :attr:`group_class` attribute.\n        \"\"\"\n        
from .decorators import group\n\n        func: t.Callable[..., t.Any] | None = 
None\n\n        if args and callable(args[0]):\n            assert len(args) == 1 and 
not kwargs, (\n                \"Use 'group(**kwargs)(callable)' to provide 
arguments.\"\n            )\n            (func,) = args\n            args = ()\n\n    
if self.group_class is not None and kwargs.get(\"cls\") is None:\n            if 
self.group_class is type:\n                kwargs[\"cls\"] = type(self)\n            
else:\n                kwargs[\"cls\"] = self.group_class\n\n        def decorator(f: 
t.Callable[..., t.Any]) -> Group:\n            cmd: Group = group(*args, 
**kwargs)(f)\n            self.add_command(cmd)\n            return cmd\n\n        if 
func is not None:\n            return decorator(func)\n\n        return decorator"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1680, "end_line": 1683, "size": 4, 
"parent_context": "function_definition", "content": "def decorator(f: t.Callable[..., 
t.Any]) -> Group:\n            cmd: Group = group(*args, **kwargs)(f)\n            
self.add_command(cmd)\n            return cmd"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1690, "end_line": 1733, "size": 44, 
"parent_context": "class_definition", "content": "def result_callback(self, replace: 
bool = False) -> t.Callable[[F], F]:\n        \"\"\"Adds a result callback to the 
command.  By default if a\n        result callback is already registered this will 
chain them but\n        this can be disabled with the `replace` parameter.  The 
result\n        callback is invoked with the return value of the subcommand\n        
(or the list of return values from all subcommands if chaining\n        is enabled) as
well as the parameters as they would be passed\n        to the main callback.\n\n     
Example::\n\n            @click.group()\n            @click.option('-i', '--input', 
default=23)\n            def cli(input):\n                return 42\n\n            
@cli.result_callback()\n            def process_result(result, input):\n              
return result + input\n\n        :param replace: if set to `True` an already existing 
result\n                        callback will be removed.\n\n        .. 
versionchanged:: 8.0\n            Renamed from ``resultcallback``.\n\n        .. 
versionadded:: 3.0\n        \"\"\"\n\n        def decorator(f: F) -> F:\n            
old_callback = self._result_callback\n\n            if old_callback is None or 
replace:\n                self._result_callback = f\n                return f\n\n     
def function(value: t.Any, /, *args: t.Any, **kwargs: t.Any) -> t.Any:\n              
inner = old_callback(value, *args, **kwargs)\n                return f(inner, *args, 
**kwargs)\n\n            self._result_callback = rv = update_wrapper(t.cast(F, 
function), f)\n            return rv  # type: ignore\n\n        return decorator"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1719, "end_line": 1731, "size": 13, 
"parent_context": "function_definition", "content": "def decorator(f: F) -> F:\n      
old_callback = self._result_callback\n\n            if old_callback is None or 
replace:\n                self._result_callback = f\n                return f\n\n     
def function(value: t.Any, /, *args: t.Any, **kwargs: t.Any) -> t.Any:\n              
inner = old_callback(value, *args, **kwargs)\n                return f(inner, *args, 
**kwargs)\n\n            self._result_callback = rv = update_wrapper(t.cast(F, 
function), f)\n            return rv  # type: ignore"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1726, "end_line": 1728, "size": 3, 
"parent_context": "function_definition", "content": "def function(value: t.Any, /, 
*args: t.Any, **kwargs: t.Any) -> t.Any:\n                inner = old_callback(value, 
*args, **kwargs)\n                return f(inner, *args, **kwargs)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1735, "end_line": 1739, "size": 5, 
"parent_context": "class_definition", "content": "def get_command(self, ctx: Context, 
cmd_name: str) -> Command | None:\n        \"\"\"Given a context and a command name, 
this returns a :class:`Command`\n        object if it exists or returns ``None``.\n   
\"\"\"\n        return self.commands.get(cmd_name)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1741, "end_line": 1743, "size": 3, 
"parent_context": "class_definition", "content": "def list_commands(self, ctx: 
Context) -> list:\n        \"\"\"Returns a list of subcommand names in the order they 
should appear.\"\"\"\n        return sorted(self.commands)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1745, "end_line": 1748, "size": 4, 
"parent_context": "class_definition", "content": "def collect_usage_pieces(self, ctx: 
Context) -> list:\n        rv = super().collect_usage_pieces(ctx)\n        
rv.append(self.subcommand_metavar)\n        return rv"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1750, "end_line": 1752, "size": 3, 
"parent_context": "class_definition", "content": "def format_options(self, ctx: 
Context, formatter: HelpFormatter) -> None:\n        super().format_options(ctx, 
formatter)\n        self.format_commands(ctx, formatter)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1754, "end_line": 1780, "size": 27, 
"parent_context": "class_definition", "content": "def format_commands(self, ctx: 
Context, formatter: HelpFormatter) -> None:\n        \"\"\"Extra format methods for 
multi methods that adds all the commands\n        after the options.\n        \"\"\"\n
commands = []\n        for subcommand in self.list_commands(ctx):\n            cmd = 
self.get_command(ctx, subcommand)\n            # What is this, the tool lied about a 
command.  Ignore it\n            if cmd is None:\n                continue\n          
if cmd.hidden:\n                continue\n\n            commands.append((subcommand, 
cmd))\n\n        # allow for 3 times the default spacing\n        if len(commands):\n 
limit = formatter.width - 6 - max(len(cmd[0]) for cmd in commands)\n\n            rows
= []\n            for subcommand, cmd in commands:\n                help = 
cmd.get_short_help_str(limit)\n                rows.append((subcommand, help))\n\n    
if rows:\n                with formatter.section(_(\"Commands\")):\n                  
formatter.write_dl(rows)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1782, "end_line": 1794, "size": 13, 
"parent_context": "class_definition", "content": "def parse_args(self, ctx: Context, 
args: list) -> list:\n        if not args and self.no_args_is_help and not 
ctx.resilient_parsing:\n            raise NoArgsIsHelpError(ctx)\n\n        rest = 
super().parse_args(ctx, args)\n\n        if self.chain:\n            
ctx._protected_args = rest\n            ctx.args = []\n        elif rest:\n           
ctx._protected_args, ctx.args = rest[:1], rest[1:]\n\n        return ctx.args"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1796, "end_line": 1862, "size": 67, 
"parent_context": "class_definition", "content": "def invoke(self, ctx: Context) -> 
t.Any:\n        def _process_result(value: t.Any) -> t.Any:\n            if 
self._result_callback is not None:\n                value = 
ctx.invoke(self._result_callback, value, **ctx.params)\n            return value\n\n  
if not ctx._protected_args:\n            if self.invoke_without_command:\n            
# No subcommand was invoked, so the result callback is\n                # invoked with
the group return value for regular\n                # groups, or an empty list for 
chained groups.\n                with ctx:\n                    rv = 
super().invoke(ctx)\n                    return _process_result([] if self.chain else 
rv)\n            ctx.fail(_(\"Missing command.\"))\n\n        # Fetch args back out\n 
args = [*ctx._protected_args, *ctx.args]\n        ctx.args = []\n        
ctx._protected_args = []\n\n        # If we're not in chain mode, we only allow the 
invocation of a\n        # single command but we also inform the current context about
the\n        # name of the command to invoke.\n        if not self.chain:\n           
# Make sure the context is entered so we do not clean up\n            # resources 
until the result processor has worked.\n            with ctx:\n                
cmd_name, cmd, args = self.resolve_command(ctx, args)\n                assert cmd is 
not None\n                ctx.invoked_subcommand = cmd_name\n                
super().invoke(ctx)\n                sub_ctx = cmd.make_context(cmd_name, args, 
parent=ctx)\n                with sub_ctx:\n                    return 
_process_result(sub_ctx.command.invoke(sub_ctx))\n\n        # In chain mode we create 
the contexts step by step, but after the\n        # base command has been invoked.  
Because at that point we do not\n        # know the subcommands yet, the invoked 
subcommand attribute is\n        # set to ``*`` to inform the command that subcommands
are executed\n        # but nothing else.\n        with ctx:\n            
ctx.invoked_subcommand = \"*\" if args else None\n            super().invoke(ctx)\n\n 
# Otherwise we make every single context and invoke them in a\n            # chain.  
In that case the return value to the result processor\n            # is the list of 
all invoked subcommand's results.\n            contexts = []\n            while 
args:\n                cmd_name, cmd, args = self.resolve_command(ctx, args)\n        
assert cmd is not None\n                sub_ctx = cmd.make_context(\n                 
cmd_name,\n                    args,\n                    parent=ctx,\n               
allow_extra_args=True,\n                    allow_interspersed_args=False,\n          
)\n                contexts.append(sub_ctx)\n                args, sub_ctx.args = 
sub_ctx.args, []\n\n            rv = []\n            for sub_ctx in contexts:\n       
with sub_ctx:\n                    rv.append(sub_ctx.command.invoke(sub_ctx))\n       
return _process_result(rv)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1797, "end_line": 1800, "size": 4, 
"parent_context": "function_definition", "content": "def _process_result(value: t.Any)
-> t.Any:\n            if self._result_callback is not None:\n                value = 
ctx.invoke(self._result_callback, value, **ctx.params)\n            return value"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1864, "end_line": 1889, "size": 26, 
"parent_context": "class_definition", "content": "def resolve_command(\n        self, 
ctx: Context, args: list\n    ) -> tuple[str | None, Command | None, list]:\n        
cmd_name = make_str(args[0])\n        original_cmd_name = cmd_name\n\n        # Get 
the command\n        cmd = self.get_command(ctx, cmd_name)\n\n        # If we can't 
find the command but there is a normalization\n        # function available, we try 
with that one.\n        if cmd is None and ctx.token_normalize_func is not None:\n    
cmd_name = ctx.token_normalize_func(cmd_name)\n            cmd = self.get_command(ctx,
cmd_name)\n\n        # If we don't find the command we want to show an error message\n
# to the user that it was not provided.  However, there is\n        # something else 
we should do: if the first argument looks like\n        # an option we want to kick 
off parsing again for arguments to\n        # resolve things like --help which now 
should go to the main\n        # place.\n        if cmd is None and not 
ctx.resilient_parsing:\n            if _split_opt(cmd_name)[0]:\n                
self.parse_args(ctx, args)\n            ctx.fail(_(\"No such command 
{name!r}.\").format(name=original_cmd_name))\n        return cmd_name if cmd else 
None, cmd, args[1:]"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1891, "end_line": 1908, "size": 18, 
"parent_context": "class_definition", "content": "def shell_complete(self, ctx: 
Context, incomplete: str) -> list[CompletionItem]:\n        \"\"\"Return a list of 
completions for the incomplete value. Looks\n        at the names of options, 
subcommands, and chained\n        multi-commands.\n\n        :param ctx: Invocation 
context for this command.\n        :param incomplete: Value being completed. May be 
empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        from 
click.shell_completion import CompletionItem\n\n        results = [\n            
CompletionItem(name, help=command.get_short_help_str())\n            for name, command
in _complete_visible_commands(ctx, incomplete)\n        ]\n        
results.extend(super().shell_complete(ctx, incomplete))\n        return results"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"class_definition", "start_line": 1911, "end_line": 1915, "size": 5, "parent_context":
"", "content": "class _MultiCommand(Group, metaclass=_FakeSubclassCheck):\n    
\"\"\"\n    .. deprecated:: 8.2\n        Will be removed in Click 9.0. Use ``Group`` 
instead.\n    \"\"\""}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"class_definition", "start_line": 1918, "end_line": 1971, "size": 54, 
"parent_context": "", "content": "class CommandCollection(Group):\n    \"\"\"A 
:class:`Group` that looks up subcommands on other groups. If a command\n    is not 
found on this group, each registered source is checked in order.\n    Parameters on a 
source are not added to this group, and a source's callback\n    is not invoked when 
invoking its commands. In other words, this \"flattens\"\n    commands in many groups 
into this one group.\n\n    :param name: The name of the group command.\n    :param 
sources: A list of :class:`Group` objects to look up commands from.\n    :param 
kwargs: Other arguments passed to :class:`Group`.\n\n    .. versionchanged:: 8.2\n    
This is a subclass of ``Group``. Commands are looked up first on this\n        group, 
then each of its sources.\n    \"\"\"\n\n    def __init__(\n        self,\n        
name: str | None = None,\n        sources: list[Group] | None = None,\n        
**kwargs: t.Any,\n    ) -> None:\n        super().__init__(name, **kwargs)\n        #:
The list of registered groups.\n        self.sources: list[Group] = sources or []\n\n 
def add_source(self, group: Group) -> None:\n        \"\"\"Add a group as a source of 
commands.\"\"\"\n        self.sources.append(group)\n\n    def get_command(self, ctx: 
Context, cmd_name: str) -> Command | None:\n        rv = super().get_command(ctx, 
cmd_name)\n\n        if rv is not None:\n            return rv\n\n        for source 
in self.sources:\n            rv = source.get_command(ctx, cmd_name)\n\n            if
rv is not None:\n                if self.chain:\n                    
_check_nested_chain(self, cmd_name, rv)\n\n                return rv\n\n        return
None\n\n    def list_commands(self, ctx: Context) -> list:\n        rv: set = 
set(super().list_commands(ctx))\n\n        for source in self.sources:\n            
rv.update(source.list_commands(ctx))\n\n        return sorted(rv)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1934, "end_line": 1942, "size": 9, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
name: str | None = None,\n        sources: list[Group] | None = None,\n        
**kwargs: t.Any,\n    ) -> None:\n        super().__init__(name, **kwargs)\n        #:
The list of registered groups.\n        self.sources: list[Group] = sources or []"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1944, "end_line": 1946, "size": 3, 
"parent_context": "class_definition", "content": "def add_source(self, group: Group) 
-> None:\n        \"\"\"Add a group as a source of commands.\"\"\"\n        
self.sources.append(group)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1948, "end_line": 1963, "size": 16, 
"parent_context": "class_definition", "content": "def get_command(self, ctx: Context, 
cmd_name: str) -> Command | None:\n        rv = super().get_command(ctx, cmd_name)\n\n
if rv is not None:\n            return rv\n\n        for source in self.sources:\n    
rv = source.get_command(ctx, cmd_name)\n\n            if rv is not None:\n            
if self.chain:\n                    _check_nested_chain(self, cmd_name, rv)\n\n       
return rv\n\n        return None"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1965, "end_line": 1971, "size": 7, 
"parent_context": "class_definition", "content": "def list_commands(self, ctx: 
Context) -> list:\n        rv: set = set(super().list_commands(ctx))\n\n        for 
source in self.sources:\n            rv.update(source.list_commands(ctx))\n\n        
return sorted(rv)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 1974, "end_line": 1981, "size": 8, 
"parent_context": "", "content": "def _check_iter(value: t.Any) -> cabc.Iterator:\n   
\"\"\"Check if the value is iterable but not a string. Raises a type\n    error, or 
return an iterator over the value.\n    \"\"\"\n    if isinstance(value, str):\n      
raise TypeError\n\n    return iter(value)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"class_definition", "start_line": 1984, "end_line": 2462, "size": 479, 
"parent_context": "", "content": "class Parameter:\n    r\"\"\"A parameter to a 
command comes in two versions: they are either\n    :class:`Option`\\s or 
:class:`Argument`\\s.  Other subclasses are currently\n    not supported by design as 
some of the internals for parsing are\n    intentionally not finalized.\n\n    Some 
settings are supported by both options and arguments.\n\n    :param param_decls: the 
parameter declarations for this option or\n                        argument.  This is 
a list of flags or argument\n                        names.\n    :param type: the type
that should be used.  Either a :class:`ParamType`\n                 or a Python type. 
The latter is converted into the former\n                 automatically if 
supported.\n    :param required: controls if this is optional or not.\n    :param 
default: the default value if omitted.  This can also be a callable,\n                
in which case it's invoked when the default is needed\n                    without any
arguments.\n    :param callback: A function to further process or validate the value\n
after type conversion. It is called as ``f(ctx, param, value)``\n        and must 
return the value. It is called for all sources,\n        including prompts.\n    
:param nargs: the number of arguments to match.  If not ``1`` the return\n            
value is a tuple instead of single value.  The default for\n                  nargs is
``1`` (except if the type is a tuple, then it's\n                  the arity of the 
tuple). If ``nargs=-1``, all remaining\n                  parameters are collected.\n 
:param metavar: how the value is represented in the help page.\n    :param 
expose_value: if this is `True` then the value is passed onwards\n                    
to the command callback and stored on the context,\n                         otherwise
it's skipped.\n    :param is_eager: eager values are processed before non eager ones. 
This\n                     should not be set for arguments or it will inverse the\n   
order of processing.\n    :param envvar: a string or list of strings that are 
environment variables\n                   that should be checked.\n    :param 
shell_complete: A function that returns custom shell\n        completions. Used 
instead of the param's type completion if\n        given. Takes ``ctx, param, 
incomplete`` and must return a list\n        of 
:class:`~click.shell_completion.CompletionItem` or a list of\n        strings.\n    
:param deprecated: If ``True`` or non-empty string, issues a message\n                
indicating that the argument is deprecated and highlights\n                        its
deprecation in --help. The message can be customized\n                        by using
a string as the value. A deprecated parameter\n                        cannot be 
required, a ValueError will be raised otherwise.\n\n    .. versionchanged:: 8.2.0\n   
Introduction of ``deprecated``.\n\n    .. versionchanged:: 8.2\n        Adding 
duplicate parameter names to a :class:`~click.core.Command` will\n        result in a 
``UserWarning`` being shown.\n\n    .. versionchanged:: 8.2\n        Adding duplicate 
parameter names to a :class:`~click.core.Command` will\n        result in a 
``UserWarning`` being shown.\n\n    .. versionchanged:: 8.0\n        ``process_value``
validates required parameters and bounded\n        ``nargs``, and invokes the 
parameter callback before returning\n        the value. This allows the callback to 
validate prompts.\n        ``full_process_value`` is removed.\n\n    .. 
versionchanged:: 8.0\n        ``autocompletion`` is renamed to ``shell_complete`` and 
has new\n        semantics described above. The old name is deprecated and will\n     
be removed in 8.1, until then it will be wrapped to match the\n        new 
requirements.\n\n    .. versionchanged:: 8.0\n        For ``multiple=True, nargs>1``, 
the default must be a list of\n        tuples.\n\n    .. versionchanged:: 8.0\n       
Setting a default is no longer required for ``nargs>1``, it will\n        default to 
``None``. ``multiple=True`` or ``nargs=-1`` will\n        default to ``()``.\n\n    ..
versionchanged:: 7.1\n        Empty environment variables are ignored rather than 
taking the\n        empty string value. This makes it possible for scripts to clear\n 
variables if they can't unset them.\n\n    .. versionchanged:: 2.0\n        Changed 
signature for parameter callback to also be passed the\n        parameter. The old 
callback format will still work, but it will\n        raise a warning to give you a 
chance to migrate the code easier.\n    \"\"\"\n\n    param_type_name = 
\"parameter\"\n\n    def __init__(\n        self,\n        param_decls: cabc.Sequence 
| None = None,\n        type: types.ParamType | t.Any | None = None,\n        
required: bool = False,\n        default: t.Any | t.Callable[[], t.Any] | None = 
None,\n        callback: t.Callable[[Context, Parameter, t.Any], t.Any] | None = 
None,\n        nargs: int | None = None,\n        multiple: bool = False,\n        
metavar: str | None = None,\n        expose_value: bool = True,\n        is_eager: 
bool = False,\n        envvar: str | cabc.Sequence | None = None,\n        
shell_complete: t.Callable[\n            [Context, Parameter, str], 
list[CompletionItem] | list\n        ]\n        | None = None,\n        deprecated: 
bool | str = False,\n    ) -> None:\n        self.name: str | None\n        self.opts:
list\n        self.secondary_opts: list\n        self.name, self.opts, 
self.secondary_opts = self._parse_decls(\n            param_decls or (), 
expose_value\n        )\n        self.type: types.ParamType = types.convert_type(type,
default)\n\n        # Default nargs to what the type tells us if we have that\n       
# information available.\n        if nargs is None:\n            if 
self.type.is_composite:\n                nargs = self.type.arity\n            else:\n 
nargs = 1\n\n        self.required = required\n        self.callback = callback\n     
self.nargs = nargs\n        self.multiple = multiple\n        self.expose_value = 
expose_value\n        self.default = default\n        self.is_eager = is_eager\n      
self.metavar = metavar\n        self.envvar = envvar\n        
self._custom_shell_complete = shell_complete\n        self.deprecated = deprecated\n\n
if __debug__:\n            if self.type.is_composite and nargs != self.type.arity:\n  
raise ValueError(\n                    f\"'nargs' must be {self.type.arity} (or None) 
for\"\n                    f\" type {self.type!r}, but it was {nargs}.\"\n            
)\n\n            # Skip no default or callable default.\n            check_default = 
default if not callable(default) else None\n\n            if check_default is not 
None:\n                if multiple:\n                    try:\n                       
# Only check the first value against nargs.\n                        check_default = 
next(_check_iter(check_default), None)\n                    except TypeError:\n       
raise ValueError(\n                            \"'default' must be a list when 
'multiple' is true.\"\n                        ) from None\n\n                # Can be
None for multiple with empty default.\n                if nargs != 1 and check_default
is not None:\n                    try:\n                        
_check_iter(check_default)\n                    except TypeError:\n                   
if multiple:\n                            message = (\n                               
\"'default' must be a list of lists when 'multiple' is\"\n                            
\" true and 'nargs' != 1.\"\n                            )\n                        
else:\n                            message = \"'default' must be a list when 'nargs' 
!= 1.\"\n\n                        raise ValueError(message) from None\n\n            
if nargs > 1 and len(check_default) != nargs:\n                        subject = 
\"item length\" if multiple else \"length\"\n                        raise 
ValueError(\n                            f\"'default' {subject} must match 
nargs={nargs}.\"\n                        )\n\n            if required and 
deprecated:\n                raise ValueError(\n                    f\"The 
{self.param_type_name} '{self.human_readable_name}' \"\n                    \"is 
deprecated and still required. A deprecated \"\n                    
f\"{self.param_type_name} cannot be required.\"\n                )\n\n    def 
to_info_dict(self) -> dict:\n        \"\"\"Gather information that could be useful for
a tool generating\n        user-facing documentation.\n\n        Use 
:meth:`click.Context.to_info_dict` to traverse the entire\n        CLI structure.\n\n 
.. versionadded:: 8.0\n        \"\"\"\n        return {\n            \"name\": 
self.name,\n            \"param_type_name\": self.param_type_name,\n            
\"opts\": self.opts,\n            \"secondary_opts\": self.secondary_opts,\n          
\"type\": self.type.to_info_dict(),\n            \"required\": self.required,\n       
\"nargs\": self.nargs,\n            \"multiple\": self.multiple,\n            
\"default\": self.default,\n            \"envvar\": self.envvar,\n        }\n\n    def
__repr__(self) -> str:\n        return f\"<{self.__class__.__name__} 
{self.name}>\"\n\n    def _parse_decls(\n        self, decls: cabc.Sequence, 
expose_value: bool\n    ) -> tuple[str | None, list, list]:\n        raise 
NotImplementedError()\n\n    @property\n    def human_readable_name(self) -> str:\n   
\"\"\"Returns the human readable name of this parameter.  This is the\n        same as
the name for options, but the metavar for arguments.\n        \"\"\"\n        return 
self.name  # type: ignore\n\n    def make_metavar(self, ctx: Context) -> str:\n       
if self.metavar is not None:\n            return self.metavar\n\n        metavar = 
self.type.get_metavar(param=self, ctx=ctx)\n\n        if metavar is None:\n           
metavar = self.type.name.upper()\n\n        if self.nargs != 1:\n            metavar 
+= \"...\"\n\n        return metavar\n\n    @t.overload\n    def get_default(\n       
self, ctx: Context, call: t.Literal[True] = True\n    ) -> t.Any | None: ...\n\n    
@t.overload\n    def get_default(\n        self, ctx: Context, call: bool = ...\n    )
-> t.Any | t.Callable[[], t.Any] | None: ...\n\n    def get_default(\n        self, 
ctx: Context, call: bool = True\n    ) -> t.Any | t.Callable[[], t.Any] | None:\n     
\"\"\"Get the default for the parameter. Tries\n        :meth:`Context.lookup_default`
first, then the local default.\n\n        :param ctx: Current context.\n        :param
call: If the default is a callable, call it. Disable to\n            return the 
callable instead.\n\n        .. versionchanged:: 8.0.2\n            Type casting is no
longer performed when getting a default.\n\n        .. versionchanged:: 8.0.1\n       
Type casting can fail in resilient parsing mode. Invalid\n            defaults will 
not prevent showing help text.\n\n        .. versionchanged:: 8.0\n            Looks 
at ``ctx.default_map`` first.\n\n        .. versionchanged:: 8.0\n            Added 
the ``call`` parameter.\n        \"\"\"\n        value = ctx.lookup_default(self.name,
call=False)  # type: ignore\n\n        if value is None:\n            value = 
self.default\n\n        if call and callable(value):\n            value = value()\n\n 
return value\n\n    def add_to_parser(self, parser: _OptionParser, ctx: Context) -> 
None:\n        raise NotImplementedError()\n\n    def consume_value(\n        self, 
ctx: Context, opts: cabc.Mapping\n    ) -> tuple:\n        value = opts.get(self.name)
# type: ignore\n        source = ParameterSource.COMMANDLINE\n\n        if value is 
None:\n            value = self.value_from_envvar(ctx)\n            source = 
ParameterSource.ENVIRONMENT\n\n        if value is None:\n            value = 
ctx.lookup_default(self.name)  # type: ignore\n            source = 
ParameterSource.DEFAULT_MAP\n\n        if value is None:\n            value = 
self.get_default(ctx)\n            source = ParameterSource.DEFAULT\n\n        return 
value, source\n\n    def type_cast_value(self, ctx: Context, value: t.Any) -> t.Any:\n
\"\"\"Convert and validate a value against the option's\n        :attr:`type`, 
:attr:`multiple`, and :attr:`nargs`.\n        \"\"\"\n        if value is None:\n     
return () if self.multiple or self.nargs == -1 else None\n\n        def 
check_iter(value: t.Any) -> cabc.Iterator:\n            try:\n                return 
_check_iter(value)\n            except TypeError:\n                # This should only 
happen when passing in args manually,\n                # the parser should construct 
an iterable when parsing\n                # the command line.\n                raise 
BadParameter(\n                    _(\"Value must be an iterable.\"), ctx=ctx, 
param=self\n                ) from None\n\n        if self.nargs == 1 or 
self.type.is_composite:\n\n            def convert(value: t.Any) -> t.Any:\n          
return self.type(value, param=self, ctx=ctx)\n\n        elif self.nargs == -1:\n\n    
def convert(value: t.Any) -> t.Any:  # tuple\n                return 
tuple(self.type(x, self, ctx) for x in check_iter(value))\n\n        else:  # nargs > 
1\n\n            def convert(value: t.Any) -> t.Any:  # tuple\n                value =
tuple(check_iter(value))\n\n                if len(value) != self.nargs:\n            
raise BadParameter(\n                        ngettext(\n                            
\"Takes {nargs} values but 1 was given.\",\n                            \"Takes 
{nargs} values but {len} were given.\",\n                            len(value),\n    
).format(nargs=self.nargs, len=len(value)),\n                        ctx=ctx,\n       
param=self,\n                    )\n\n                return tuple(self.type(x, self, 
ctx) for x in value)\n\n        if self.multiple:\n            return tuple(convert(x)
for x in check_iter(value))\n\n        return convert(value)\n\n    def 
value_is_missing(self, value: t.Any) -> bool:\n        if value is None:\n            
return True\n\n        if (self.nargs != 1 or self.multiple) and value == ():\n       
return True\n\n        return False\n\n    def process_value(self, ctx: Context, 
value: t.Any) -> t.Any:\n        value = self.type_cast_value(ctx, value)\n\n        
if self.required and self.value_is_missing(value):\n            raise 
MissingParameter(ctx=ctx, param=self)\n\n        if self.callback is not None:\n      
value = self.callback(ctx, self, value)\n\n        return value\n\n    def 
resolve_envvar_value(self, ctx: Context) -> str | None:\n        if self.envvar is 
None:\n            return None\n\n        if isinstance(self.envvar, str):\n          
rv = os.environ.get(self.envvar)\n\n            if rv:\n                return rv\n   
else:\n            for envvar in self.envvar:\n                rv = 
os.environ.get(envvar)\n\n                if rv:\n                    return rv\n\n   
return None\n\n    def value_from_envvar(self, ctx: Context) -> t.Any | None:\n       
rv: t.Any | None = self.resolve_envvar_value(ctx)\n\n        if rv is not None and 
self.nargs != 1:\n            rv = self.type.split_envvar_value(rv)\n\n        return 
rv\n\n    def handle_parse_result(\n        self, ctx: Context, opts: cabc.Mapping, 
args: list\n    ) -> tuple[t.Any, list]:\n        with augment_usage_errors(ctx, 
param=self):\n            value, source = self.consume_value(ctx, opts)\n\n           
if (\n                self.deprecated\n                and value is not None\n        
and source\n                not in (\n                    ParameterSource.DEFAULT,\n  
ParameterSource.DEFAULT_MAP,\n                )\n            ):\n                
extra_message = (\n                    f\" {self.deprecated}\" if 
isinstance(self.deprecated, str) else \"\"\n                )\n                message
= _(\n                    \"DeprecationWarning: The {param_type} {name!r} is 
deprecated.\"\n                    \"{extra_message}\"\n                ).format(\n   
param_type=self.param_type_name,\n                    name=self.human_readable_name,\n
extra_message=extra_message,\n                )\n                echo(style(message, 
fg=\"red\"), err=True)\n\n            ctx.set_parameter_source(self.name, source)  # 
type: ignore\n\n            try:\n                value = self.process_value(ctx, 
value)\n            except Exception:\n                if not ctx.resilient_parsing:\n
raise\n\n                value = None\n\n        if self.expose_value:\n            
ctx.params = value  # type: ignore\n\n        return value, args\n\n    def 
get_help_record(self, ctx: Context) -> tuple | None:\n        pass\n\n    def 
get_usage_pieces(self, ctx: Context) -> list:\n        return []\n\n    def 
get_error_hint(self, ctx: Context) -> str:\n        \"\"\"Get a stringified version of
the param for use in error messages to\n        indicate which param caused the 
error.\n        \"\"\"\n        hint_list = self.opts or \n        return \" / 
\".join(f\"'{x}'\" for x in hint_list)\n\n    def shell_complete(self, ctx: Context, 
incomplete: str) -> list[CompletionItem]:\n        \"\"\"Return a list of completions 
for the incomplete value. If a\n        ``shell_complete`` function was given during 
init, it is used.\n        Otherwise, the :attr:`type`\n        
:meth:`~click.types.ParamType.shell_complete` function is used.\n\n        :param ctx:
Invocation context for this command.\n        :param incomplete: Value being 
completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        if 
self._custom_shell_complete is not None:\n            results = 
self._custom_shell_complete(ctx, self, incomplete)\n\n            if results and 
isinstance(results[0], str):\n                from click.shell_completion import 
CompletionItem\n\n                results = [CompletionItem(c) for c in results]\n\n  
return t.cast(\"list[CompletionItem]\", results)\n\n        return 
self.type.shell_complete(ctx, self, incomplete)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2076, "end_line": 2169, "size": 94, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
param_decls: cabc.Sequence | None = None,\n        type: types.ParamType | t.Any | 
None = None,\n        required: bool = False,\n        default: t.Any | t.Callable[[],
t.Any] | None = None,\n        callback: t.Callable[[Context, Parameter, t.Any], 
t.Any] | None = None,\n        nargs: int | None = None,\n        multiple: bool = 
False,\n        metavar: str | None = None,\n        expose_value: bool = True,\n     
is_eager: bool = False,\n        envvar: str | cabc.Sequence | None = None,\n        
shell_complete: t.Callable[\n            [Context, Parameter, str], 
list[CompletionItem] | list\n        ]\n        | None = None,\n        deprecated: 
bool | str = False,\n    ) -> None:\n        self.name: str | None\n        self.opts:
list\n        self.secondary_opts: list\n        self.name, self.opts, 
self.secondary_opts = self._parse_decls(\n            param_decls or (), 
expose_value\n        )\n        self.type: types.ParamType = types.convert_type(type,
default)\n\n        # Default nargs to what the type tells us if we have that\n       
# information available.\n        if nargs is None:\n            if 
self.type.is_composite:\n                nargs = self.type.arity\n            else:\n 
nargs = 1\n\n        self.required = required\n        self.callback = callback\n     
self.nargs = nargs\n        self.multiple = multiple\n        self.expose_value = 
expose_value\n        self.default = default\n        self.is_eager = is_eager\n      
self.metavar = metavar\n        self.envvar = envvar\n        
self._custom_shell_complete = shell_complete\n        self.deprecated = deprecated\n\n
if __debug__:\n            if self.type.is_composite and nargs != self.type.arity:\n  
raise ValueError(\n                    f\"'nargs' must be {self.type.arity} (or None) 
for\"\n                    f\" type {self.type!r}, but it was {nargs}.\"\n            
)\n\n            # Skip no default or callable default.\n            check_default = 
default if not callable(default) else None\n\n            if check_default is not 
None:\n                if multiple:\n                    try:\n                       
# Only check the first value against nargs.\n                        check_default = 
next(_check_iter(check_default), None)\n                    except TypeError:\n       
raise ValueError(\n                            \"'default' must be a list when 
'multiple' is true.\"\n                        ) from None\n\n                # Can be
None for multiple with empty default.\n                if nargs != 1 and check_default
is not None:\n                    try:\n                        
_check_iter(check_default)\n                    except TypeError:\n                   
if multiple:\n                            message = (\n                               
\"'default' must be a list of lists when 'multiple' is\"\n                            
\" true and 'nargs' != 1.\"\n                            )\n                        
else:\n                            message = \"'default' must be a list when 'nargs' 
!= 1.\"\n\n                        raise ValueError(message) from None\n\n            
if nargs > 1 and len(check_default) != nargs:\n                        subject = 
\"item length\" if multiple else \"length\"\n                        raise 
ValueError(\n                            f\"'default' {subject} must match 
nargs={nargs}.\"\n                        )\n\n            if required and 
deprecated:\n                raise ValueError(\n                    f\"The 
{self.param_type_name} '{self.human_readable_name}' \"\n                    \"is 
deprecated and still required. A deprecated \"\n                    
f\"{self.param_type_name} cannot be required.\"\n                )"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2171, "end_line": 2191, "size": 21, 
"parent_context": "class_definition", "content": "def to_info_dict(self) -> dict:\n   
\"\"\"Gather information that could be useful for a tool generating\n        
user-facing documentation.\n\n        Use :meth:`click.Context.to_info_dict` to 
traverse the entire\n        CLI structure.\n\n        .. versionadded:: 8.0\n        
\"\"\"\n        return {\n            \"name\": self.name,\n            
\"param_type_name\": self.param_type_name,\n            \"opts\": self.opts,\n        
\"secondary_opts\": self.secondary_opts,\n            \"type\": 
self.type.to_info_dict(),\n            \"required\": self.required,\n            
\"nargs\": self.nargs,\n            \"multiple\": self.multiple,\n            
\"default\": self.default,\n            \"envvar\": self.envvar,\n        }"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2193, "end_line": 2194, "size": 2, 
"parent_context": "class_definition", "content": "def __repr__(self) -> str:\n        
return f\"<{self.__class__.__name__} {self.name}>\""}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2196, "end_line": 2199, "size": 4, 
"parent_context": "class_definition", "content": "def _parse_decls(\n        self, 
decls: cabc.Sequence, expose_value: bool\n    ) -> tuple[str | None, list, list]:\n   
raise NotImplementedError()"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 2201, "end_line": 2206, "size": 6, 
"parent_context": "class_definition", "content": "@property\n    def 
human_readable_name(self) -> str:\n        \"\"\"Returns the human readable name of 
this parameter.  This is the\n        same as the name for options, but the metavar 
for arguments.\n        \"\"\"\n        return self.name  # type: ignore"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2202, "end_line": 2206, "size": 5, 
"parent_context": "decorated_definition", "content": "def human_readable_name(self) ->
str:\n        \"\"\"Returns the human readable name of this parameter.  This is the\n 
same as the name for options, but the metavar for arguments.\n        \"\"\"\n        
return self.name  # type: ignore"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2208, "end_line": 2220, "size": 13, 
"parent_context": "class_definition", "content": "def make_metavar(self, ctx: Context)
-> str:\n        if self.metavar is not None:\n            return self.metavar\n\n    
metavar = self.type.get_metavar(param=self, ctx=ctx)\n\n        if metavar is None:\n 
metavar = self.type.name.upper()\n\n        if self.nargs != 1:\n            metavar 
+= \"...\"\n\n        return metavar"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 2222, "end_line": 2225, "size": 4, 
"parent_context": "class_definition", "content": "@t.overload\n    def get_default(\n 
self, ctx: Context, call: t.Literal[True] = True\n    ) -> t.Any | None: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2223, "end_line": 2225, "size": 3, 
"parent_context": "decorated_definition", "content": "def get_default(\n        self, 
ctx: Context, call: t.Literal[True] = True\n    ) -> t.Any | None: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 2227, "end_line": 2230, "size": 4, 
"parent_context": "class_definition", "content": "@t.overload\n    def get_default(\n 
self, ctx: Context, call: bool = ...\n    ) -> t.Any | t.Callable[[], t.Any] | None: 
..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2228, "end_line": 2230, "size": 3, 
"parent_context": "decorated_definition", "content": "def get_default(\n        self, 
ctx: Context, call: bool = ...\n    ) -> t.Any | t.Callable[[], t.Any] | None: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2232, "end_line": 2263, "size": 32, 
"parent_context": "class_definition", "content": "def get_default(\n        self, ctx:
Context, call: bool = True\n    ) -> t.Any | t.Callable[[], t.Any] | None:\n        
\"\"\"Get the default for the parameter. Tries\n        :meth:`Context.lookup_default`
first, then the local default.\n\n        :param ctx: Current context.\n        :param
call: If the default is a callable, call it. Disable to\n            return the 
callable instead.\n\n        .. versionchanged:: 8.0.2\n            Type casting is no
longer performed when getting a default.\n\n        .. versionchanged:: 8.0.1\n       
Type casting can fail in resilient parsing mode. Invalid\n            defaults will 
not prevent showing help text.\n\n        .. versionchanged:: 8.0\n            Looks 
at ``ctx.default_map`` first.\n\n        .. versionchanged:: 8.0\n            Added 
the ``call`` parameter.\n        \"\"\"\n        value = ctx.lookup_default(self.name,
call=False)  # type: ignore\n\n        if value is None:\n            value = 
self.default\n\n        if call and callable(value):\n            value = value()\n\n 
return value"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2265, "end_line": 2266, "size": 2, 
"parent_context": "class_definition", "content": "def add_to_parser(self, parser: 
_OptionParser, ctx: Context) -> None:\n        raise NotImplementedError()"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2268, "end_line": 2286, "size": 19, 
"parent_context": "class_definition", "content": "def consume_value(\n        self, 
ctx: Context, opts: cabc.Mapping\n    ) -> tuple:\n        value = opts.get(self.name)
# type: ignore\n        source = ParameterSource.COMMANDLINE\n\n        if value is 
None:\n            value = self.value_from_envvar(ctx)\n            source = 
ParameterSource.ENVIRONMENT\n\n        if value is None:\n            value = 
ctx.lookup_default(self.name)  # type: ignore\n            source = 
ParameterSource.DEFAULT_MAP\n\n        if value is None:\n            value = 
self.get_default(ctx)\n            source = ParameterSource.DEFAULT\n\n        return 
value, source"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2288, "end_line": 2337, "size": 50, 
"parent_context": "class_definition", "content": "def type_cast_value(self, ctx: 
Context, value: t.Any) -> t.Any:\n        \"\"\"Convert and validate a value against 
the option's\n        :attr:`type`, :attr:`multiple`, and :attr:`nargs`.\n        
\"\"\"\n        if value is None:\n            return () if self.multiple or 
self.nargs == -1 else None\n\n        def check_iter(value: t.Any) -> cabc.Iterator:\n
try:\n                return _check_iter(value)\n            except TypeError:\n      
# This should only happen when passing in args manually,\n                # the parser
should construct an iterable when parsing\n                # the command line.\n      
raise BadParameter(\n                    _(\"Value must be an iterable.\"), ctx=ctx, 
param=self\n                ) from None\n\n        if self.nargs == 1 or 
self.type.is_composite:\n\n            def convert(value: t.Any) -> t.Any:\n          
return self.type(value, param=self, ctx=ctx)\n\n        elif self.nargs == -1:\n\n    
def convert(value: t.Any) -> t.Any:  # tuple\n                return 
tuple(self.type(x, self, ctx) for x in check_iter(value))\n\n        else:  # nargs > 
1\n\n            def convert(value: t.Any) -> t.Any:  # tuple\n                value =
tuple(check_iter(value))\n\n                if len(value) != self.nargs:\n            
raise BadParameter(\n                        ngettext(\n                            
\"Takes {nargs} values but 1 was given.\",\n                            \"Takes 
{nargs} values but {len} were given.\",\n                            len(value),\n    
).format(nargs=self.nargs, len=len(value)),\n                        ctx=ctx,\n       
param=self,\n                    )\n\n                return tuple(self.type(x, self, 
ctx) for x in value)\n\n        if self.multiple:\n            return tuple(convert(x)
for x in check_iter(value))\n\n        return convert(value)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2295, "end_line": 2304, "size": 10, 
"parent_context": "function_definition", "content": "def check_iter(value: t.Any) -> 
cabc.Iterator:\n            try:\n                return _check_iter(value)\n         
except TypeError:\n                # This should only happen when passing in args 
manually,\n                # the parser should construct an iterable when parsing\n   
# the command line.\n                raise BadParameter(\n                    
_(\"Value must be an iterable.\"), ctx=ctx, param=self\n                ) from None"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2308, "end_line": 2309, "size": 2, 
"parent_context": "function_definition", "content": "def convert(value: t.Any) -> 
t.Any:\n                return self.type(value, param=self, ctx=ctx)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2313, "end_line": 2314, "size": 2, 
"parent_context": "function_definition", "content": "def convert(value: t.Any) -> 
t.Any:  # tuple\n                return tuple(self.type(x, self, ctx) for x in 
check_iter(value))"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2318, "end_line": 2332, "size": 15, 
"parent_context": "function_definition", "content": "def convert(value: t.Any) -> 
t.Any:  # tuple\n                value = tuple(check_iter(value))\n\n                
if len(value) != self.nargs:\n                    raise BadParameter(\n               
ngettext(\n                            \"Takes {nargs} values but 1 was given.\",\n   
\"Takes {nargs} values but {len} were given.\",\n                            
len(value),\n                        ).format(nargs=self.nargs, len=len(value)),\n    
ctx=ctx,\n                        param=self,\n                    )\n\n              
return tuple(self.type(x, self, ctx) for x in value)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2339, "end_line": 2346, "size": 8, 
"parent_context": "class_definition", "content": "def value_is_missing(self, value: 
t.Any) -> bool:\n        if value is None:\n            return True\n\n        if 
(self.nargs != 1 or self.multiple) and value == ():\n            return True\n\n      
return False"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2348, "end_line": 2357, "size": 10, 
"parent_context": "class_definition", "content": "def process_value(self, ctx: 
Context, value: t.Any) -> t.Any:\n        value = self.type_cast_value(ctx, value)\n\n
if self.required and self.value_is_missing(value):\n            raise 
MissingParameter(ctx=ctx, param=self)\n\n        if self.callback is not None:\n      
value = self.callback(ctx, self, value)\n\n        return value"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2359, "end_line": 2375, "size": 17, 
"parent_context": "class_definition", "content": "def resolve_envvar_value(self, ctx: 
Context) -> str | None:\n        if self.envvar is None:\n            return None\n\n 
if isinstance(self.envvar, str):\n            rv = os.environ.get(self.envvar)\n\n    
if rv:\n                return rv\n        else:\n            for envvar in 
self.envvar:\n                rv = os.environ.get(envvar)\n\n                if rv:\n 
return rv\n\n        return None"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2377, "end_line": 2383, "size": 7, 
"parent_context": "class_definition", "content": "def value_from_envvar(self, ctx: 
Context) -> t.Any | None:\n        rv: t.Any | None = 
self.resolve_envvar_value(ctx)\n\n        if rv is not None and self.nargs != 1:\n    
rv = self.type.split_envvar_value(rv)\n\n        return rv"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2385, "end_line": 2426, "size": 42, 
"parent_context": "class_definition", "content": "def handle_parse_result(\n        
self, ctx: Context, opts: cabc.Mapping, args: list\n    ) -> tuple[t.Any, list]:\n    
with augment_usage_errors(ctx, param=self):\n            value, source = 
self.consume_value(ctx, opts)\n\n            if (\n                self.deprecated\n  
and value is not None\n                and source\n                not in (\n         
ParameterSource.DEFAULT,\n                    ParameterSource.DEFAULT_MAP,\n          
)\n            ):\n                extra_message = (\n                    f\" 
{self.deprecated}\" if isinstance(self.deprecated, str) else \"\"\n                )\n
message = _(\n                    \"DeprecationWarning: The {param_type} {name!r} is 
deprecated.\"\n                    \"{extra_message}\"\n                ).format(\n   
param_type=self.param_type_name,\n                    name=self.human_readable_name,\n
extra_message=extra_message,\n                )\n                echo(style(message, 
fg=\"red\"), err=True)\n\n            ctx.set_parameter_source(self.name, source)  # 
type: ignore\n\n            try:\n                value = self.process_value(ctx, 
value)\n            except Exception:\n                if not ctx.resilient_parsing:\n
raise\n\n                value = None\n\n        if self.expose_value:\n            
ctx.params = value  # type: ignore\n\n        return value, args"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2428, "end_line": 2429, "size": 2, 
"parent_context": "class_definition", "content": "def get_help_record(self, ctx: 
Context) -> tuple | None:\n        pass"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2431, "end_line": 2432, "size": 2, 
"parent_context": "class_definition", "content": "def get_usage_pieces(self, ctx: 
Context) -> list:\n        return []"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2434, "end_line": 2439, "size": 6, 
"parent_context": "class_definition", "content": "def get_error_hint(self, ctx: 
Context) -> str:\n        \"\"\"Get a stringified version of the param for use in 
error messages to\n        indicate which param caused the error.\n        \"\"\"\n   
hint_list = self.opts or \n        return \" / \".join(f\"'{x}'\" for x in 
hint_list)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2441, "end_line": 2462, "size": 22, 
"parent_context": "class_definition", "content": "def shell_complete(self, ctx: 
Context, incomplete: str) -> list[CompletionItem]:\n        \"\"\"Return a list of 
completions for the incomplete value. If a\n        ``shell_complete`` function was 
given during init, it is used.\n        Otherwise, the :attr:`type`\n        
:meth:`~click.types.ParamType.shell_complete` function is used.\n\n        :param ctx:
Invocation context for this command.\n        :param incomplete: Value being 
completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        if 
self._custom_shell_complete is not None:\n            results = 
self._custom_shell_complete(ctx, self, incomplete)\n\n            if results and 
isinstance(results[0], str):\n                from click.shell_completion import 
CompletionItem\n\n                results = [CompletionItem(c) for c in results]\n\n  
return t.cast(\"list[CompletionItem]\", results)\n\n        return 
self.type.shell_complete(ctx, self, incomplete)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"class_definition", "start_line": 2465, "end_line": 3076, "size": 612, 
"parent_context": "", "content": "class Option(Parameter):\n    \"\"\"Options are 
usually optional values on the command line and\n    have some extra features that 
arguments don't have.\n\n    All other parameters are passed onwards to the parameter 
constructor.\n\n    :param show_default: Show the default value for this option in 
its\n        help text. Values are not shown by default, unless\n        
:attr:`Context.show_default` is ``True``. If this value is a\n        string, it shows
that string in parentheses instead of the\n        actual value. This is particularly 
useful for dynamic options.\n        For single option boolean flags, the default 
remains hidden if\n        its value is ``False``.\n    :param show_envvar: Controls 
if an environment variable should be\n        shown on the help page and error 
messages.\n        Normally, environment variables are not shown.\n    :param prompt: 
If set to ``True`` or a non empty string then the\n        user will be prompted for 
input. If set to ``True`` the prompt\n        will be the option name capitalized. A 
deprecated option cannot be\n        prompted.\n    :param confirmation_prompt: Prompt
a second time to confirm the\n        value if it was prompted for. Can be set to a 
string instead of\n        ``True`` to customize the message.\n    :param 
prompt_required: If set to ``False``, the user will be\n        prompted for input 
only when the option was specified as a flag\n        without a value.\n    :param 
hide_input: If this is ``True`` then the input on the prompt\n        will be hidden 
from the user. This is useful for password input.\n    :param is_flag: forces this 
option to act as a flag.  The default is\n                    auto detection.\n    
:param flag_value: which value should be used for this flag if it's\n                 
enabled.  This is set to a boolean automatically if\n                       the option
string contains a slash to mark two options.\n    :param multiple: if this is set to 
`True` then the argument is accepted\n                     multiple times and 
recorded.  This is similar to ``nargs``\n                     in how it works but 
supports arbitrary number of\n                     arguments.\n    :param count: this 
flag makes an option increment an integer.\n    :param allow_from_autoenv: if this is 
enabled then the value of this\n                               parameter will be 
pulled from an environment\n                               variable in case a prefix 
is defined on the\n                               context.\n    :param help: the help 
string.\n    :param hidden: hide this option from help outputs.\n    :param attrs: 
Other command arguments described in :class:`Parameter`.\n\n    .. versionchanged:: 
8.2\n        ``envvar`` used with ``flag_value`` will always use the ``flag_value``,\n
previously it would use the value of the environment variable.\n\n    .. 
versionchanged:: 8.1\n        Help text indentation is cleaned here instead of only in
the\n        ``@option`` decorator.\n\n    .. versionchanged:: 8.1\n        The 
``show_default`` parameter overrides\n        ``Context.show_default``.\n\n    .. 
versionchanged:: 8.1\n        The default of a single option boolean flag is not shown
if the\n        default value is ``False``.\n\n    .. versionchanged:: 8.0.1\n        
``type`` is detected from ``flag_value`` if given.\n    \"\"\"\n\n    param_type_name 
= \"option\"\n\n    def __init__(\n        self,\n        param_decls: cabc.Sequence |
None = None,\n        show_default: bool | str | None = None,\n        prompt: bool | 
str = False,\n        confirmation_prompt: bool | str = False,\n        
prompt_required: bool = True,\n        hide_input: bool = False,\n        is_flag: 
bool | None = None,\n        flag_value: t.Any | None = None,\n        multiple: bool 
= False,\n        count: bool = False,\n        allow_from_autoenv: bool = True,\n    
type: types.ParamType | t.Any | None = None,\n        help: str | None = None,\n      
hidden: bool = False,\n        show_choices: bool = True,\n        show_envvar: bool =
False,\n        deprecated: bool | str = False,\n        **attrs: t.Any,\n    ) -> 
None:\n        if help:\n            help = inspect.cleandoc(help)\n\n        
super().__init__(\n            param_decls, type=type, multiple=multiple, 
deprecated=deprecated, **attrs\n        )\n\n        if prompt is True:\n            
if self.name is None:\n                raise TypeError(\"'name' is required with 
'prompt=True'.\")\n\n            prompt_text: str | None = self.name.replace(\"_\", \"
\").capitalize()\n        elif prompt is False:\n            prompt_text = None\n     
else:\n            prompt_text = prompt\n\n        if deprecated:\n            
deprecated_message = (\n                f\"(DEPRECATED: {deprecated})\"\n             
if isinstance(deprecated, str)\n                else \"(DEPRECATED)\"\n            )\n
help = help + deprecated_message if help is not None else deprecated_message\n\n      
self.prompt = prompt_text\n        self.confirmation_prompt = confirmation_prompt\n   
self.prompt_required = prompt_required\n        self.hide_input = hide_input\n        
self.hidden = hidden\n\n        # If prompt is enabled but not required, then the 
option can be\n        # used as a flag to indicate using prompt or flag_value.\n     
self._flag_needs_value = self.prompt is not None and not self.prompt_required\n\n     
if is_flag is None:\n            # Implicitly a flag because flag_value was set.\n    
if flag_value is not None:\n                is_flag = True\n            # Not a flag, 
but when used as a flag it shows a prompt.\n            elif self._flag_needs_value:\n
is_flag = False\n            # Implicitly a flag because flag options were given.\n   
elif self.secondary_opts:\n                is_flag = True\n        elif is_flag is 
False and not self._flag_needs_value:\n            # Not a flag, and prompt is not 
enabled, can be used as a\n            # flag if flag_value is set.\n            
self._flag_needs_value = flag_value is not None\n\n        self.default: t.Any | 
t.Callable[[], t.Any]\n\n        if is_flag:\n            # Set missing default for 
flags if not explicitly required or prompted.\n            if self.default is None and
not self.required and not self.prompt:\n                if multiple:\n                
self.default = ()\n                else:\n                    self.default = False\n\n
if flag_value is None:\n                # A boolean flag presence in the command line 
is enough to set\n                # the value: to the default if it is not blank, or 
to True\n                # otherwise.\n                flag_value = self.default if 
self.default else True\n\n        self.type: types.ParamType\n        if is_flag and 
type is None:\n            # Re-guess the type from the flag value instead of the\n   
# default.\n            self.type = types.convert_type(None, flag_value)\n\n        
self.is_flag: bool = bool(is_flag)\n        self.is_bool_flag: bool = bool(\n         
is_flag and isinstance(self.type, types.BoolParamType)\n        )\n        
self.flag_value: t.Any = flag_value\n\n        # Counting\n        self.count = 
count\n        if count:\n            if type is None:\n                self.type = 
types.IntRange(min=0)\n            if self.default is None:\n                
self.default = 0\n\n        self.allow_from_autoenv = allow_from_autoenv\n        
self.help = help\n        self.show_default = show_default\n        self.show_choices 
= show_choices\n        self.show_envvar = show_envvar\n\n        if __debug__:\n     
if deprecated and prompt:\n                raise ValueError(\"`deprecated` options 
cannot use `prompt`.\")\n\n            if self.nargs == -1:\n                raise 
TypeError(\"nargs=-1 is not supported for options.\")\n\n            if self.prompt 
and self.is_flag and not self.is_bool_flag:\n                raise 
TypeError(\"'prompt' is not valid for non-boolean flag.\")\n\n            if not 
self.is_bool_flag and self.secondary_opts:\n                raise 
TypeError(\"Secondary flag is not valid for non-boolean flag.\")\n\n            if 
self.is_bool_flag and self.hide_input and self.prompt is not None:\n                
raise TypeError(\n                    \"'prompt' with 'hide_input' is not valid for 
boolean flag.\"\n                )\n\n            if self.count:\n                if 
self.multiple:\n                    raise TypeError(\"'count' is not valid with 
'multiple'.\")\n\n                if self.is_flag:\n                    raise 
TypeError(\"'count' is not valid with 'is_flag'.\")\n\n    def to_info_dict(self) -> 
dict:\n        info_dict = super().to_info_dict()\n        info_dict.update(\n        
help=self.help,\n            prompt=self.prompt,\n            is_flag=self.is_flag,\n 
flag_value=self.flag_value,\n            count=self.count,\n            
hidden=self.hidden,\n        )\n        return info_dict\n\n    def 
get_error_hint(self, ctx: Context) -> str:\n        result = 
super().get_error_hint(ctx)\n        if self.show_envvar:\n            result += f\" 
(env var: '{self.envvar}')\"\n        return result\n\n    def _parse_decls(\n        
self, decls: cabc.Sequence, expose_value: bool\n    ) -> tuple[str | None, list, 
list]:\n        opts = []\n        secondary_opts = []\n        name = None\n        
possible_names = []\n\n        for decl in decls:\n            if 
decl.isidentifier():\n                if name is not None:\n                    raise 
TypeError(f\"Name '{name}' defined twice\")\n                name = decl\n            
else:\n                split_char = \";\" if decl[:1] == \"/\" else \"/\"\n           
if split_char in decl:\n                    first, second = decl.split(split_char, 
1)\n                    first = first.rstrip()\n                    if first:\n       
possible_names.append(_split_opt(first))\n                        opts.append(first)\n
second = second.lstrip()\n                    if second:\n                        
secondary_opts.append(second.lstrip())\n                    if first == second:\n     
raise ValueError(\n                            f\"Boolean option {decl!r} cannot use 
the\"\n                            \" same flag for true/false.\"\n                   
)\n                else:\n                    
possible_names.append(_split_opt(decl))\n                    opts.append(decl)\n\n    
if name is None and possible_names:\n            possible_names.sort(key=lambda x: 
-len(x[0]))  # group long options first\n            name = 
possible_names[0][1].replace(\"-\", \"_\").lower()\n            if not 
name.isidentifier():\n                name = None\n\n        if name is None:\n       
if not expose_value:\n                return None, opts, secondary_opts\n            
raise TypeError(\n                f\"Could not determine name for option with 
declarations {decls!r}\"\n            )\n\n        if not opts and not 
secondary_opts:\n            raise TypeError(\n                f\"No options defined 
but a name was passed ({name}).\"\n                \" Did you mean to declare an 
argument instead? Did\"\n                f\" you mean to pass '--{name}'?\"\n         
)\n\n        return name, opts, secondary_opts\n\n    def add_to_parser(self, parser: 
_OptionParser, ctx: Context) -> None:\n        if self.multiple:\n            action =
\"append\"\n        elif self.count:\n            action = \"count\"\n        else:\n 
action = \"store\"\n\n        if self.is_flag:\n            action = 
f\"{action}_const\"\n\n            if self.is_bool_flag and self.secondary_opts:\n    
parser.add_option(\n                    obj=self, opts=self.opts, dest=self.name, 
action=action, const=True\n                )\n                parser.add_option(\n    
obj=self,\n                    opts=self.secondary_opts,\n                    
dest=self.name,\n                    action=action,\n                    
const=False,\n                )\n            else:\n                
parser.add_option(\n                    obj=self,\n                    
opts=self.opts,\n                    dest=self.name,\n                    
action=action,\n                    const=self.flag_value,\n                )\n       
else:\n            parser.add_option(\n                obj=self,\n                
opts=self.opts,\n                dest=self.name,\n                action=action,\n    
nargs=self.nargs,\n            )\n\n    def get_help_record(self, ctx: Context) -> 
tuple | None:\n        if self.hidden:\n            return None\n\n        
any_prefix_is_slash = False\n\n        def _write_opts(opts: cabc.Sequence) -> str:\n 
nonlocal any_prefix_is_slash\n\n            rv, any_slashes = join_options(opts)\n\n  
if any_slashes:\n                any_prefix_is_slash = True\n\n            if not 
self.is_flag and not self.count:\n                rv += f\" 
{self.make_metavar(ctx=ctx)}\"\n\n            return rv\n\n        rv = 
[_write_opts(self.opts)]\n\n        if self.secondary_opts:\n            
rv.append(_write_opts(self.secondary_opts))\n\n        help = self.help or \"\"\n\n   
extra = self.get_help_extra(ctx)\n        extra_items = []\n        if \"envvars\" in 
extra:\n            extra_items.append(\n                _(\"env var: 
{var}\").format(var=\", \".join(extra[\"envvars\"]))\n            )\n        if 
\"default\" in extra:\n            extra_items.append(_(\"default: 
{default}\").format(default=extra[\"default\"]))\n        if \"range\" in extra:\n    
extra_items.append(extra[\"range\"])\n        if \"required\" in extra:\n            
extra_items.append(_(extra[\"required\"]))\n\n        if extra_items:\n            
extra_str = \"; \".join(extra_items)\n            help = f\"{help}  [{extra_str}]\" if
help else f\"[{extra_str}]\"\n\n        return (\"; \" if any_prefix_is_slash else \" 
/ \").join(rv), help\n\n    def get_help_extra(self, ctx: Context) -> 
types.OptionHelpExtra:\n        extra: types.OptionHelpExtra = {}\n\n        if 
self.show_envvar:\n            envvar = self.envvar\n\n            if envvar is 
None:\n                if (\n                    self.allow_from_autoenv\n            
and ctx.auto_envvar_prefix is not None\n                    and self.name is not 
None\n                ):\n                    envvar = 
f\"{ctx.auto_envvar_prefix}_{self.name.upper()}\"\n\n            if envvar is not 
None:\n                if isinstance(envvar, str):\n                    
extra[\"envvars\"] = (envvar,)\n                else:\n                    
extra[\"envvars\"] = tuple(str(d) for d in envvar)\n\n        # Temporarily enable 
resilient parsing to avoid type casting\n        # failing for the default. Might be 
possible to extend this to\n        # help formatting in general.\n        resilient =
ctx.resilient_parsing\n        ctx.resilient_parsing = True\n\n        try:\n         
default_value = self.get_default(ctx, call=False)\n        finally:\n            
ctx.resilient_parsing = resilient\n\n        show_default = False\n        
show_default_is_str = False\n\n        if self.show_default is not None:\n            
if isinstance(self.show_default, str):\n                show_default_is_str = 
show_default = True\n            else:\n                show_default = 
self.show_default\n        elif ctx.show_default is not None:\n            
show_default = ctx.show_default\n\n        if show_default_is_str or (show_default and
(default_value is not None)):\n            if show_default_is_str:\n                
default_string = f\"({self.show_default})\"\n            elif 
isinstance(default_value, (list, tuple)):\n                default_string = \", 
\".join(str(d) for d in default_value)\n            elif isinstance(default_value, 
enum.Enum):\n                default_string = default_value.name\n            elif 
inspect.isfunction(default_value):\n                default_string = 
_(\"(dynamic)\")\n            elif self.is_bool_flag and self.secondary_opts:\n       
# For boolean flags that have distinct True/False opts,\n                # use the opt
without prefix instead of the value.\n                default_string = _split_opt(\n  
(self.opts if default_value else self.secondary_opts)[0]\n                )[1]\n      
elif self.is_bool_flag and not self.secondary_opts and not default_value:\n           
default_string = \"\"\n            elif default_value == \"\":\n                
default_string = '\"\"'\n            else:\n                default_string = 
str(default_value)\n\n            if default_string:\n                
extra[\"default\"] = default_string\n\n        if (\n            isinstance(self.type,
types._NumberRangeBase)\n            # skip count with default range type\n           
and not (self.count and self.type.min == 0 and self.type.max is None)\n        ):\n   
range_str = self.type._describe_range()\n\n            if range_str:\n                
extra[\"range\"] = range_str\n\n        if self.required:\n            
extra[\"required\"] = \"required\"\n\n        return extra\n\n    @t.overload\n    def
get_default(\n        self, ctx: Context, call: t.Literal[True] = True\n    ) -> t.Any
| None: ...\n\n    @t.overload\n    def get_default(\n        self, ctx: Context, 
call: bool = ...\n    ) -> t.Any | t.Callable[[], t.Any] | None: ...\n\n    def 
get_default(\n        self, ctx: Context, call: bool = True\n    ) -> t.Any | 
t.Callable[[], t.Any] | None:\n        # If we're a non boolean flag our default is 
more complex because\n        # we need to look at all flags in the same group to 
figure out\n        # if we're the default one in which case we return the flag\n     
# value as default.\n        if self.is_flag and not self.is_bool_flag:\n            
for param in ctx.command.params:\n                if param.name == self.name and 
param.default is not None:\n                    return t.cast(Option, 
param).default\n\n            return None\n\n        return super().get_default(ctx, 
call=call)\n\n    def prompt_for_value(self, ctx: Context) -> t.Any:\n        
\"\"\"This is an alternative flow that can be activated in the full\n        value 
processing if a value does not exist.  It will prompt the\n        user until a valid 
value exists and then returns the processed\n        value as result.\n        
\"\"\"\n        assert self.prompt is not None\n\n        # Calculate the default 
before prompting anything to be stable.\n        default = self.get_default(ctx)\n\n  
# If this is a prompt for a flag we need to handle this\n        # differently.\n     
if self.is_bool_flag:\n            return confirm(self.prompt, default)\n\n        # 
If show_default is set to True/False, provide this to `prompt` as well. For\n        #
non-bool values of `show_default`, we use `prompt`'s default behavior\n        
prompt_kwargs: t.Any = {}\n        if isinstance(self.show_default, bool):\n          
prompt_kwargs[\"show_default\"] = self.show_default\n\n        return prompt(\n       
self.prompt,\n            default=default,\n            type=self.type,\n            
hide_input=self.hide_input,\n            show_choices=self.show_choices,\n            
confirmation_prompt=self.confirmation_prompt,\n            value_proc=lambda x: 
self.process_value(ctx, x),\n            **prompt_kwargs,\n        )\n\n    def 
resolve_envvar_value(self, ctx: Context) -> str | None:\n        \"\"\"Find which 
environment variable to read for this option and return\n        its value.\n\n       
Returns the value of the environment variable if it exists, or ``None``\n        if it
does not.\n\n        .. caution::\n\n            The raw value extracted from the 
environment is not normalized and\n            is returned as-is. Any normalization or
reconciation with the\n            option's type should happen later.\n        
\"\"\"\n        rv = super().resolve_envvar_value(ctx)\n\n        if rv is not None:\n
return rv\n\n        if (\n            self.allow_from_autoenv\n            and 
ctx.auto_envvar_prefix is not None\n            and self.name is not None\n        
):\n            envvar = f\"{ctx.auto_envvar_prefix}_{self.name.upper()}\"\n          
rv = os.environ.get(envvar)\n\n            if rv:\n                return rv\n\n      
return None\n\n    def value_from_envvar(self, ctx: Context) -> t.Any | None:\n       
\"\"\"Normalize the value from the environment variable, if it exists.\"\"\"\n        
rv: str | None = self.resolve_envvar_value(ctx)\n\n        if rv is None:\n           
return None\n\n        # Non-boolean flags are more liberal in what they accept. But a
flag being a\n        # flag, its envvar value still needs to analyzed to determine if
the flag is\n        # activated or not.\n        if self.is_flag and not 
self.is_bool_flag:\n            # If the flag_value is set and match the envvar value,
return it\n            # directly.\n            if self.flag_value is not None and rv 
== self.flag_value:\n                return self.flag_value\n            # Analyze the
envvar value as a boolean to know if the flag is\n            # activated or not.\n   
return types.BoolParamType.str_to_bool(rv)\n\n        # Split the envvar value if it 
is allowed to be repeated.\n        value_depth = (self.nargs != 1) + 
bool(self.multiple)\n        if value_depth > 0:\n            multi_rv = 
self.type.split_envvar_value(rv)\n            if self.multiple and self.nargs != 1:\n 
multi_rv = batch(multi_rv, self.nargs)  # type: ignore\n\n            return 
multi_rv\n\n        return rv\n\n    def consume_value(\n        self, ctx: Context, 
opts: cabc.Mapping\n    ) -> tuple:\n        value, source = 
super().consume_value(ctx, opts)\n\n        # The parser will emit a sentinel value if
the option can be\n        # given as a flag without a value. This is different from 
None\n        # to distinguish from the flag not being given at all.\n        if value
is _flag_needs_value:\n            if self.prompt is not None and not 
ctx.resilient_parsing:\n                value = self.prompt_for_value(ctx)\n          
source = ParameterSource.PROMPT\n            else:\n                value = 
self.flag_value\n                source = ParameterSource.COMMANDLINE\n\n        # A 
flag which is activated and has a flag_value set, should returns\n        # the 
latter, unless the value comes from the explicitly sets default.\n        elif (\n    
self.is_flag\n            and value is True\n            and not self.is_bool_flag\n  
and self.flag_value is not None\n            and source is not 
ParameterSource.DEFAULT\n        ):\n            value = self.flag_value\n\n        
elif (\n            self.multiple\n            and value is not None\n            and 
any(v is _flag_needs_value for v in value)\n        ):\n            value = \n        
source = ParameterSource.COMMANDLINE\n\n        # The value wasn't set, or used the 
param's default, prompt if\n        # prompting is enabled.\n        elif (\n         
source in {None, ParameterSource.DEFAULT}\n            and self.prompt is not None\n  
and (self.required or self.prompt_required)\n            and not 
ctx.resilient_parsing\n        ):\n            value = self.prompt_for_value(ctx)\n   
source = ParameterSource.PROMPT\n\n        return value, source"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2533, "end_line": 2669, "size": 137, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
param_decls: cabc.Sequence | None = None,\n        show_default: bool | str | None = 
None,\n        prompt: bool | str = False,\n        confirmation_prompt: bool | str = 
False,\n        prompt_required: bool = True,\n        hide_input: bool = False,\n    
is_flag: bool | None = None,\n        flag_value: t.Any | None = None,\n        
multiple: bool = False,\n        count: bool = False,\n        allow_from_autoenv: 
bool = True,\n        type: types.ParamType | t.Any | None = None,\n        help: str 
| None = None,\n        hidden: bool = False,\n        show_choices: bool = True,\n   
show_envvar: bool = False,\n        deprecated: bool | str = False,\n        **attrs: 
t.Any,\n    ) -> None:\n        if help:\n            help = 
inspect.cleandoc(help)\n\n        super().__init__(\n            param_decls, 
type=type, multiple=multiple, deprecated=deprecated, **attrs\n        )\n\n        if 
prompt is True:\n            if self.name is None:\n                raise 
TypeError(\"'name' is required with 'prompt=True'.\")\n\n            prompt_text: str 
| None = self.name.replace(\"_\", \" \").capitalize()\n        elif prompt is False:\n
prompt_text = None\n        else:\n            prompt_text = prompt\n\n        if 
deprecated:\n            deprecated_message = (\n                f\"(DEPRECATED: 
{deprecated})\"\n                if isinstance(deprecated, str)\n                else 
\"(DEPRECATED)\"\n            )\n            help = help + deprecated_message if help 
is not None else deprecated_message\n\n        self.prompt = prompt_text\n        
self.confirmation_prompt = confirmation_prompt\n        self.prompt_required = 
prompt_required\n        self.hide_input = hide_input\n        self.hidden = 
hidden\n\n        # If prompt is enabled but not required, then the option can be\n   
# used as a flag to indicate using prompt or flag_value.\n        
self._flag_needs_value = self.prompt is not None and not self.prompt_required\n\n     
if is_flag is None:\n            # Implicitly a flag because flag_value was set.\n    
if flag_value is not None:\n                is_flag = True\n            # Not a flag, 
but when used as a flag it shows a prompt.\n            elif self._flag_needs_value:\n
is_flag = False\n            # Implicitly a flag because flag options were given.\n   
elif self.secondary_opts:\n                is_flag = True\n        elif is_flag is 
False and not self._flag_needs_value:\n            # Not a flag, and prompt is not 
enabled, can be used as a\n            # flag if flag_value is set.\n            
self._flag_needs_value = flag_value is not None\n\n        self.default: t.Any | 
t.Callable[[], t.Any]\n\n        if is_flag:\n            # Set missing default for 
flags if not explicitly required or prompted.\n            if self.default is None and
not self.required and not self.prompt:\n                if multiple:\n                
self.default = ()\n                else:\n                    self.default = False\n\n
if flag_value is None:\n                # A boolean flag presence in the command line 
is enough to set\n                # the value: to the default if it is not blank, or 
to True\n                # otherwise.\n                flag_value = self.default if 
self.default else True\n\n        self.type: types.ParamType\n        if is_flag and 
type is None:\n            # Re-guess the type from the flag value instead of the\n   
# default.\n            self.type = types.convert_type(None, flag_value)\n\n        
self.is_flag: bool = bool(is_flag)\n        self.is_bool_flag: bool = bool(\n         
is_flag and isinstance(self.type, types.BoolParamType)\n        )\n        
self.flag_value: t.Any = flag_value\n\n        # Counting\n        self.count = 
count\n        if count:\n            if type is None:\n                self.type = 
types.IntRange(min=0)\n            if self.default is None:\n                
self.default = 0\n\n        self.allow_from_autoenv = allow_from_autoenv\n        
self.help = help\n        self.show_default = show_default\n        self.show_choices 
= show_choices\n        self.show_envvar = show_envvar\n\n        if __debug__:\n     
if deprecated and prompt:\n                raise ValueError(\"`deprecated` options 
cannot use `prompt`.\")\n\n            if self.nargs == -1:\n                raise 
TypeError(\"nargs=-1 is not supported for options.\")\n\n            if self.prompt 
and self.is_flag and not self.is_bool_flag:\n                raise 
TypeError(\"'prompt' is not valid for non-boolean flag.\")\n\n            if not 
self.is_bool_flag and self.secondary_opts:\n                raise 
TypeError(\"Secondary flag is not valid for non-boolean flag.\")\n\n            if 
self.is_bool_flag and self.hide_input and self.prompt is not None:\n                
raise TypeError(\n                    \"'prompt' with 'hide_input' is not valid for 
boolean flag.\"\n                )\n\n            if self.count:\n                if 
self.multiple:\n                    raise TypeError(\"'count' is not valid with 
'multiple'.\")\n\n                if self.is_flag:\n                    raise 
TypeError(\"'count' is not valid with 'is_flag'.\")"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2671, "end_line": 2681, "size": 11, 
"parent_context": "class_definition", "content": "def to_info_dict(self) -> dict:\n   
info_dict = super().to_info_dict()\n        info_dict.update(\n            
help=self.help,\n            prompt=self.prompt,\n            is_flag=self.is_flag,\n 
flag_value=self.flag_value,\n            count=self.count,\n            
hidden=self.hidden,\n        )\n        return info_dict"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2683, "end_line": 2687, "size": 5, 
"parent_context": "class_definition", "content": "def get_error_hint(self, ctx: 
Context) -> str:\n        result = super().get_error_hint(ctx)\n        if 
self.show_envvar:\n            result += f\" (env var: '{self.envvar}')\"\n        
return result"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2689, "end_line": 2742, "size": 54, 
"parent_context": "class_definition", "content": "def _parse_decls(\n        self, 
decls: cabc.Sequence, expose_value: bool\n    ) -> tuple[str | None, list, list]:\n   
opts = []\n        secondary_opts = []\n        name = None\n        possible_names = 
[]\n\n        for decl in decls:\n            if decl.isidentifier():\n               
if name is not None:\n                    raise TypeError(f\"Name '{name}' defined 
twice\")\n                name = decl\n            else:\n                split_char =
\";\" if decl[:1] == \"/\" else \"/\"\n                if split_char in decl:\n       
first, second = decl.split(split_char, 1)\n                    first = 
first.rstrip()\n                    if first:\n                        
possible_names.append(_split_opt(first))\n                        opts.append(first)\n
second = second.lstrip()\n                    if second:\n                        
secondary_opts.append(second.lstrip())\n                    if first == second:\n     
raise ValueError(\n                            f\"Boolean option {decl!r} cannot use 
the\"\n                            \" same flag for true/false.\"\n                   
)\n                else:\n                    
possible_names.append(_split_opt(decl))\n                    opts.append(decl)\n\n    
if name is None and possible_names:\n            possible_names.sort(key=lambda x: 
-len(x[0]))  # group long options first\n            name = 
possible_names[0][1].replace(\"-\", \"_\").lower()\n            if not 
name.isidentifier():\n                name = None\n\n        if name is None:\n       
if not expose_value:\n                return None, opts, secondary_opts\n            
raise TypeError(\n                f\"Could not determine name for option with 
declarations {decls!r}\"\n            )\n\n        if not opts and not 
secondary_opts:\n            raise TypeError(\n                f\"No options defined 
but a name was passed ({name}).\"\n                \" Did you mean to declare an 
argument instead? Did\"\n                f\" you mean to pass '--{name}'?\"\n         
)\n\n        return name, opts, secondary_opts"}
{"file": "click/src/click/core.py", "language": "python", "node_type": "lambda", 
"start_line": 2723, "end_line": 2723, "size": 1, "parent_context": 
"function_definition", "content": "lambda x: -len(x[0])"}
{"file": "click/src/click/core.py", "language": "python", "node_type": "lambda", 
"start_line": 2723, "end_line": 2723, "size": 1, "parent_context": "lambda", 
"content": "lambda"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2744, "end_line": 2781, "size": 38, 
"parent_context": "class_definition", "content": "def add_to_parser(self, parser: 
_OptionParser, ctx: Context) -> None:\n        if self.multiple:\n            action =
\"append\"\n        elif self.count:\n            action = \"count\"\n        else:\n 
action = \"store\"\n\n        if self.is_flag:\n            action = 
f\"{action}_const\"\n\n            if self.is_bool_flag and self.secondary_opts:\n    
parser.add_option(\n                    obj=self, opts=self.opts, dest=self.name, 
action=action, const=True\n                )\n                parser.add_option(\n    
obj=self,\n                    opts=self.secondary_opts,\n                    
dest=self.name,\n                    action=action,\n                    
const=False,\n                )\n            else:\n                
parser.add_option(\n                    obj=self,\n                    
opts=self.opts,\n                    dest=self.name,\n                    
action=action,\n                    const=self.flag_value,\n                )\n       
else:\n            parser.add_option(\n                obj=self,\n                
opts=self.opts,\n                dest=self.name,\n                action=action,\n    
nargs=self.nargs,\n            )"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2783, "end_line": 2826, "size": 44, 
"parent_context": "class_definition", "content": "def get_help_record(self, ctx: 
Context) -> tuple | None:\n        if self.hidden:\n            return None\n\n       
any_prefix_is_slash = False\n\n        def _write_opts(opts: cabc.Sequence) -> str:\n 
nonlocal any_prefix_is_slash\n\n            rv, any_slashes = join_options(opts)\n\n  
if any_slashes:\n                any_prefix_is_slash = True\n\n            if not 
self.is_flag and not self.count:\n                rv += f\" 
{self.make_metavar(ctx=ctx)}\"\n\n            return rv\n\n        rv = 
[_write_opts(self.opts)]\n\n        if self.secondary_opts:\n            
rv.append(_write_opts(self.secondary_opts))\n\n        help = self.help or \"\"\n\n   
extra = self.get_help_extra(ctx)\n        extra_items = []\n        if \"envvars\" in 
extra:\n            extra_items.append(\n                _(\"env var: 
{var}\").format(var=\", \".join(extra[\"envvars\"]))\n            )\n        if 
\"default\" in extra:\n            extra_items.append(_(\"default: 
{default}\").format(default=extra[\"default\"]))\n        if \"range\" in extra:\n    
extra_items.append(extra[\"range\"])\n        if \"required\" in extra:\n            
extra_items.append(_(extra[\"required\"]))\n\n        if extra_items:\n            
extra_str = \"; \".join(extra_items)\n            help = f\"{help}  [{extra_str}]\" if
help else f\"[{extra_str}]\"\n\n        return (\"; \" if any_prefix_is_slash else \" 
/ \").join(rv), help"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2789, "end_line": 2800, "size": 12, 
"parent_context": "function_definition", "content": "def _write_opts(opts: 
cabc.Sequence) -> str:\n            nonlocal any_prefix_is_slash\n\n            rv, 
any_slashes = join_options(opts)\n\n            if any_slashes:\n                
any_prefix_is_slash = True\n\n            if not self.is_flag and not self.count:\n   
rv += f\" {self.make_metavar(ctx=ctx)}\"\n\n            return rv"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2828, "end_line": 2908, "size": 81, 
"parent_context": "class_definition", "content": "def get_help_extra(self, ctx: 
Context) -> types.OptionHelpExtra:\n        extra: types.OptionHelpExtra = {}\n\n     
if self.show_envvar:\n            envvar = self.envvar\n\n            if envvar is 
None:\n                if (\n                    self.allow_from_autoenv\n            
and ctx.auto_envvar_prefix is not None\n                    and self.name is not 
None\n                ):\n                    envvar = 
f\"{ctx.auto_envvar_prefix}_{self.name.upper()}\"\n\n            if envvar is not 
None:\n                if isinstance(envvar, str):\n                    
extra[\"envvars\"] = (envvar,)\n                else:\n                    
extra[\"envvars\"] = tuple(str(d) for d in envvar)\n\n        # Temporarily enable 
resilient parsing to avoid type casting\n        # failing for the default. Might be 
possible to extend this to\n        # help formatting in general.\n        resilient =
ctx.resilient_parsing\n        ctx.resilient_parsing = True\n\n        try:\n         
default_value = self.get_default(ctx, call=False)\n        finally:\n            
ctx.resilient_parsing = resilient\n\n        show_default = False\n        
show_default_is_str = False\n\n        if self.show_default is not None:\n            
if isinstance(self.show_default, str):\n                show_default_is_str = 
show_default = True\n            else:\n                show_default = 
self.show_default\n        elif ctx.show_default is not None:\n            
show_default = ctx.show_default\n\n        if show_default_is_str or (show_default and
(default_value is not None)):\n            if show_default_is_str:\n                
default_string = f\"({self.show_default})\"\n            elif 
isinstance(default_value, (list, tuple)):\n                default_string = \", 
\".join(str(d) for d in default_value)\n            elif isinstance(default_value, 
enum.Enum):\n                default_string = default_value.name\n            elif 
inspect.isfunction(default_value):\n                default_string = 
_(\"(dynamic)\")\n            elif self.is_bool_flag and self.secondary_opts:\n       
# For boolean flags that have distinct True/False opts,\n                # use the opt
without prefix instead of the value.\n                default_string = _split_opt(\n  
(self.opts if default_value else self.secondary_opts)[0]\n                )[1]\n      
elif self.is_bool_flag and not self.secondary_opts and not default_value:\n           
default_string = \"\"\n            elif default_value == \"\":\n                
default_string = '\"\"'\n            else:\n                default_string = 
str(default_value)\n\n            if default_string:\n                
extra[\"default\"] = default_string\n\n        if (\n            isinstance(self.type,
types._NumberRangeBase)\n            # skip count with default range type\n           
and not (self.count and self.type.min == 0 and self.type.max is None)\n        ):\n   
range_str = self.type._describe_range()\n\n            if range_str:\n                
extra[\"range\"] = range_str\n\n        if self.required:\n            
extra[\"required\"] = \"required\"\n\n        return extra"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 2910, "end_line": 2913, "size": 4, 
"parent_context": "class_definition", "content": "@t.overload\n    def get_default(\n 
self, ctx: Context, call: t.Literal[True] = True\n    ) -> t.Any | None: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2911, "end_line": 2913, "size": 3, 
"parent_context": "decorated_definition", "content": "def get_default(\n        self, 
ctx: Context, call: t.Literal[True] = True\n    ) -> t.Any | None: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 2915, "end_line": 2918, "size": 4, 
"parent_context": "class_definition", "content": "@t.overload\n    def get_default(\n 
self, ctx: Context, call: bool = ...\n    ) -> t.Any | t.Callable[[], t.Any] | None: 
..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2916, "end_line": 2918, "size": 3, 
"parent_context": "decorated_definition", "content": "def get_default(\n        self, 
ctx: Context, call: bool = ...\n    ) -> t.Any | t.Callable[[], t.Any] | None: ..."}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2920, "end_line": 2934, "size": 15, 
"parent_context": "class_definition", "content": "def get_default(\n        self, ctx:
Context, call: bool = True\n    ) -> t.Any | t.Callable[[], t.Any] | None:\n        # 
If we're a non boolean flag our default is more complex because\n        # we need to 
look at all flags in the same group to figure out\n        # if we're the default one 
in which case we return the flag\n        # value as default.\n        if self.is_flag
and not self.is_bool_flag:\n            for param in ctx.command.params:\n            
if param.name == self.name and param.default is not None:\n                    return 
t.cast(Option, param).default\n\n            return None\n\n        return 
super().get_default(ctx, call=call)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2936, "end_line": 2967, "size": 32, 
"parent_context": "class_definition", "content": "def prompt_for_value(self, ctx: 
Context) -> t.Any:\n        \"\"\"This is an alternative flow that can be activated in
the full\n        value processing if a value does not exist.  It will prompt the\n   
user until a valid value exists and then returns the processed\n        value as 
result.\n        \"\"\"\n        assert self.prompt is not None\n\n        # Calculate
the default before prompting anything to be stable.\n        default = 
self.get_default(ctx)\n\n        # If this is a prompt for a flag we need to handle 
this\n        # differently.\n        if self.is_bool_flag:\n            return 
confirm(self.prompt, default)\n\n        # If show_default is set to True/False, 
provide this to `prompt` as well. For\n        # non-bool values of `show_default`, we
use `prompt`'s default behavior\n        prompt_kwargs: t.Any = {}\n        if 
isinstance(self.show_default, bool):\n            prompt_kwargs[\"show_default\"] = 
self.show_default\n\n        return prompt(\n            self.prompt,\n            
default=default,\n            type=self.type,\n            
hide_input=self.hide_input,\n            show_choices=self.show_choices,\n            
confirmation_prompt=self.confirmation_prompt,\n            value_proc=lambda x: 
self.process_value(ctx, x),\n            **prompt_kwargs,\n        )"}
{"file": "click/src/click/core.py", "language": "python", "node_type": "lambda", 
"start_line": 2965, "end_line": 2965, "size": 1, "parent_context": 
"function_definition", "content": "lambda x: self.process_value(ctx, x)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": "lambda", 
"start_line": 2965, "end_line": 2965, "size": 1, "parent_context": "lambda", 
"content": "lambda"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 2969, "end_line": 2998, "size": 30, 
"parent_context": "class_definition", "content": "def resolve_envvar_value(self, ctx: 
Context) -> str | None:\n        \"\"\"Find which environment variable to read for 
this option and return\n        its value.\n\n        Returns the value of the 
environment variable if it exists, or ``None``\n        if it does not.\n\n        .. 
caution::\n\n            The raw value extracted from the environment is not 
normalized and\n            is returned as-is. Any normalization or reconciation with 
the\n            option's type should happen later.\n        \"\"\"\n        rv = 
super().resolve_envvar_value(ctx)\n\n        if rv is not None:\n            return 
rv\n\n        if (\n            self.allow_from_autoenv\n            and 
ctx.auto_envvar_prefix is not None\n            and self.name is not None\n        
):\n            envvar = f\"{ctx.auto_envvar_prefix}_{self.name.upper()}\"\n          
rv = os.environ.get(envvar)\n\n            if rv:\n                return rv\n\n      
return None"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 3000, "end_line": 3028, "size": 29, 
"parent_context": "class_definition", "content": "def value_from_envvar(self, ctx: 
Context) -> t.Any | None:\n        \"\"\"Normalize the value from the environment 
variable, if it exists.\"\"\"\n        rv: str | None = 
self.resolve_envvar_value(ctx)\n\n        if rv is None:\n            return None\n\n 
# Non-boolean flags are more liberal in what they accept. But a flag being a\n        
# flag, its envvar value still needs to analyzed to determine if the flag is\n        
# activated or not.\n        if self.is_flag and not self.is_bool_flag:\n            #
If the flag_value is set and match the envvar value, return it\n            # 
directly.\n            if self.flag_value is not None and rv == self.flag_value:\n    
return self.flag_value\n            # Analyze the envvar value as a boolean to know if
the flag is\n            # activated or not.\n            return 
types.BoolParamType.str_to_bool(rv)\n\n        # Split the envvar value if it is 
allowed to be repeated.\n        value_depth = (self.nargs != 1) + 
bool(self.multiple)\n        if value_depth > 0:\n            multi_rv = 
self.type.split_envvar_value(rv)\n            if self.multiple and self.nargs != 1:\n 
multi_rv = batch(multi_rv, self.nargs)  # type: ignore\n\n            return 
multi_rv\n\n        return rv"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 3030, "end_line": 3076, "size": 47, 
"parent_context": "class_definition", "content": "def consume_value(\n        self, 
ctx: Context, opts: cabc.Mapping\n    ) -> tuple:\n        value, source = 
super().consume_value(ctx, opts)\n\n        # The parser will emit a sentinel value if
the option can be\n        # given as a flag without a value. This is different from 
None\n        # to distinguish from the flag not being given at all.\n        if value
is _flag_needs_value:\n            if self.prompt is not None and not 
ctx.resilient_parsing:\n                value = self.prompt_for_value(ctx)\n          
source = ParameterSource.PROMPT\n            else:\n                value = 
self.flag_value\n                source = ParameterSource.COMMANDLINE\n\n        # A 
flag which is activated and has a flag_value set, should returns\n        # the 
latter, unless the value comes from the explicitly sets default.\n        elif (\n    
self.is_flag\n            and value is True\n            and not self.is_bool_flag\n  
and self.flag_value is not None\n            and source is not 
ParameterSource.DEFAULT\n        ):\n            value = self.flag_value\n\n        
elif (\n            self.multiple\n            and value is not None\n            and 
any(v is _flag_needs_value for v in value)\n        ):\n            value = \n        
source = ParameterSource.COMMANDLINE\n\n        # The value wasn't set, or used the 
param's default, prompt if\n        # prompting is enabled.\n        elif (\n         
source in {None, ParameterSource.DEFAULT}\n            and self.prompt is not None\n  
and (self.required or self.prompt_required)\n            and not 
ctx.resilient_parsing\n        ):\n            value = self.prompt_for_value(ctx)\n   
source = ParameterSource.PROMPT\n\n        return value, source"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"class_definition", "start_line": 3079, "end_line": 3154, "size": 76, 
"parent_context": "", "content": "class Argument(Parameter):\n    \"\"\"Arguments are 
positional parameters to a command.  They generally\n    provide fewer features than 
options but can have infinite ``nargs``\n    and are required by default.\n\n    All 
parameters are passed onwards to the constructor of :class:`Parameter`.\n    
\"\"\"\n\n    param_type_name = \"argument\"\n\n    def __init__(\n        self,\n    
param_decls: cabc.Sequence,\n        required: bool | None = None,\n        **attrs: 
t.Any,\n    ) -> None:\n        if required is None:\n            if 
attrs.get(\"default\") is not None:\n                required = False\n            
else:\n                required = attrs.get(\"nargs\", 1) > 0\n\n        if 
\"multiple\" in attrs:\n            raise TypeError(\"__init__() got an unexpected 
keyword argument 'multiple'.\")\n\n        super().__init__(param_decls, 
required=required, **attrs)\n\n        if __debug__:\n            if self.default is 
not None and self.nargs == -1:\n                raise TypeError(\"'default' is not 
supported for nargs=-1.\")\n\n    @property\n    def human_readable_name(self) -> 
str:\n        if self.metavar is not None:\n            return self.metavar\n        
return self.name.upper()  # type: ignore\n\n    def make_metavar(self, ctx: Context) 
-> str:\n        if self.metavar is not None:\n            return self.metavar\n      
var = self.type.get_metavar(param=self, ctx=ctx)\n        if not var:\n            var
= self.name.upper()  # type: ignore\n        if self.deprecated:\n            var += 
\"!\"\n        if not self.required:\n            var = f\"[{var}]\"\n        if 
self.nargs != 1:\n            var += \"...\"\n        return var\n\n    def 
_parse_decls(\n        self, decls: cabc.Sequence, expose_value: bool\n    ) -> 
tuple[str | None, list, list]:\n        if not decls:\n            if not 
expose_value:\n                return None, [], []\n            raise 
TypeError(\"Argument is marked as exposed, but does not have a name.\")\n        if 
len(decls) == 1:\n            name = arg = decls[0]\n            name = 
name.replace(\"-\", \"_\").lower()\n        else:\n            raise TypeError(\n     
\"Arguments take exactly one parameter declaration, got\"\n                f\" 
{len(decls)}: {decls}.\"\n            )\n        return name, , []\n\n    def 
get_usage_pieces(self, ctx: Context) -> list:\n        return \n\n    def 
get_error_hint(self, ctx: Context) -> str:\n        return 
f\"'{self.make_metavar(ctx)}'\"\n\n    def add_to_parser(self, parser: _OptionParser, 
ctx: Context) -> None:\n        parser.add_argument(dest=self.name, nargs=self.nargs, 
obj=self)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 3089, "end_line": 3108, "size": 20, 
"parent_context": "class_definition", "content": "def __init__(\n        self,\n      
param_decls: cabc.Sequence,\n        required: bool | None = None,\n        **attrs: 
t.Any,\n    ) -> None:\n        if required is None:\n            if 
attrs.get(\"default\") is not None:\n                required = False\n            
else:\n                required = attrs.get(\"nargs\", 1) > 0\n\n        if 
\"multiple\" in attrs:\n            raise TypeError(\"__init__() got an unexpected 
keyword argument 'multiple'.\")\n\n        super().__init__(param_decls, 
required=required, **attrs)\n\n        if __debug__:\n            if self.default is 
not None and self.nargs == -1:\n                raise TypeError(\"'default' is not 
supported for nargs=-1.\")"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"decorated_definition", "start_line": 3110, "end_line": 3114, "size": 5, 
"parent_context": "class_definition", "content": "@property\n    def 
human_readable_name(self) -> str:\n        if self.metavar is not None:\n            
return self.metavar\n        return self.name.upper()  # type: ignore"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 3111, "end_line": 3114, "size": 4, 
"parent_context": "decorated_definition", "content": "def human_readable_name(self) ->
str:\n        if self.metavar is not None:\n            return self.metavar\n        
return self.name.upper()  # type: ignore"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 3116, "end_line": 3128, "size": 13, 
"parent_context": "class_definition", "content": "def make_metavar(self, ctx: Context)
-> str:\n        if self.metavar is not None:\n            return self.metavar\n      
var = self.type.get_metavar(param=self, ctx=ctx)\n        if not var:\n            var
= self.name.upper()  # type: ignore\n        if self.deprecated:\n            var += 
\"!\"\n        if not self.required:\n            var = f\"[{var}]\"\n        if 
self.nargs != 1:\n            var += \"...\"\n        return var"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 3130, "end_line": 3145, "size": 16, 
"parent_context": "class_definition", "content": "def _parse_decls(\n        self, 
decls: cabc.Sequence, expose_value: bool\n    ) -> tuple[str | None, list, list]:\n   
if not decls:\n            if not expose_value:\n                return None, [], []\n
raise TypeError(\"Argument is marked as exposed, but does not have a name.\")\n       
if len(decls) == 1:\n            name = arg = decls[0]\n            name = 
name.replace(\"-\", \"_\").lower()\n        else:\n            raise TypeError(\n     
\"Arguments take exactly one parameter declaration, got\"\n                f\" 
{len(decls)}: {decls}.\"\n            )\n        return name, , []"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 3147, "end_line": 3148, "size": 2, 
"parent_context": "class_definition", "content": "def get_usage_pieces(self, ctx: 
Context) -> list:\n        return "}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 3150, "end_line": 3151, "size": 2, 
"parent_context": "class_definition", "content": "def get_error_hint(self, ctx: 
Context) -> str:\n        return f\"'{self.make_metavar(ctx)}'\""}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 3153, "end_line": 3154, "size": 2, 
"parent_context": "class_definition", "content": "def add_to_parser(self, parser: 
_OptionParser, ctx: Context) -> None:\n        parser.add_argument(dest=self.name, 
nargs=self.nargs, obj=self)"}
{"file": "click/src/click/core.py", "language": "python", "node_type": 
"function_definition", "start_line": 3157, "end_line": 3178, "size": 22, 
"parent_context": "", "content": "def __getattr__(name: str) -> object:\n    import 
warnings\n\n    if name == \"BaseCommand\":\n        warnings.warn(\n            
\"'BaseCommand' is deprecated and will be removed in Click 9.0. Use\"\n            \" 
'Command' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n   
)\n        return _BaseCommand\n\n    if name == \"MultiCommand\":\n        
warnings.warn(\n            \"'MultiCommand' is deprecated and will be removed in 
Click 9.0. Use\"\n            \" 'Group' instead.\",\n            
DeprecationWarning,\n            stacklevel=2,\n        )\n        return 
_MultiCommand\n\n    raise AttributeError(name)"}
